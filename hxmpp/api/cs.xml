<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/cs/_std/Array.hx">
		<ofNative params="X" set="method" line="40" static="1">
			<f a="native">
				<c path="cs.NativeArray"><c path="ofNative.X"/></c>
				<c path="Array"><c path="ofNative.X"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\treturn new Array<X>(native);\n\t"]]></e></m></meta>
		</ofNative>
		<alloc params="Y" set="method" line="48" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="Array"><c path="alloc.Y"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\treturn new Array<Y>(new Y[size]);\n\t"]]></e></m></meta>
		</alloc>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<__a><c path="cs.NativeArray"><c path="Array.T"/></c></__a>
		<concat public="1" set="method" line="59">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.
		
		This operation does not modify `this` Array.
		
		If `a` is the empty Array `[]`, a copy of `this` Array is returned.
		
		The length of the returned Array is equal to the sum of `this.length` 
		and `a.length`.
		
		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<concatNative set="method" line="69"><f a="a">
	<c path="cs.NativeArray"><c path="Array.T"/></c>
	<x path="Void"/>
</f></concatNative>
		<join public="1" set="method" line="87">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.
		
		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`
		
		If `this` is the empty Array `[]`, the result is the empty String `""`. 
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.
		
		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method" line="106">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this.length` will decrease by 1.
		
		If `this` is the empty Array `[]`, null is returned and the length 
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="122">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the offset
		it was added at.
		
		This operation modifies `this` Array in place.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method" line="137">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="153">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.
		
		If `this` is the empty Array `[]`, `null` is returned and the length 
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="169">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.
		
		This operation does not modify `this` Array.
		
		The elements are not copied and retain their identity.
		
		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.
		
		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.
		
		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="191">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies `this` Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.
		
		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<quicksort set="method" line="198"><f a="lo:hi:f">
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="Array.T"/>
		<c path="Array.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></quicksort>
		<splice public="1" set="method" line="219">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.
		
		This operation modifies `this` Array in place.
		
		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].
		
		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.
		
		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<spliceVoid set="method" line="247"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></spliceVoid>
		<toString public="1" set="method" line="270">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="289">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.
		
		This operation modifies `this` Array in place.
		
		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method" line="308">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.
		
		This operation modifies `this` Array in place.
		
		The offset is calculated like so:
			
		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this` 
		  Array, i.e. `this.length + pos`. If this yields a negative value, the 
		  offset is 0.
		- Otherwise, the offset is `pos`.
		
		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="342">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<map public="1" params="S" set="method" line="361">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method" line="368">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<copy public="1" set="method" line="376">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.
		
		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However, 
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="385">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<__get set="method" line="396"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="406"><f a="idx:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__unsafe_get get="inline" set="null" line="426"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__unsafe_get>
		<__unsafe_set get="inline" set="null" line="431"><f a="idx:val">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__unsafe_set>
		<new public="1" set="method" line="53">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a `List` which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":classCode"><e>"\n\tpublic Array(T[] native)\n\t{\n\t\tthis.__a = native;\n\t\tthis.length = native.Length;\n\t}\n"</e></m>
			<m n=":final"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/cs/_std/Date.hx">
		<now public="1" set="method" line="92" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="99" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="106" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<fromNative set="method" line="127" static="1"><f a="d">
	<c path="cs.system.DateTime"/>
	<c path="Date"/>
</f></fromNative>
		<date><c path="cs.system.DateTime"/></date>
		<getTime public="1" get="inline" set="null" line="37">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" get="inline" set="null" line="42">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" get="inline" set="null" line="47">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" get="inline" set="null" line="52">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" get="inline" set="null" line="57">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" get="inline" set="null" line="67">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" get="inline" set="null" line="72">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="77">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="30">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/cs/_std/EReg.hx">
		<regex><c path="cs.system.text.regularExpressions.Regex"/></regex>
		<m><c path="cs.system.text.regularExpressions.Match"/></m>
		<isGlobal><x path="Bool"/></isGlobal>
		<cur><c path="String"/></cur>
		<match public="1" set="method" line="50">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.
		
		This method modifies the internal state.
		
		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="56">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.
		
		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.
		
		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.
		
		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="63">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="67">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="71">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="75">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.matchSub(s.substr(pos,len))` can be used instead.
		
		This method modifies the internal state.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="81">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.
		
		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.
		
		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.
		
		If two matching substrings appear next to each other, the result
		contains the empty String "" between them.
		
		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<start get="inline" set="null" line="89"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></start>
		<len get="inline" set="null" line="94"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></len>
		<replace public="1" set="method" line="99">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.
		
		If `this` EReg does not match any substring, the result is `s`.
		
		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.
		
		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.
		
		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="104">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string `s`, the function `f` is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the `g` flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</map>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.
		
		This is equivalent to the shorthand syntax `~/r/opt`
		
		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="IntIterator" params="" file="/usr/lib/haxe/std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" set="method" line="52">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="61">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.
		
		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" set="method" line="44">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).
		
		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.
	
	It is usually not used explicitly, but through it's special syntax:
	`min...max`
		
	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.
		
		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="54" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.
		
		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="68" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new List by applying function `f` to all elements of `it`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="82" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.
		
		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.
		
		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="115" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.
		
		This function returns true as soon as an element is found for which a
		call to `f` returns true.
		
		If no such element is found, the result is false.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="134" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.
		
		This function returns false as soon as an element is found for which a
		call to `f` returns false.
		
		If no such element is found, the result is true.
		
		In particular, this function always returns true if `it` is empty.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="146" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="159" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.
		
		If `it` is empty, the result is the empty List even if `f` is null.
		
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="179" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.
		
		If `it` has no elements, the result is `first`.
		
		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.
		
		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.
		
		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="206" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.
		
		This function uses operator `==` to check for equality.
		
		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="233" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new List containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<first public="1" set="method" line="81">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</first>
		<last public="1" set="method" line="90">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</last>
		<pop public="1" set="method" line="100">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		The element is removed from `this` List.</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="114">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.
		
		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.
		
		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.
		
		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="203">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` List.
		
		The result is enclosed in { } with the individual elements being
		separated by a comma.</haxe_doc>
		</toString>
		<join public="1" set="method" line="224">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` List, with `sep` separating
		each element.</haxe_doc>
		</join>
		<filter public="1" set="method" line="243">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with `f`. The returned list will contain all
		elements for which `f(x) == true`.</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="259">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted by the
		function `f`.</haxe_doc>
		</map>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
	<_new public="1" set="method" static="1">
		<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="70" static="1">
		<f a="this:key:value">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="87" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<t path="Null"><c path="Map.V"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="102" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
	</iterator>
	<toString public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
	</toString>
	<arrayWrite public="1" get="inline" set="null" line="131" static="1">
		<f a="this:k:v">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<c path="Map.V"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</arrayWrite>
	<toStringMap get="inline" set="null" line="136" static="1">
		<f a="t">
			<c path="IMap">
				<c path="String"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap get="inline" set="null" line="140" static="1">
		<f a="t">
			<c path="IMap">
				<x path="Int"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toEnumValueMapMap>
	<toObjectMap params="K" get="inline" set="null" line="148" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toObjectMap>
	<fromStringMap params="V" get="inline" set="null" line="152" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<fromIntMap params="V" get="inline" set="null" line="156" static="1">
		<f a="map">
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="Map">
				<x path="Int"/>
				<c path="fromIntMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntMap>
	<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
		<f a="map">
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
			<x path="Map">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectMap>
</class></impl>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
		<_new public="1" set="method" static="1">
			<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="70" static="1">
			<f a="this:key:value">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="87" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<t path="Null"><c path="Map.V"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="102" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
		</iterator>
		<toString public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
		</toString>
		<arrayWrite public="1" get="inline" set="null" line="131" static="1">
			<f a="this:k:v">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<c path="Map.V"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</arrayWrite>
		<toStringMap get="inline" set="null" line="136" static="1">
			<f a="t">
				<c path="IMap">
					<c path="String"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap get="inline" set="null" line="140" static="1">
			<f a="t">
				<c path="IMap">
					<x path="Int"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.EnumValueMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toEnumValueMapMap>
		<toObjectMap params="K" get="inline" set="null" line="148" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.ObjectMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toObjectMap>
		<fromStringMap params="V" get="inline" set="null" line="152" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<fromIntMap params="V" get="inline" set="null" line="156" static="1">
			<f a="map">
				<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
				<x path="Map">
					<x path="Int"/>
					<c path="fromIntMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntMap>
		<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
			<f a="map">
				<c path="haxe.ds.ObjectMap">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</c>
				<x path="Map">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectMap>
	</class>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<t path="Null"><c path="IMap.V"/></t>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="IMap.K"/>
	<c path="IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
	</class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="cs.system.Math" params="" file="/usr/lib/haxe/std/cs/system/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<Abs public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Abs>
		<Min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Min>
		<Max public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Max>
		<Sin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Sin>
		<Cos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Cos>
		<Atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Atan2>
		<Tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Tan>
		<Exp public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Exp>
		<Log public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Log>
		<Sqrt public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Sqrt>
		<Round public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Round>
		<Floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Floor>
		<Ceiling public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Ceiling>
		<Atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Atan>
		<Asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Asin>
		<Acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></Acos>
		<Pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Pow>
		<meta>
			<m n=":native"><e>"System.Math"</e></m>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="cs.system.Random" params="" file="/usr/lib/haxe/std/cs/system/Random.hx" extern="1">
		<Next public="1" set="method">
			<f a=""><x path="Int"/></f>
			<overloads>
				<Next public="1" set="method"><f a="max">
	<x path="Int"/>
	<x path="Int"/>
</f></Next>
				<Next public="1" set="method"><f a="min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Next>
			</overloads>
		</Next>
		<NextDouble public="1" set="method"><f a=""><x path="Float"/></f></NextDouble>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"System.Random"</e></m></meta>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/cs/_std/Math.hx">
		<rand static="1"><c path="cs.system.Random"/></rand>
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<abs public="1" get="inline" set="null" line="43" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.
		
		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" get="inline" set="null" line="48" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" get="inline" set="null" line="53" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" get="inline" set="null" line="58" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" get="inline" set="null" line="63" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<atan2 public="1" get="inline" set="null" line="68" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<tan public="1" get="inline" set="null" line="73" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<exp public="1" get="inline" set="null" line="78" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" get="inline" set="null" line="83" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<sqrt public="1" get="inline" set="null" line="88" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<fround public="1" get="inline" set="null" line="93" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<ffloor public="1" get="inline" set="null" line="98" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="103" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<round public="1" set="method" line="108" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" get="inline" set="null" line="121" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="126" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<atan public="1" get="inline" set="null" line="131" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<asin public="1" get="inline" set="null" line="136" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" get="inline" set="null" line="141" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<pow public="1" get="inline" set="null" line="146" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" get="inline" set="null" line="151" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<isFinite public="1" set="method" line="156" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.
		
		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" line="161" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.
		
		If `f` is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cs/_std/Reflect.hx">
		<hasField public="1" set="method" line="56" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o is haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, haxe.lang.FieldLookup.hash(field), false, true, false) != haxe.lang.Runtime.undefined;\n\n\t\treturn haxe.lang.Runtime.slowHasField(o, field);\n\t"</e></m></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.
		
		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="67" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o is haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, haxe.lang.FieldLookup.hash(field), false, false, false);\n\n\t\treturn haxe.lang.Runtime.slowGetField(o, field, false);\n\t"</e></m></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" line="78" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o is haxe.lang.IHxObject)\n\t\t\t((haxe.lang.IHxObject) o).__hx_setField(field, haxe.lang.FieldLookup.hash(field), value, false);\n\t\telse\n\t\t\thaxe.lang.Runtime.slowSetField(o, field, value);\n\t"</e></m></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.
		
		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.
		
		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="92" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o is haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, haxe.lang.FieldLookup.hash(field), false, false, true);\n\n\t\tif (haxe.lang.Runtime.slowHasField(o, \"get_\" + field))\n\t\t\treturn haxe.lang.Runtime.slowCallField(o, \"get_\" + field, null);\n\n\t\treturn haxe.lang.Runtime.slowGetField(o, field, false);\n\t"</e></m></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="105" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (o is haxe.lang.IHxObject)\n\t\t\t((haxe.lang.IHxObject) o).__hx_setField(field, haxe.lang.FieldLookup.hash(field), value, true);\n\t\telse if (haxe.lang.Runtime.slowHasField(o, \"set_\" + field))\n\t\t\thaxe.lang.Runtime.slowCallField(o, \"set_\" + field, new Array<object>(new object[]{value}));\n\t\telse\n\t\t\thaxe.lang.Runtime.slowSetField(o, field, value);\n\t"]]></e></m></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.
		
		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="113" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn ((haxe.lang.Function) func).__hx_invokeDynamic(args);\n\t"</e></m></meta>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="130" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (o is haxe.lang.IHxObject)\n\t\t{\n\t\t\tArray<object> ret = new Array<object>();\n\t\t\t\t((haxe.lang.IHxObject) o).__hx_getFields(ret);\n\t\t\treturn ret;\n\t\t} else if (o is System.Type) {\n\t\t\treturn Type.getClassFields( (System.Type) o);\n\t\t} else {\n\t\t\treturn new Array<object>();\n\t\t}\n\t"]]></e></m></meta>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="138" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn f is haxe.lang.Function;\n\t"</e></m></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="146" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn haxe.lang.Runtime.compare(a, b);\n\t"</e></m></meta>
			<haxe_doc>Compares `a` and `b`.
		
		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.
		
		This function is only defined if `a` and `b` are of the same type.
		
		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.
		
		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:
		
		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified
		
		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="165" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\n\t\tif (f1 is haxe.lang.Closure && f2 is haxe.lang.Closure)\n\t\t{\n\t\t\thaxe.lang.Closure f1c = (haxe.lang.Closure) f1;\n\t\t\thaxe.lang.Closure f2c = (haxe.lang.Closure) f2;\n\n\t\t\treturn haxe.lang.Runtime.refEq(f1c.obj, f2c.obj) && f1c.field.Equals(f2c.field);\n\t\t}\n\n\t\treturn false;\n\t"]]></e></m></meta>
			<haxe_doc>Compares the functions `f1` and `f2`.
		
		If `f1` or `f2` are not functions, the result is unspecified.
		
		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="173" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn v != null && !(v is haxe.lang.Enum || v is haxe.lang.Function || v is System.ValueType);\n\t"]]></e></m></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.
		
		The result is true if `v` is one of the following:
			
		- class instance
		- structure
		- Class<T>
		- Enum<T>
			
		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="181" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn v != null && (v is haxe.lang.Enum || v is System.Enum);\n\t"]]></e></m></meta>
			<haxe_doc>Tells if `v` is an enum value.
		
		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.
		
		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="191" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn (o is haxe.lang.DynamicObject && ((haxe.lang.DynamicObject) o).__hx_deleteField(field, haxe.lang.FieldLookup.hash(field)));\n\t"]]></e></m></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.
		
		This method is only guaranteed to work on anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="196" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.
		
		This is only guaranteed to work on anonymous structures.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="205" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cs/_std/Std.hx">
		<is public="1" set="method" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="55" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="64" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="68" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="136" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="237" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/cs/_std/String.hx" extern="1">
		<Compare set="method" static="1"><f a="s1:s2">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></Compare>
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<Replace set="method"><f a="oldValue:newValue">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Replace>
		<StartsWith set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></StartsWith>
		<EndsWith set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></EndsWith>
		<TrimStart set="method"><f a=""><c path="String"/></f></TrimStart>
		<TrimEnd set="method"><f a=""><c path="String"/></f></TrimEnd>
		<Trim set="method"><f a=""><c path="String"/></f></Trim>
		<CompareTo set="method"><f a="obj">
	<d/>
	<x path="Int"/>
</f></CompareTo>
		<Substring set="method">
			<f a="startIndex:length">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><Substring set="method"><f a="startIndex">
	<x path="Int"/>
	<c path="String"/>
</f></Substring></overloads>
		</Substring>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cs/_std/StringBuf.hx">
		<b><c path="cs.StringBuilder"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="33"><f a=""><x path="Int"/></f></get_length>
		<add public="1" get="inline" set="null" line="37">
			<f a="x">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.
		
		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).
		
		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="41">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.
		
		If `s` or `pos` are null, the result is unspecified.
		
		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.
		
		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<toString public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.
		
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="37" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="62" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="98" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:
			
		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;
		
		If `quotes` is true, the following characters are also replaced:
		
		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="117" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: htmlUnescape(htmlEscape(s)) == s

		The replacements follow:
			
		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<startsWith public="1" get="inline" set="null" line="128" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" get="inline" set="null" line="145" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is null, the result is unspecified.

		If `end` is the empty String "", the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="166" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" get="inline" set="null" line="180" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" get="inline" set="null" line="205" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" get="inline" set="null" line="227" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="249" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="271" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="292" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="314" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="343" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`.

		This method is faster than String.charCodeAt() on most platforms.
		However, unlike String.charCodeAt(), the result is unspecified if
		`index` is negative or exceeds `s.length`.

		This operation is not guaranteed to work if `s` contains the \0
		character.</haxe_doc>
		</fastCodeAt>
		<isEof public="1" get="inline" set="null" line="370" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isEof>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cs/_std/Sys.hx">
		<_env static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></_env>
		<_args static="1"><c path="Array"><c path="String"/></c></_args>
		<print public="1" set="method" line="55" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="60" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<args public="1" set="method" line="65" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="76" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="81" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" line="88" static="1">
			<f a=""><c path="haxe.ds.StringMap"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" line="103" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="108" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="114" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="119" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="124" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" line="140" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="149" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="154" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="159" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="164" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<getChar public="1" set="method" line="170" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" line="179" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="188" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="197" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/cs/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":keep"/></meta>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/cs/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="70" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o == null || o is haxe.lang.DynamicObject || o is System.Type)\n\t\t\treturn null;\n\n\t\treturn o.GetType();\n\t"</e></m></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="80" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o is System.Enum || o is haxe.lang.Enum)\n\t\t\treturn o.GetType();\n\t\treturn null;\n\t"</e></m></meta>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.
		
		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.
		
		If `o` is null, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="85" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.
		
		If `c` has no super class, null is returned.
		
		If `c` is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="97" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="115" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="127" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If `name` is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If `name` is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="169" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (name == \"Bool\") return typeof(bool);\n\t\tSystem.Type t = resolveClass(name);\n\t\tif (t != null && (t.BaseType.Equals(typeof(System.Enum)) || t.BaseType.Equals(typeof(haxe.lang.Enum))))\n\t\t\treturn t;\n\t\treturn null;\n\t"]]></e></m></meta>
			<haxe_doc>Resolves an enum by name.
		
		If `name` is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If `name` is null the result is unspecified.
		
		If `name` is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="175" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="189" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.
		
		This function guarantees that the class constructor is not called.
		
		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="214" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (@params == null || @params[0] == null)\n\t\t{\n\t\t\tobject ret = haxe.lang.Runtime.slowGetField(e, constr, true);\n\t\t\tif (ret is haxe.lang.Function)\n\t\t\t\tthrow haxe.lang.HaxeException.wrap(\"Constructor \" + constr + \" needs parameters\");\n\t\t\treturn (T) ret;\n\t\t} else {\n\t\t\treturn (T) haxe.lang.Runtime.slowCallField(e, constr, @params);\n\t\t}\n\t"</e></m></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="219" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="244" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (c == typeof(string))\n\t\t{\n\t\t\treturn haxe.lang.StringRefl.fields;\n\t\t}\n\n\t\tArray<object> ret = new Array<object>();\n\n        System.Reflection.MemberInfo[] mis = c.GetMembers(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.FlattenHierarchy);\n        for (int i = 0; i < mis.Length; i++)\n        {\n\t\t\tif (mis[i] is System.Reflection.PropertyInfo)\n                continue;\n\t\t\tstring n = mis[i].Name;\n\t\t\tif (!n.StartsWith(\"__hx_\") && n[0] != '.' && !n.Equals(\"Equals\") && !n.Equals(\"ToString\") && !n.Equals(\"GetHashCode\") && !n.Equals(\"GetType\"))\n\t\t\t\tret.push(mis[i].Name);\n        }\n\n\t\treturn ret;\n\t"]]></e></m></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`.
		
		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="267" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tArray<object> ret = new Array<object>();\n\n\t\tif (c == typeof(string))\n\t\t{\n\t\t\tret.push(\"fromCharCode\");\n\t\t\treturn ret;\n\t\t}\n\n        System.Reflection.MemberInfo[] mis = c.GetMembers(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);\n        for (int i = 0; i < mis.Length; i++)\n        {\n            string n = mis[i].Name;\n\t\t\tif (!n.StartsWith(\"__hx_\"))\n\t\t\t\tret.push(mis[i].Name);\n        }\n\n        return ret;\n\t"]]></e></m></meta>
			<haxe_doc>Returns a list of static fields of class `c`.
		
		This does not include static fields of parent classes.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="271" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="327" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (v == null) return ValueType.TNull;\n\n        System.Type t = v as System.Type;\n        if (t != null)\n        {\n            //class type\n            return ValueType.TObject;\n        }\n\n        t = v.GetType();\n        if (t.IsEnum)\n            return ValueType.TEnum(t);\n        if (t.IsValueType)\n        {\n            System.IConvertible vc = v as System.IConvertible;\n            if (vc != null)\n            {\n                switch (vc.GetTypeCode())\n                {\n                    case System.TypeCode.Boolean: return ValueType.TBool;\n                    case System.TypeCode.Double:\n\t\t\t\t\t\tdouble d = vc.ToDouble(null);\n\t\t\t\t\t\tif (d >= int.MinValue && d <= int.MaxValue && d == vc.ToInt32(null))\n\t\t\t\t\t\t\treturn ValueType.TInt;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn ValueType.TFloat;\n                    case System.TypeCode.Int32:\n                        return ValueType.TInt;\n                    default:\n                        return ValueType.TClass(t);\n                }\n            } else {\n                return ValueType.TClass(t);\n            }\n        }\n\n        if (v is haxe.lang.IHxObject)\n        {\n            if (v is haxe.lang.DynamicObject)\n                return ValueType.TObject;\n            else if (v is haxe.lang.Enum)\n                return ValueType.TEnum(t);\n            return ValueType.TClass(t);\n        } else if (v is haxe.lang.Function) {\n            return ValueType.TFunction;\n        } else {\n            return ValueType.TClass(t);\n        }\n\t"]]></e></m></meta>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="338" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (a is haxe.lang.Enum)\n\t\t\t\treturn a.Equals(b);\n\t\t\telse\n\t\t\t\treturn haxe.lang.Runtime.eq(a, b);\n\t"</e></m></meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="349" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (e is System.Enum)\n\t\t\treturn e + \"\";\n\t\telse\n\t\t\treturn ((haxe.lang.Enum) e).getTag();\n\t"</e></m></meta>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="357" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn ( e is System.Enum ) ? new Array<object>() : ((haxe.lang.Enum) e).@params;\n\t"]]></e></m></meta>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" line="368" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (e is System.Enum)\n\t\t\treturn ((System.IConvertible) e).ToInt32(null);\n\t\telse\n\t\t\treturn ((haxe.lang.Enum) e).index;\n\t"</e></m></meta>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="373" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/cs/_std/Xml.hx" module="Xml"><meta><m n=":native"><e>"_Xml.RealXmlType"</e></m></meta></enum>
	<enum path="_Xml.RealXmlType" params="" file="/usr/lib/haxe/std/cs/_std/Xml.hx" private="1" module="Xml">
		<Element/>
		<PCData/>
		<CData/>
		<Comment/>
		<DocType/>
		<ProcessingInstruction/>
		<Document/>
	</enum>
	<class path="Xml" params="" file="/usr/lib/haxe/std/cs/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="57" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="64" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="73" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="80" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="87" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="94" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="101" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="108" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" get="accessor" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><c path="haxe.ds.StringMap"><c path="String"/></c></_attributes>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<get_nodeName set="method" line="115"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName set="method" line="121"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue set="method" line="127"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue set="method" line="133"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get_parent set="method" line="139"><f a=""><c path="Xml"/></f></get_parent>
		<get public="1" set="method" line="143">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="149">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<remove public="1" set="method" line="155">
			<f a="att">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="161">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="167">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="173">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="187">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="219">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="254">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="259">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="272">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="279">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="287">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="294">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="61"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="cs.Boot" params="" file="/usr/lib/haxe/std/cs/Boot.hx"><init public="1" set="method" line="38" static="1">
	<f a=""><x path="Void"/></f>
	<meta><m n=":keep"/></meta>
</init></class>
	<class path="cs.Lib" params="" file="/usr/lib/haxe/std/cs/Lib.hx">
		<decimalSeparator static="1">
			<c path="String"/>
			<meta><m n=":keep"/></meta>
		</decimalSeparator>
		<applyCultureChanges public="1" set="method" line="43" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":functionCode"><e>"\n\t\t\tSystem.Globalization.CultureInfo ci = new System.Globalization.CultureInfo(System.Threading.Thread.CurrentThread.CurrentCulture.Name, true);\n\t\t\tdecimalSeparator = ci.NumberFormat.NumberDecimalSeparator;\n            ci.NumberFormat.NumberDecimalSeparator = \".\";\n            System.Threading.Thread.CurrentThread.CurrentCulture = ci;\n\t"</e></m>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Changes the current culture settings to allow a consistent cross-target behavior.
		Currently the only change made is in regard to the decimal separator, which is always set to "."</haxe_doc>
		</applyCultureChanges>
		<revertDefaultCulture public="1" set="method" line="55" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\n\t\tSystem.Globalization.CultureInfo ci = new System.Globalization.CultureInfo(System.Threading.Thread.CurrentThread.CurrentCulture.Name, true);\n\t\tSystem.Threading.Thread.CurrentThread.CurrentCulture = ci;\n\t"</e></m></meta>
			<haxe_doc>Reverts the culture changes to the default settings.</haxe_doc>
		</revertDefaultCulture>
		<nativeArray public="1" params="T" set="method" line="66" static="1">
			<f a="arr:equalLengthRequired">
				<c path="Array"><c path="nativeArray.T"/></c>
				<x path="Bool"/>
				<c path="cs.NativeArray"><c path="nativeArray.T"/></c>
			</f>
			<haxe_doc>Returns a native array from the supplied Array. This native array is unsafe to be written on,
		as it may or may not be linked to the actual Array implementation.

		If equalLengthRequired is true, the result might be a copy of an array with the correct size.</haxe_doc>
		</nativeArray>
		<as public="1" params="T" get="inline" set="null" line="89" static="1">
			<f a="obj:cl">
				<d/>
				<x path="Class"><c path="as.T"/></x>
				<c path="as.T"/>
			</f>
			<meta>
				<m n=":functionCode"><e>"\n\t\t\tthrow new haxe.lang.HaxeException(\"This function cannot be accessed at runtime\");\n\t"</e></m>
				<m n=":extern"/>
			</meta>
			<haxe_doc>Provides support for the "as" keyword in C#.
		If the object is not of the supplied type "T", it will return null instead of rasing an exception.

		This function will not work with Value Types (such as Int, Float, Bool...)</haxe_doc>
		</as>
		<fromNativeType public="1" get="inline" set="null" line="100" static="1">
			<f a="t">
				<c path="cs.system.Type"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns a Class<> equivalent to the native System.Type type.

		Currently Haxe's Class<> is equivalent to System.Type, but this is an implementation detail.
		This may change in the future, so use this function whenever you need to perform such conversion.]]></haxe_doc>
		</fromNativeType>
		<toNativeType public="1" get="inline" set="null" line="111" static="1">
			<f a="cl">
				<x path="Class"><d/></x>
				<c path="cs.system.Type"/>
			</f>
			<haxe_doc><![CDATA[Returns a System.Type equivalent to the Haxe Class<> type.

		Currently Haxe's Class<> is equivalent to System.Type, but this is an implementation detail.
		This may change in the future, so use this function whenever you need to perform such conversion.]]></haxe_doc>
		</toNativeType>
		<nativeType public="1" set="method" line="119" static="1">
			<f a="obj">
				<d/>
				<c path="cs.system.Type"/>
			</f>
			<haxe_doc>Gets the native System.Type from the supplied object. Will throw an exception in case of null being passed.</haxe_doc>
		</nativeType>
		<array public="1" params="T" set="method" line="129" static="1">
			<f a="native">
				<c path="cs.NativeArray"><c path="array.T"/></c>
				<c path="Array"><c path="array.T"/></c>
			</f>
			<haxe_doc>Returns a Haxe Array of a native Array.
		It won't copy the contents of the native array, so unless any operation triggers an array resize,
		all changes made to the Haxe array will affect the native array argument.</haxe_doc>
		</array>
		<arrayAlloc public="1" params="T" set="method" line="137" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="Array"><c path="arrayAlloc.T"/></c>
			</f>
			<haxe_doc>Allocates a new Haxe Array with a predetermined size</haxe_doc>
		</arrayAlloc>
		<checked public="1" params="V" get="inline" set="null" line="155" static="1">
			<f a="block">
				<c path="checked.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Creates a "checked" block, which throws exceptions for overflows.

		Usage:
			cs.Lib.checked({
				var x = 1000;
				while(true)
				{
					x *= x;
				}
			});
		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</checked>
		<lock public="1" params="O:V" get="inline" set="null" line="167" static="1">
			<f a="obj:block">
				<c path="lock.O"/>
				<c path="lock.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Ensures that one thread does not enter a critical section of code while another thread
		is in the critical section. If another thread attempts to enter a locked code, it
		will wait, block, until the object is released.

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</lock>
		<fixed public="1" params="V" get="inline" set="null" line="189" static="1">
			<f a="block">
				<c path="fixed.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Marks its parameters as fixed objects inside the defined block.
		The first variable declarations that use cs.Lib.pointerOfArray() will be the fixed definitions.
		Usage:
			cs.Lib.fixed({
				var obj1 = cs.Lib.pointerOfArray(someArray);
				var obj2 = cs.Lib.pointerOfArray(someArray2);
				var obj3 = cs.Lib.pointerOfArray(someArray3);
				//from now on, obj1, obj2 and obj3 are fixed
				//we cannot change obj1, obj2 or obj3 variables like this:
				//obj1++;
			});

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</fixed>
		<unsafe public="1" params="V" get="inline" set="null" line="203" static="1">
			<f a="block">
				<c path="unsafe.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Marks the contained block as an unsafe block, meaning that it can contain unsafe code.
		Usage:
			cs.Lib.unsafe({
				//unsafe code is allowed inside here
			});

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</unsafe>
		<addressOf public="1" params="T" get="inline" set="null" line="221" static="1">
			<f a="variable">
				<c path="addressOf.T"/>
				<c path="cs.Pointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc><![CDATA[Gets the pointer to the address of current local. Equivalent to the "&" operator in C#
		Usage:
			var x:Int = 0;
			cs.Lib.unsafe({
				var addr = cs.Lib.addressOf(x);
				x[0] = 42;
			});
			trace(x); //42

		This method only exists at compile-time, so it can't be called via reflection.
		Warning: This method will only work if a local variable is passed as an argument.]]></haxe_doc>
		</addressOf>
		<valueOf public="1" params="T" get="inline" set="null" line="240" static="1">
			<f a="pointer">
				<c path="cs.Pointer"><c path="valueOf.T"/></c>
				<c path="valueOf.T"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Gets the value of the pointer address.
		Usage:
			var x:Int = 0;
			cs.Lib.unsafe({
				var addr = cs.Lib.addressOf(x);
				trace(cs.Lib.valueOf(addr)); //0
				addr[0] = 42;
				trace(cs.Lib.valueOf(addr)); //42
			});
			trace(x); //42

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</valueOf>
		<pointerOfArray public="1" params="T" get="inline" set="null" line="261" static="1">
			<f a="array">
				<c path="cs.NativeArray"><c path="pointerOfArray.T"/></c>
				<c path="cs.Pointer"><c path="pointerOfArray.T"/></c>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc><![CDATA[Transforms a managed native array into a Pointer. Must be inside a fixed statement
		Usage:
			var x:cs.NativeArray<Int> = new cs.NativeArray(1);
			cs.Lib.unsafe({
				cs.Lib.fixed({
					var addr = cs.Lib.pointerOfArray(x);
					trace(cs.Lib.valueOf(addr)); //0
					addr[0] = 42;
					trace(cs.Lib.valueOf(addr)); //42
				});
			});
			trace(x[0]); //42

		This method only exists at compile-time, so it can't be called via reflection.]]></haxe_doc>
		</pointerOfArray>
		<sizeof public="1" get="inline" set="null" line="269" static="1">
			<f a="struct">
				<x path="Class"><d/></x>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Returns the byte size of the given struct. Only works with structs and basic types.</haxe_doc>
		</sizeof>
		<haxe_doc>Platform-specific C# Library. Provides some platform-specific functions for the C# target,
	such as conversion from haxe types to native types and vice-versa.</haxe_doc>
	</class>
	<class path="cs.system.Array" params="" file="/usr/lib/haxe/std/cs/system/Array.hx" extern="1">
		<Copy public="1" set="method" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Copy>
		<meta><m n=":native"><e>"System.Array"</e></m></meta>
	</class>
	<class path="cs.NativeArray" params="T" file="/usr/lib/haxe/std/cs/NativeArray.hx" extern="1">
		<extends path="cs.system.Array"/>
		<Reverse public="1" set="method" static="1"><f a="arr">
	<c path="cs.system.Array"/>
	<x path="Void"/>
</f></Reverse>
		<Length public="1" set="null"><x path="Int"/></Length>
		<CopyTo public="1" set="method">
			<f a="arr:destIndex">
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><CopyTo public="1" set="method"><f a="arr:destIndex">
	<c path="cs.system.Array"/>
	<c path="haxe.Int64"/>
	<x path="Void"/>
</f></CopyTo></overloads>
		</CopyTo>
		<new public="1" set="method"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="cs.Pointer" params="T" file="/usr/lib/haxe/std/cs/Pointer.hx" extern="1">
		<op_Addition public="1" params="T" set="method" static="1"><f a="p:i">
	<c path="cs.Pointer"><c path="op_Addition.T"/></c>
	<x path="Int"/>
	<c path="cs.Pointer"><c path="op_Addition.T"/></c>
</f></op_Addition>
		<add public="1" get="inline" set="null" line="48"><f a="i">
	<x path="Int"/>
	<c path="cs.Pointer"><c path="cs.Pointer.T"/></c>
</f></add>
		<haxe_doc><![CDATA[This type represents pointer types for C# function parameters. It should only
	be used inside an unsafe context (not checked by the Haxe compiler)

	C# code:
		int[] src;
		fixed (int* pSrc = src)
		{
			...
		}
	Haxe code:
		var pSrc:cs.Pointer<Int>;
		cs.Lib.fixed(pSrc = cast src,
		{
			...
		});]]></haxe_doc>
	</class>
	<typedef path="cs.Int8" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><x path="Int"/></typedef>
	<typedef path="cs.UInt8" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><x path="Int"/></typedef>
	<typedef path="cs.Int16" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><x path="Int"/></typedef>
	<typedef path="cs.UInt16" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><x path="Int"/></typedef>
	<typedef path="cs.UInt64" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><c path="haxe.Int64"/></typedef>
	<typedef path="cs.Char16" params="" file="/usr/lib/haxe/std/cs/StdTypes.hx" module="cs.StdTypes"><x path="Int"/></typedef>
	<class path="cs.StringBuilder" params="" file="/usr/lib/haxe/std/cs/StringBuilder.hx" extern="1">
		<Length public="1" set="null"><x path="Int"/></Length>
		<Append public="1" set="method">
			<f a="obj">
				<d/>
				<c path="cs.StringBuilder"/>
			</f>
			<overloads>
				<Append public="1" set="method"><f a="char">
	<t path="cs.Char16"/>
	<c path="cs.StringBuilder"/>
</f></Append>
				<Append public="1" set="method"><f a="str:startIndex:len">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.StringBuilder"/>
</f></Append>
			</overloads>
		</Append>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"System.Text.StringBuilder"</e></m></meta>
	</class>
	<class path="cs.system.Exception" params="" file="/usr/lib/haxe/std/cs/system/Exception.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<new set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":native"><e>"System.Exception"</e></m>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="cs.internal._Exceptions.HaxeException" params="" file="/usr/lib/haxe/std/cs/internal/Exceptions.hx" private="1" module="cs.internal.Exceptions">
		<extends path="cs.system.Exception"/>
		<wrap public="1" set="method" line="52" static="1"><f a="obj">
	<d/>
	<c path="cs.system.Exception"/>
</f></wrap>
		<obj><d/></obj>
		<getObject public="1" set="method" line="42"><f a=""><d/></f></getObject>
		<toString public="1" set="method" line="47"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="30"><f a="obj">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.HaxeException"</e></m>
		</meta>
	</class>
	<class path="cs.internal._FieldLookup.FieldLookup" params="" file="/usr/lib/haxe/std/cs/internal/FieldLookup.hx" private="1" module="cs.internal.FieldLookup">
		<fieldIds static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":private"/></meta>
		</fieldIds>
		<fields static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":private"/></meta>
		</fields>
		<doHash get="inline" set="null" line="32" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></doHash>
		<lookupHash public="1" set="method" line="43" static="1"><f a="key">
	<x path="Int"/>
	<c path="String"/>
</f></lookupHash>
		<hash public="1" set="method" line="67" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></hash>
		<findHash public="1" set="method" line="100" static="1"><f a="hash:hashs">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></findHash>
		<meta>
			<m n=":native"><e>"haxe.lang.FieldLookup"</e></m>
			<m n=":keep"/>
			<m n=":static"/>
		</meta>
	</class>
	<class path="cs.internal._Function.Function" params="" file="/usr/lib/haxe/std/cs/internal/Function.hx" private="1" module="cs.internal.Function">
		<new set="method" line="32"><f a="arity:type">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>These classes are automatically generated by the compiler. They are only
 here so there is an option for e.g. defining them as externs if you are compiling
 in modules (untested).</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":abstract"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Function"</e></m>
		</meta>
	</class>
	<class path="cs.internal._Function.VarArgsBase" params="" file="/usr/lib/haxe/std/cs/internal/Function.hx" private="1" module="cs.internal.Function">
		<extends path="cs.internal._Function.Function"/>
		<__hx_invokeDynamic public="1" set="method" line="40"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsBase"</e></m>
		</meta>
	</class>
	<class path="cs.internal.VarArgsFunction" params="" file="/usr/lib/haxe/std/cs/internal/Function.hx" module="cs.internal.Function">
		<extends path="cs.internal._Function.VarArgsBase"/>
		<fun><f a="">
	<c path="Array"><d/></c>
	<d/>
</f></fun>
		<__hx_invokeDynamic public="1" set="method" line="57" override="1"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<new public="1" set="method" line="51"><f a="fun">
	<f a="">
		<c path="Array"><d/></c>
		<d/>
	</f>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsFunction"</e></m>
		</meta>
	</class>
	<class path="cs.internal.Closure" params="" file="/usr/lib/haxe/std/cs/internal/Function.hx" module="cs.internal.Function">
		<extends path="cs.internal._Function.VarArgsBase"/>
		<obj><d/></obj>
		<field><c path="String"/></field>
		<hash><x path="Int"/></hash>
		<__hx_invokeDynamic public="1" set="method" line="77" override="1"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<new public="1" set="method" line="69"><f a="obj:field:hash">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Closure"</e></m>
		</meta>
	</class>
	<typedef path="cs.internal._HxObject.StdType" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject"><c path="Type"/></typedef>
	<class path="cs.internal._HxObject.IHxObject" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject" interface="1"><meta>
	<m n=":keep"/>
	<m n=":native"><e>"haxe.lang.IHxObject"</e></m>
</meta></class>
	<class path="cs.internal._HxObject.HxObject" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject">
		<implements path="cs.internal._HxObject.IHxObject"/>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.HxObject"</e></m>
		</meta>
	</class>
	<class path="cs.internal._HxObject.DynamicObject" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject">
		<extends path="cs.internal._HxObject.HxObject"/>
		<toString public="1" set="method" line="39">
			<f a=""><c path="String"/></f>
			<meta><m n=":skipReflection"/></meta>
		</toString>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.DynamicObject"</e></m>
		</meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="cs.internal.IGenericObject" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject" interface="1"><meta>
	<m n=":keep"/>
	<m n=":native"><e>"haxe.lang.IGenericObject"</e></m>
</meta></class>
	<class path="cs.internal._HxObject.Enum" params="" file="/usr/lib/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject">
		<index>
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</index>
		<params>
			<c path="Array"><a/></c>
			<meta><m n=":readOnly"/></meta>
		</params>
		<getTag public="1" set="method" line="79">
			<f a=""><c path="String"/></f>
			<meta><m n=":final"/></meta>
		</getTag>
		<toString public="1" set="method" line="84"><f a=""><c path="String"/></f></toString>
		<Equals public="1" set="method" line="101"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></Equals>
		<GetHashCode public="1" set="method" line="122"><f a=""><x path="Int"/></f></GetHashCode>
		<new public="1" set="method" line="74"><f a="index:params">
	<x path="Int"/>
	<c path="Array"><a/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":native"><e>"haxe.lang.Enum"</e></m>
			<m n=":keep"/>
			<m n=":skipCtor"/>
		</meta>
	</class>
	<class path="cs.internal.Iterator" params="T" file="/usr/lib/haxe/std/cs/internal/Iterator.hx" interface="1">
		<hasNext public="1" set="method"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><c path="cs.internal.Iterator.T"/></f></next>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.Iterator"</e></m>
		</meta>
	</class>
	<class path="cs.internal.Iterable" params="T" file="/usr/lib/haxe/std/cs/internal/Iterator.hx" module="cs.internal.Iterator" interface="1">
		<iterator public="1" set="method"><f a=""><c path="cs.internal.Iterator"><c path="cs.internal.Iterable.T"/></c></f></iterator>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.Iterable"</e></m>
		</meta>
	</class>
	<class path="cs.internal._Null.Nullable" params="T" file="/usr/lib/haxe/std/cs/internal/Null.hx" private="1" module="cs.internal.Null">
		<ofDynamic public="1" params="D" set="method" line="73" static="1">
			<f a="obj">
				<d/>
				<c path="cs.internal._Null.Nullable"><c path="ofDynamic.D"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (obj == null)\n\t\t{\n\t\t\treturn new haxe.lang.Null<D>(default(D), false);\n\t\t} else if (typeof(D).Equals(typeof(double))) {\n\t\t\treturn new haxe.lang.Null<D>((D) (object) haxe.lang.Runtime.toDouble(obj), true);\n\t\t} else if (typeof(D).Equals(typeof(int))) {\n\t\t\treturn new haxe.lang.Null<D>((D) (object) haxe.lang.Runtime.toInt(obj), true);\n\t\t} else {\n\t\t\treturn new haxe.lang.Null<D>((D) obj, true);\n\t\t}\n\t"]]></e></m></meta>
		</ofDynamic>
		<value public="1">
			<c path="cs.internal._Null.Nullable.T"/>
			<meta><m n=":readOnly"/></meta>
		</value>
		<hasValue public="1">
			<x path="Bool"/>
			<meta><m n=":readOnly"/></meta>
		</hasValue>
		<toDynamic public="1" set="method" line="83">
			<f a=""><d/></f>
			<meta><m n=":functionCode"><e>"\n\t\tif (this.hasValue)\n\t\t\treturn value;\n\t\treturn null;\n\t"</e></m></meta>
		</toDynamic>
		<new public="1" set="method" line="55">
			<f a="v:hasValue">
				<c path="cs.internal._Null.Nullable.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif ( !(v is System.ValueType) && System.Object.ReferenceEquals(v, default(T)))\n\t\t\t{\n\t\t\t\thasValue = false;\n\t\t\t}\n\n\t\t\tthis.@value = v;\n\t\t\tthis.hasValue = hasValue;\n\t"]]></e></m></meta>
		</new>
		<meta>
			<m n=":classCode"><e><![CDATA["\n\t//This function is here to be used with Reflection, when the haxe.lang.Null type is known\n\tpublic static haxe.lang.Null<T> _ofDynamic(object obj)\n\t{\n\t\tif (obj == null)\n\t\t{\n\t\t\treturn new haxe.lang.Null<T>(default(T), false);\n\t\t} else if (typeof(T).Equals(typeof(double))) {\n\t\t\treturn new haxe.lang.Null<T>((T) (object) haxe.lang.Runtime.toDouble(obj), true);\n\t\t} else if (typeof(T).Equals(typeof(int))) {\n\t\t\treturn new haxe.lang.Null<T>((T) (object) haxe.lang.Runtime.toInt(obj), true);\n\t\t} else {\n\t\t\treturn new haxe.lang.Null<T>((T) obj, true);\n\t\t}\n\t}\n"]]></e></m>
			<m n=":keep"/>
			<m n=":struct"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Null"</e></m>
		</meta>
	</class>
	<class path="cs.internal.Runtime" params="" file="/usr/lib/haxe/std/cs/internal/Runtime.hx">
		<undefined public="1" set="null" line="69" static="1"><d/></undefined>
		<closure public="1" set="method" line="74" static="1">
			<f a="obj:hash:field">
				<d/>
				<x path="Int"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn new haxe.lang.Closure(obj, field, hash);\n\t"</e></m></meta>
		</closure>
		<eq public="1" set="method" line="128" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (System.Object.ReferenceEquals(v1, v2))\n\t\t\t\treturn true;\n\t\t\tif (v1 == null || v2 == null)\n\t\t\t\treturn false;\n\n\t\t\tSystem.IConvertible v1c = v1 as System.IConvertible;\n\n\t\t\tif (v1c != null)\n\t\t\t{\n\t\t\t\tSystem.IConvertible v2c = v2 as System.IConvertible;\n\n\t\t\t\tif (v2c == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tSystem.TypeCode t1 = v1c.GetTypeCode();\n\t\t\t\tSystem.TypeCode t2 = v2c.GetTypeCode();\n\t\t\t\tif (t1 == t2)\n\t\t\t\t\treturn v1c.Equals(v2c);\n\n\t\t\t\tswitch(t1)\n\t\t\t\t{\n\t\t\t\t\tcase System.TypeCode.Int64:\n\t\t\t\t\tcase System.TypeCode.UInt64:\n\t\t\t\t\t\treturn v1c.ToUInt64(null) == v2c.ToUInt64(null);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn v1c.ToDouble(null) == v2c.ToDouble(null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.ValueType v1v = v1 as System.ValueType;\n\t\t\tif (v1v != null)\n\t\t\t{\n\t\t\t\treturn v1.Equals(v2);\n\t\t\t} else {\n\t\t\t\tSystem.Type v1t = v1 as System.Type;\n\t\t\t\tif (v1t != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.Type v2t = v2 as System.Type;\n\t\t\t\t\tif (v2t != null)\n\t\t\t\t\t\treturn typeEq(v1t, v2t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t"</e></m></meta>
		</eq>
		<refEq public="1" set="method" line="138" static="1">
			<f a="v1:v2">
				<a/>
				<a/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (v1 is System.Type)\n\t\t\t\treturn typeEq(v1 as System.Type, v2 as System.Type);\n\t\t\treturn System.Object.ReferenceEquals(v1, v2);\n\t"</e></m></meta>
		</refEq>
		<toDouble public="1" set="method" line="146" static="1">
			<f a="obj">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (obj == null) ? 0.0 : (obj is double) ? (double)obj : ((System.IConvertible) obj).ToDouble(null);\n\t"</e></m></meta>
		</toDouble>
		<toInt public="1" set="method" line="154" static="1">
			<f a="obj">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (obj == null) ? 0 : (obj is int) ? (int)obj : ((System.IConvertible) obj).ToInt32(null);\n\t"</e></m></meta>
		</toInt>
		<isInt public="1" set="method" line="179" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tSystem.IConvertible cv1 = obj as System.IConvertible;\n\t\t\tif (cv1 != null)\n\t\t\t{\n                switch (cv1.GetTypeCode())\n                {\n                    case System.TypeCode.Double:\n                        double d = (double)obj;\n\n\t\t\t\t        return d >= int.MinValue && d <= int.MaxValue && d == ( (int)d );\n                    case System.TypeCode.UInt32:\n                    case System.TypeCode.Int32:\n                        return true;\n                    default:\n                        return false;\n                }\n\n\t\t\t}\n\t\t\treturn false;\n\t"]]></e></m></meta>
		</isInt>
		<compare public="1" set="method" line="263" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif (v1 == v2) return 0;\n\t\t\tif (v1 == null) return -1;\n\t\t\tif (v2 == null) return 1;\n\t\t\tSystem.IConvertible cv1 = v1 as System.IConvertible;\n\t\t\tif (cv1 != null)\n\t\t\t{\n\t\t\t\tSystem.IConvertible cv2 = v2 as System.IConvertible;\n\n\t\t\t\tif (cv2 == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new System.ArgumentException(\"Cannot compare \" + v1.GetType().ToString() + \" and \" + v2.GetType().ToString());\n\t\t\t\t}\n\n\t\t\t\tswitch(cv1.GetTypeCode())\n\t\t\t\t{\n\t\t\t\t\tcase System.TypeCode.String:\n\t\t\t\t\t\tif (cv2.GetTypeCode() != System.TypeCode.String)\n\t\t\t\t\t\t\tthrow new System.ArgumentException(\"Cannot compare \" + v1.GetType().ToString() + \" and \" + v2.GetType().ToString());\n\t\t\t\t\t\tstring s1 = v1 as string;\n\t\t\t\t\t\tstring s2 = v2 as string;\n\t\t\t\t\t\tint i =0;\n\t\t\t\t\t\tint l1 = s1.Length;\n\t\t\t\t\t\tint l2 = s2.Length;\n\t\t\t\t\t\tbool active = true;\n\t\t\t\t\t\twhile(active)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar h1; char h2;\n\t\t\t\t\t\t\tif (i >= l1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\th1 = (char) 0;\n\t\t\t\t\t\t\t\tactive = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\th1 = s1[i];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (i >= l2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\th2 = (char) 0;\n\t\t\t\t\t\t\t\tactive = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\th2 = s2[i];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint v = h1 - h2;\n\t\t\t\t\t\t\tif (v > 0)\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\telse if (v < 0)\n\t\t\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tcase System.TypeCode.Double:\n\t\t\t\t\tdouble d1 = (double) v1;\n\t\t\t\t\tdouble d2 = cv2.ToDouble(null);\n\n\t\t\t\t\tif (double.IsInfinity(d1) || double.IsInfinity(d2))\n\t\t\t\t\t\treturn (d1 < d2) ? -1 : (d1 > d2) ? 1 : 0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (int) (d1 - d2);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn ((int) (cv1.ToDouble(null) - cv2.ToDouble(null)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.IComparable c1 = v1 as System.IComparable;\n\t\t\tSystem.IComparable c2 = v2 as System.IComparable;\n\n\t\t\tif (c1 == null || c2 == null)\n\t\t\t{\n\t\t\t\tif (c1 == c2)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tthrow new System.ArgumentException(\"Cannot compare \" + v1.GetType().ToString() + \" and \" + v2.GetType().ToString());\n\t\t\t}\n\n\t\t\treturn c1.CompareTo(c2);\n\t"]]></e></m></meta>
		</compare>
		<plus public="1" set="method" line="287" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (v1 is string || v2 is string)\n\t\t\t\treturn Std.@string(v1) + Std.@string(v2);\n\n\t\t\tSystem.IConvertible cv1 = v1 as System.IConvertible;\n\t\t\tif (cv1 != null)\n\t\t\t{\n\t\t\t\tSystem.IConvertible cv2 = v2 as System.IConvertible;\n\n\t\t\t\tif (cv2 == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new System.ArgumentException(\"Cannot dynamically add \" + v1.GetType().ToString() + \" and \" + v2.GetType().ToString());\n\t\t\t\t}\n\n\t\t\t\treturn cv1.ToDouble(null) + cv2.ToDouble(null);\n\t\t\t}\n\n\t\t\tthrow new System.ArgumentException(\"Cannot dynamically add \" + v1 + \" and \" + v2);\n\t"</e></m></meta>
		</plus>
		<slowGetField public="1" set="method" line="340" static="1">
			<f a="obj:field:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\n\t\tif (obj == null)\n\t\t\tif (throwErrors)\n\t\t\t\tthrow new System.NullReferenceException(\"Cannot access field '\" + field + \"' of null.\");\n\t\t\telse\n\t\t\t\treturn null;\n\n\t\tSystem.Type t = obj as System.Type;\n\t\tSystem.Reflection.BindingFlags bf;\n        if (t == null)\n\t\t{\n\t\t\tstring s = obj as string;\n\t\t\tif (s != null)\n\t\t\t\treturn haxe.lang.StringRefl.handleGetField(s, field, throwErrors);\n\t\t\tt = obj.GetType();\n\t\t\tbf = System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy;\n\t\t} else {\n\t\t\tif (obj == typeof(string) && field.Equals(\"fromCharCode\"))\n\t\t\t\treturn new haxe.lang.Closure(typeof(haxe.lang.StringExt), field, 0);\n\n\t\t\tobj = null;\n\t\t\tbf = System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public;\n\t\t}\n\n\t\tSystem.Reflection.FieldInfo f = t.GetField(field, bf);\n\t\tif (f != null)\n\t\t{\n\t\t\treturn haxe.lang.Runtime.unbox(f.GetValue(obj));\n\t\t} else {\n\t\t\tSystem.Reflection.PropertyInfo prop = t.GetProperty(field, bf);\n\t\t\tif (prop == null)\n\t\t\t{\n\t\t\t\tSystem.Reflection.MemberInfo[] m = t.GetMember(field, bf);\n\t\t\t\tif (m.Length > 0)\n\t\t\t\t{\n\t\t\t\t\treturn new haxe.lang.Closure(obj != null ? obj : t, field, 0);\n\t\t\t\t} else {\n\t\t\t\t\tif (throwErrors)\n\t\t\t\t\t\tthrow HaxeException.wrap(\"Cannot access field '\" + field + \"'.\");\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn haxe.lang.Runtime.unbox(prop.GetValue(obj, null));\n\t\t}\n\n\t"]]></e></m></meta>
		</slowGetField>
		<slowHasField public="1" set="method" line="366" static="1">
			<f a="obj:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (obj == null) return false;\n\t\tSystem.Type t = obj as System.Type;\n\t\tSystem.Reflection.BindingFlags bf;\n        if (t == null)\n\t\t{\n\t\t\tstring s = obj as string;\n\t\t\tif (s != null)\n\t\t\t\treturn haxe.lang.StringRefl.handleGetField(s, field, false) != null;\n\t\t\tt = obj.GetType();\n\t\t\tbf = System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy;\n\t\t} else {\n\t\t\tif (t == typeof(string))\n\t\t\t\treturn field.Equals(\"fromCharCode\");\n\t\t\tobj = null;\n\t\t\tbf = System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public;\n\t\t}\n\n\t\tSystem.Reflection.MemberInfo[] mi = t.GetMember(field, bf);\n\t\treturn mi != null && mi.Length > 0;\n\t"]]></e></m></meta>
		</slowHasField>
		<slowSetField public="1" set="method" line="413" static="1">
			<f a="obj:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (obj == null)\n\t\t\tthrow new System.NullReferenceException(\"Cannot access field '\" + field + \"' of null.\");\n\n\t\tSystem.Type t = obj as System.Type;\n\t\tSystem.Reflection.BindingFlags bf;\n        if (t == null)\n\t\t{\n\t\t\tt = obj.GetType();\n\t\t\tbf = System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy;\n\t\t} else {\n\t\t\tobj = null;\n\t\t\tbf = System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public;\n\t\t}\n\n\t\tSystem.Reflection.FieldInfo f = t.GetField(field, bf);\n\t\tif (f != null)\n\t\t{\n\t\t\tif (f.FieldType.ToString().StartsWith(\"haxe.lang.Null\"))\n\t\t\t{\n\t\t\t\t@value = haxe.lang.Runtime.mkNullable(@value, f.FieldType);\n\t\t\t}\n\n\t\t\tf.SetValue(obj, @value);\n\t\t\treturn @value;\n\t\t} else {\n\t\t\tSystem.Reflection.PropertyInfo prop = t.GetProperty(field, bf);\n\t\t\tif (prop == null)\n\t\t\t{\n\t\t\t\tthrow haxe.lang.HaxeException.wrap(\"Field '\" + field + \"' not found for writing from Class \" + t);\n\t\t\t}\n\n\t\t\tif (prop.PropertyType.ToString().StartsWith(\"haxe.lang.Null\"))\n\t\t\t{\n\t\t\t\t@value = haxe.lang.Runtime.mkNullable(@value, prop.PropertyType);\n\t\t\t}\n\t\t\tprop.SetValue(obj, @value, null);\n\n\t\t\treturn @value;\n\t\t}\n\n\t"</e></m></meta>
		</slowSetField>
		<callMethod public="1" set="method" line="420" static="1"><f a="obj:methods:methodLength:args">
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<d/>
</f></callMethod>
		<unbox public="1" set="method" line="541" static="1"><f a="dyn">
	<d/>
	<d/>
</f></unbox>
		<mkNullable public="1" set="method" line="556" static="1">
			<f a="obj:nullableType">
				<d/>
				<c path="cs.system.Type"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (nullableType.ContainsGenericParameters)\n\t\t\treturn haxe.lang.Null<object>.ofDynamic<object>(obj);\n\t\treturn nullableType.GetMethod(\"_ofDynamic\").Invoke(null, new object[] { obj });\n\t"]]></e></m></meta>
		</mkNullable>
		<slowCallField public="1" set="method" line="603" static="1">
			<f a="obj:field:args">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (field == \"toString\")\n\t\t{\n\t\t\tif (args == null)\n\t\t\t\treturn obj.ToString();\n\t\t\tfield = \"ToString\";\n\t\t}\n\t\tif (args == null) args = new Array<object>();\n\n\t\tSystem.Reflection.BindingFlags bf;\n\t\tSystem.Type t = obj as System.Type;\n\t\tif (t == null)\n\t\t{\n\t\t\tstring s = obj as string;\n\t\t\tif (s != null)\n\t\t\t\treturn haxe.lang.StringRefl.handleCallField(s, field, args);\n\t\t\tt = obj.GetType();\n\t\t\tbf = System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy;\n\t\t} else {\n\t\t\tif (t == typeof(string) && field.Equals(\"fromCharCode\"))\n\t\t\t\treturn haxe.lang.StringExt.fromCharCode(toInt(args[0]));\n\t\t\tobj = null;\n\t\t\tbf = System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public;\n\t\t}\n\n\t\tSystem.Reflection.MethodInfo[] mis = t.GetMethods(bf);\n\t\tint last = 0;\n\t\tfor (int i = 0; i < mis.Length; i++)\n\t\t{\n\t\t\tif (mis[i].Name.Equals(field))\n\t\t\t{\n\t\t\t\tmis[last++] = mis[i];\n\t\t\t}\n\t\t}\n\n\t\tif (last == 0)\n\t\t{\n\t\t\tthrow haxe.lang.HaxeException.wrap(\"Method '\" + field + \"' not found on type \" + t);\n\t\t}\n\n\t\treturn haxe.lang.Runtime.callMethod(obj, mis, last, args);\n\t"]]></e></m></meta>
		</slowCallField>
		<callField public="1" set="method" line="616" static="1">
			<f a="obj:field:fieldHash:args">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\thaxe.lang.HxObject hxObj = obj as haxe.lang.HxObject;\n\t\tif (hxObj != null)\n\t\t\treturn hxObj.__hx_invokeField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, args);\n\n\t\treturn slowCallField(obj, field, args);\n\t"</e></m></meta>
		</callField>
		<getField public="1" set="method" line="630" static="1">
			<f a="obj:field:fieldHash:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\thaxe.lang.HxObject hxObj = obj as haxe.lang.HxObject;\n\t\tif (hxObj != null)\n\t\t\treturn hxObj.__hx_getField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false, false);\n\n\t\treturn slowGetField(obj, field, throwErrors);\n\n\t"</e></m></meta>
		</getField>
		<getField_f public="1" set="method" line="644" static="1">
			<f a="obj:field:fieldHash:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\thaxe.lang.HxObject hxObj = obj as haxe.lang.HxObject;\n\t\tif (hxObj != null)\n\t\t\treturn hxObj.__hx_getField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false);\n\n\t\treturn (double)slowGetField(obj, field, throwErrors);\n\n\t"</e></m></meta>
		</getField_f>
		<setField public="1" set="method" line="658" static="1">
			<f a="obj:field:fieldHash:value">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\thaxe.lang.HxObject hxObj = obj as haxe.lang.HxObject;\n\t\tif (hxObj != null)\n\t\t\treturn hxObj.__hx_setField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\n\t\treturn slowSetField(obj, field, value);\n\n\t"</e></m></meta>
		</setField>
		<setField_f public="1" set="method" line="672" static="1">
			<f a="obj:field:fieldHash:value">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\thaxe.lang.HxObject hxObj = obj as haxe.lang.HxObject;\n\t\tif (hxObj != null)\n\t\t\treturn hxObj.__hx_setField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\n\t\treturn (double)slowSetField(obj, field, value);\n\n\t"</e></m></meta>
		</setField_f>
		<toString public="1" set="method" line="677" static="1"><f a="obj">
	<d/>
	<c path="String"/>
</f></toString>
		<typeEq public="1" set="method" line="697" static="1">
			<f a="t1:t2">
				<c path="cs.system.Type"/>
				<c path="cs.system.Type"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (t1 == null || t2 == null)\n\t\t\t\treturn t1 == t2;\n\t\t\tstring n1 = Type.getClassName(t1);\n\t\t\tstring n2 = Type.getClassName(t2);\n\t\t\treturn n1.Equals(n2);\n\t"</e></m></meta>
		</typeEq>
		<genericCast public="1" params="To" set="method" line="715" static="1">
			<f a="obj">
				<d/>
				<c path="genericCast.To"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (obj is To)\n\t\t\treturn (To) obj;\n\t\telse if (obj == null)\n\t\t\treturn default(To);\n\t\tif (typeof(To) == typeof(double))\n\t\t\treturn (To)(object) toDouble(obj);\n\t\telse if (typeof(To) == typeof(int))\n\t\t\treturn (To)(object) toInt(obj);\n\t\telse\n\t\t\treturn (To) obj;\n\t"</e></m></meta>
		</genericCast>
		<concat public="1" set="method" line="723" static="1">
			<f a="s1:s2">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (s1 == null ? \"null\" : s1) + (s2 == null ? \"null\" : s2);\n\t"</e></m></meta>
		</concat>
		<haxe_doc>This class is meant for internal compiler use only. It provides the Haxe runtime
 compatibility to the host language.</haxe_doc>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Runtime"</e></m>
			<m n=":classCode"><e><![CDATA["\n\tpublic static object getField(haxe.lang.HxObject obj, string field, int fieldHash, bool throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return null;\n\t\treturn obj.__hx_getField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false, false);\n\t}\n\n\tpublic static double getField_f(haxe.lang.HxObject obj, string field, int fieldHash, bool throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return 0.0;\n\t\treturn obj.__hx_getField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false);\n\t}\n\n\tpublic static object setField(haxe.lang.HxObject obj, string field, int fieldHash, object value)\n\t{\n\t\treturn obj.__hx_setField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\t}\n\n\tpublic static double setField_f(haxe.lang.HxObject obj, string field, int fieldHash, double value)\n\t{\n\t\treturn obj.__hx_setField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\t}\n\n\tpublic static object callField(haxe.lang.HxObject obj, string field, int fieldHash, Array args)\n\t{\n\t\treturn obj.__hx_invokeField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, args);\n\t}\n"]]></e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="cs.internal._Runtime.EmptyObject" params="" file="/usr/lib/haxe/std/cs/internal/Runtime.hx" private="1" module="cs.internal.Runtime">
		<EMPTY/>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.EmptyObject"</e></m>
		</meta>
	</enum>
	<typedef path="cs.internal._StringExt.NativeString" params="" file="/usr/lib/haxe/std/cs/internal/StringExt.hx" private="1" module="cs.internal.StringExt"><c path="String"/></typedef>
	<class path="cs.internal._StringExt.StringExt" params="" file="/usr/lib/haxe/std/cs/internal/StringExt.hx" private="1" module="cs.internal.StringExt">
		<charAt public="1" set="method" line="35" static="1">
			<f a="me:index">
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif ( ((uint) index) >= me.Length)\n\t\t\t\treturn \"\";\n\t\t\telse\n\t\t\t\treturn new string(me[index], 1);\n\t"]]></e></m></meta>
		</charAt>
		<charCodeAt public="1" set="method" line="46" static="1">
			<f a="me:index">
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif ( ((uint) index) >= me.Length)\n\t\t\t\treturn default(haxe.lang.Null<int>);\n\t\t\telse\n\t\t\t\treturn new haxe.lang.Null<int>((int)me[index], true);\n\t"]]></e></m></meta>
		</charCodeAt>
		<indexOf public="1" set="method" line="57" static="1">
			<f a="me:str:?startIndex">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tuint sIndex = (startIndex.hasValue) ? ((uint) startIndex.@value) : 0;\n\t\t\tif (sIndex >= me.Length)\n\t\t\t\treturn -1;\n\t\t\treturn me.IndexOf(str, (int)sIndex);\n\t"]]></e></m></meta>
		</indexOf>
		<lastIndexOf public="1" set="method" line="93" static="1">
			<f a="me:str:?startIndex">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint sIndex = (startIndex.hasValue) ? (startIndex.@value) : (me.Length - 1);\n\t\t\tif (sIndex >= me.Length)\n\t\t\t\tsIndex = me.Length - 1;\n\t\t\telse if (sIndex < 0)\n\t\t\t\treturn -1;\n\n\t\t\t//TestBaseTypes.hx@133 fix\n\t\t\tif (startIndex.hasValue)\n\t\t\t{\n\t\t\t\tfor(int i = sIndex; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tbool found = true;\n\t\t\t\t\tfor(int j = 0; j < str.Length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(me[i + j] != str[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found)\n\t\t\t\t\t\treturn i;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn me.LastIndexOf(str, sIndex);\n\t\t\t}\n\t"]]></e></m></meta>
		</lastIndexOf>
		<split public="1" set="method" line="111" static="1">
			<f a="me:delimiter">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
				<c path="Array"><t path="cs.internal._StringExt.NativeString"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tstring[] native;\n\t\t\tif (delimiter.Length == 0)\n\t\t\t{\n\t\t\t\tint len = me.Length;\n\t\t\t\tnative = new string[len];\n\t\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\t\tnative[i] = new string(me[i], 1);\n\t\t\t} else {\n\t\t\t\tnative = me.Split(new string[] { delimiter }, System.StringSplitOptions.None);\n\t\t\t}\n\t\t\treturn new Array<object>(native);\n\t"]]></e></m></meta>
		</split>
		<substr public="1" set="method" line="144" static="1">
			<f a="me:pos:?len">
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint meLen = me.Length;\n\t\t\tint targetLen = meLen;\n\t\t\tif (len.hasValue)\n\t\t\t{\n\t\t\t\ttargetLen = len.@value;\n\t\t\t\tif (targetLen == 0)\n\t\t\t\t\treturn \"\";\n\t\t\t\tif( pos != 0 && targetLen < 0 ){\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( pos < 0 ){\n\t\t\t\tpos = meLen + pos;\n\t\t\t\tif( pos < 0 ) pos = 0;\n\t\t\t} else if( targetLen < 0 ){\n\t\t\t\ttargetLen = meLen + targetLen - pos;\n\t\t\t}\n\n\t\t\tif( pos + targetLen > meLen ){\n\t\t\t\ttargetLen = meLen - pos;\n\t\t\t}\n\n\t\t\tif ( pos < 0 || targetLen <= 0 ) return \"\";\n\n\t\t\treturn me.Substring(pos, targetLen);\n\t"]]></e></m></meta>
		</substr>
		<substring public="1" set="method" line="174" static="1">
			<f a="me:startIndex:?endIndex">
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tint endIdx;\n\t\tint len = me.Length;\n\t\tif ( !endIndex.hasValue ) {\n\t\t\tendIdx = len;\n\t\t} else if ( (endIdx = endIndex.@value) < 0 ) {\n\t\t\tendIdx = 0;\n\t\t} else if ( endIdx > len ) {\n\t\t\tendIdx = len;\n\t\t}\n\n\t\tif ( startIndex < 0 ) {\n\t\t\tstartIndex = 0;\n\t\t} else if ( startIndex > len ) {\n\t\t\tstartIndex = len;\n\t\t}\n\n\t\tif ( startIndex > endIdx ) {\n\t\t\tint tmp = startIndex;\n\t\t\tstartIndex = endIdx;\n\t\t\tendIdx = tmp;\n\t\t}\n\n\t\treturn me.Substring(startIndex, endIdx - startIndex);\n\t"]]></e></m></meta>
		</substring>
		<toLowerCase public="1" set="method" line="182" static="1">
			<f a="me">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\treturn me.ToLower();\n\t"</e></m></meta>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="190" static="1">
			<f a="me">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\treturn me.ToUpper();\n\t"</e></m></meta>
		</toUpperCase>
		<toNativeString public="1" set="method" line="195" static="1"><f a="me">
	<t path="cs.internal._StringExt.NativeString"/>
	<t path="cs.internal._StringExt.NativeString"/>
</f></toNativeString>
		<fromCharCode public="1" set="method" line="203" static="1">
			<f a="code">
				<x path="Int"/>
				<t path="cs.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\treturn new string( (char) code, 1 );\n\t"</e></m></meta>
		</fromCharCode>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringExt"</e></m>
		</meta>
	</class>
	<class path="cs.internal._StringExt.StringRefl" params="" file="/usr/lib/haxe/std/cs/internal/StringExt.hx" private="1" module="cs.internal.StringExt">
		<fields public="1" line="211" static="1"><c path="Array"><c path="String"/></c></fields>
		<handleGetField public="1" set="method" line="213" static="1"><f a="str:f:throwErrors">
	<t path="cs.internal._StringExt.NativeString"/>
	<t path="cs.internal._StringExt.NativeString"/>
	<x path="Bool"/>
	<d/>
</f></handleGetField>
		<handleCallField public="1" set="method" line="228" static="1"><f a="str:f:args">
	<t path="cs.internal._StringExt.NativeString"/>
	<t path="cs.internal._StringExt.NativeString"/>
	<c path="Array"><d/></c>
	<d/>
</f></handleCallField>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringRefl"</e></m>
		</meta>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<helper><t path="haxe.io.BytesData"/></helper>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="77"><f a="?bufsize">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="119"><f a="end">
	<x path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="144"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="198"><f a=""><x path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="271"><f a=""><x path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="278"><f a=""><x path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="287"><f a=""><x path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="293"><f a=""><x path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="303"><f a=""><x path="Int"/></f></readUInt24>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readString public="1" set="method" line="318"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="cs.io.NativeInput" params="" file="/usr/lib/haxe/std/cs/io/NativeInput.hx">
		<extends path="haxe.io.Input"/>
		<canSeek public="1" get="accessor" set="null"><x path="Bool"/></canSeek>
		<stream><c path="cs.system.io.Stream"/></stream>
		<readByte public="1" set="method" line="40" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="47" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></close>
		<get_canSeek set="method" line="62"><f a=""><x path="Bool"/></f></get_canSeek>
		<seek public="1" set="method" line="67"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="79"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method" line="84"><f a=""><x path="Bool"/></f></eof>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<LN2 line="31" static="1"><x path="Float"/></LN2>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="65"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="71"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="78"><f a="s">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="97"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="151"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="228"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="234"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="239"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="250"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="255"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt24>
		<writeInt32 public="1" set="method" line="268"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="288">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="291"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="cs.io.NativeOutput" params="" file="/usr/lib/haxe/std/cs/io/NativeOutput.hx">
		<extends path="haxe.io.Output"/>
		<canSeek get="accessor" set="null"><x path="Bool"/></canSeek>
		<stream><c path="cs.system.io.Stream"/></stream>
		<writeByte public="1" set="method" line="37" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<close public="1" set="method" line="42" override="1"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></flush>
		<prepare public="1" set="method" line="52" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></prepare>
		<get_canSeek set="method" line="58"><f a=""><x path="Bool"/></f></get_canSeek>
		<seek public="1" set="method" line="63"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="75"><f a=""><x path="Int"/></f></tell>
		<new public="1" set="method" line="31"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="cs.system.Activator" params="" file="/usr/lib/haxe/std/cs/system/Activator.hx" extern="1">
		<CreateInstance public="1" set="method" static="1"><f a="t">
	<c path="cs.system.Type"/>
	<d/>
</f></CreateInstance>
		<meta><m n=":native"><e>"System.Activator"</e></m></meta>
	</class>
	<class path="cs.system.BitConverter" params="" file="/usr/lib/haxe/std/cs/system/BitConverter.hx" extern="1">
		<IsLittleEndian public="1" set="null" static="1"><x path="Bool"/></IsLittleEndian>
		<DoubleToInt64Bits public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<c path="haxe.Int64"/>
</f></DoubleToInt64Bits>
		<Int64BitsToDouble public="1" set="method" static="1"><f a="v">
	<c path="haxe.Int64"/>
	<x path="Float"/>
</f></Int64BitsToDouble>
		<GetBytes public="1" set="method" static="1"><f a="d">
	<d/>
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
</f></GetBytes>
		<ToBoolean public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></ToBoolean>
		<ToChar public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.Char16"/>
</f></ToChar>
		<ToDouble public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<x path="Float"/>
</f></ToDouble>
		<ToInt16 public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.Int16"/>
</f></ToInt16>
		<ToInt32 public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></ToInt32>
		<ToInt64 public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></ToInt64>
		<ToSingle public="1" set="method" static="1"><f a="b:startIndex">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<x path="Single"/>
</f></ToSingle>
		<meta><m n=":native"><e>"System.BitConverter"</e></m></meta>
	</class>
	<class path="cs.system.Console" params="" file="/usr/lib/haxe/std/cs/system/Console.hx" extern="1">
		<Error public="1" set="null" static="1"><c path="cs.system.io.StreamWriter"/></Error>
		<In public="1" set="null" static="1"><c path="cs.system.io.StreamReader"/></In>
		<Out public="1" set="null" static="1"><c path="cs.system.io.StreamWriter"/></Out>
		<Write public="1" set="method" static="1"><f a="obj">
	<d/>
	<x path="Void"/>
</f></Write>
		<WriteLine public="1" set="method" static="1"><f a="obj">
	<d/>
	<x path="Void"/>
</f></WriteLine>
		<OpenStandardOutput public="1" set="method" static="1"><f a=""><c path="cs.system.io.Stream"/></f></OpenStandardOutput>
		<OpenStandardInput public="1" set="method" static="1"><f a=""><c path="cs.system.io.Stream"/></f></OpenStandardInput>
		<OpenStandardError public="1" set="method" static="1"><f a=""><c path="cs.system.io.Stream"/></f></OpenStandardError>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install/update hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.Console"</e></m></meta>
	</class>
	<class path="cs.system.DateTime" params="" file="/usr/lib/haxe/std/cs/system/DateTime.hx" extern="1">
		<Now public="1" set="null" static="1"><c path="cs.system.DateTime"/></Now>
		<UtcNow public="1" set="null" static="1"><c path="cs.system.DateTime"/></UtcNow>
		<Day public="1" set="null"><x path="Int"/></Day>
		<DayOfWeek public="1" set="null"><e path="cs.system.DayOfWeek"/></DayOfWeek>
		<DayOfYear public="1" set="null"><x path="Int"/></DayOfYear>
		<Hour public="1" set="null"><x path="Int"/></Hour>
		<Millisecond public="1" set="null"><x path="Int"/></Millisecond>
		<Minute public="1" set="null"><x path="Int"/></Minute>
		<Second public="1" set="null"><x path="Int"/></Second>
		<Year public="1" set="null"><x path="Int"/></Year>
		<Month public="1" set="null"><x path="Int"/></Month>
		<Ticks public="1" set="null"><c path="haxe.Int64"/></Ticks>
		<new public="1" set="method">
			<f a="ticks">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<overloads><new public="1" set="method"><f a="year:month:day:hour:min:sec">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
		<meta><m n=":native"><e>"System.DateTime"</e></m></meta>
	</class>
	<enum path="cs.system.DayOfWeek" params="" file="/usr/lib/haxe/std/cs/system/DateTime.hx" module="cs.system.DateTime">
		<Sunday/>
		<Monday/>
		<Tuesday/>
		<Wedsneday/>
		<Thursday/>
		<Friday/>
		<Saturday/>
		<meta><m n=":native"><e>"System.DayOfWeek"</e></m></meta>
	</enum>
	<class path="cs.system.TimeSpan" params="" file="/usr/lib/haxe/std/cs/system/DateTime.hx" module="cs.system.DateTime" extern="1">
		<TicksPerMillisecond public="1" set="null" static="1"><x path="Int"/></TicksPerMillisecond>
		<meta><m n=":native"><e>"System.TimeSpan"</e></m></meta>
	</class>
	<class path="cs.system.Environment" params="" file="/usr/lib/haxe/std/cs/system/Environment.hx" extern="1">
		<Exit public="1" set="method" static="1"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></Exit>
		<GetEnvironmentVariables public="1" set="method" static="1"><f a=""><c path="cs.system.collections.IDictionary"/></f></GetEnvironmentVariables>
		<GetEnvironmentVariable public="1" set="method" static="1"><f a="k">
	<c path="String"/>
	<c path="String"/>
</f></GetEnvironmentVariable>
		<SetEnvironmentVariable public="1" set="method" static="1"><f a="k:v">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></SetEnvironmentVariable>
		<GetCommandLineArgs public="1" set="method" static="1"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetCommandLineArgs>
		<NewLine public="1" set="null" static="1"><c path="String"/></NewLine>
		<TickCount public="1" set="null" static="1"><x path="Int"/></TickCount>
		<OSVersion public="1" set="null" static="1"><c path="cs.system.OperatingSystem"/></OSVersion>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install/update hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.Environment"</e></m></meta>
	</class>
	<class path="cs.system.IConvertible" params="" file="/usr/lib/haxe/std/cs/system/IConvertible.hx" extern="1" interface="1">
		<ToType public="1" set="method"><f a="conversionType:provider">
	<c path="cs.system.Type"/>
	<c path="cs.system.IFormatProvider"/>
	<d/>
</f></ToType>
		<meta><m n=":native"><e>"System.IConvertible"</e></m></meta>
	</class>
	<class path="cs.system.IFormatProvider" params="" file="/usr/lib/haxe/std/cs/system/IFormatProvider.hx" extern="1" interface="1"><meta><m n=":native"><e>"System.IFormatProvider"</e></m></meta></class>
	<class path="cs.system.LocalDataStoreSlot" params="" file="/usr/lib/haxe/std/cs/system/LocalDataStoreSlot.hx" extern="1"><meta>
	<m n=":final"/>
	<m n=":native"><e>"System.LocalDataStoreSlot"</e></m>
</meta></class>
	<class path="cs.system.OperatingSystem" params="" file="/usr/lib/haxe/std/cs/system/OperatingSystem.hx" extern="1">
		<Platform public="1" set="null"><e path="cs.system.PlatformID"/></Platform>
		<Version public="1" set="null"><c path="cs.system.Version"/></Version>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install/update hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.OperatingSystem"</e></m></meta>
	</class>
	<enum path="cs.system.PlatformID" params="" file="/usr/lib/haxe/std/cs/system/PlatformID.hx">
		<Win32S/>
		<Win32Windows/>
		<Win32NT/>
		<WinCE/>
		<Unix/>
		<Xbox/>
		<MacOSX/>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install/update hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.PlatformID"</e></m></meta>
	</enum>
	<class path="cs.system.Type" params="" file="/usr/lib/haxe/std/cs/system/Type.hx" extern="1">
		<GetType public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<t path="Null"><c path="cs.system.Type"/></t>
</f></GetType>
		<Name public="1" set="null"><c path="String"/></Name>
		<BaseType public="1" set="null"><c path="cs.system.Type"/></BaseType>
		<IsInterface public="1" set="null"><x path="Bool"/></IsInterface>
		<ContainsGenericParameters public="1" set="null"><x path="Bool"/></ContainsGenericParameters>
		<IsValueType public="1" set="null"><x path="Bool"/></IsValueType>
		<IsAssignableFrom public="1" set="method"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsAssignableFrom>
		<GetConstructors public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c></f></GetConstructors>
		<meta><m n=":native"><e>"System.Type"</e></m></meta>
	</class>
	<class path="cs.system.Version" params="" file="/usr/lib/haxe/std/cs/system/Version.hx" extern="1">
		<Build public="1" set="null"><x path="Int"/></Build>
		<Major public="1" set="null"><x path="Int"/></Major>
		<Minor public="1" set="null"><x path="Int"/></Minor>
		<Revision public="1" set="null"><x path="Int"/></Revision>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install/update hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.Version"</e></m></meta>
	</class>
	<class path="cs.system.collections.IEnumerable" params="" file="/usr/lib/haxe/std/cs/system/collections/IEnumerable.hx" extern="1" interface="1">
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta><m n=":native"><e>"System.Collections.IEnumerable"</e></m></meta>
	</class>
	<class path="cs.system.collections.ICollection" params="" file="/usr/lib/haxe/std/cs/system/collections/ICollection.hx" extern="1" interface="1">
		<extends path="cs.system.collections.IEnumerable"/>
		<Count public="1" set="null"><x path="Int"/></Count>
		<IsSynchronized public="1" set="null"><x path="Bool"/></IsSynchronized>
		<SyncRoot public="1" set="null"><x path="Bool"/></SyncRoot>
		<CopyTo public="1" set="method"><f a="arr:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta><m n=":native"><e>"System.Collections.ICollection"</e></m></meta>
	</class>
	<class path="cs.system.collections.IDictionary" params="" file="/usr/lib/haxe/std/cs/system/collections/IDictionary.hx" extern="1" interface="1">
		<extends path="cs.system.collections.ICollection"/>
		<IsFixedSize public="1" set="null"><x path="Bool"/></IsFixedSize>
		<IsReadOnly public="1" set="null"><x path="Bool"/></IsReadOnly>
		<Add public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="key">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<Remove public="1" set="method"><f a="key">
	<d/>
	<x path="Void"/>
</f></Remove>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IDictionaryEnumerator"/></f></GetEnumerator>
		<meta><m n=":native"><e>"System.Collections.IDictionary"</e></m></meta>
	</class>
	<class path="cs.system.collections.IEnumerator" params="" file="/usr/lib/haxe/std/cs/system/collections/IEnumerator.hx" extern="1" interface="1">
		<Current public="1" set="null"><d/></Current>
		<MoveNext public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<meta><m n=":native"><e>"System.Collections.IEnumerator"</e></m></meta>
	</class>
	<class path="cs.system.collections.IDictionaryEnumerator" params="" file="/usr/lib/haxe/std/cs/system/collections/IDictionary.hx" module="cs.system.collections.IDictionary" extern="1" interface="1">
		<extends path="cs.system.collections.IEnumerator"/>
		<Key public="1" set="null"><d/></Key>
		<Value public="1" set="null"><d/></Value>
		<meta><m n=":native"><e>"System.Collections.IDictionaryEnumerator"</e></m></meta>
	</class>
	<class path="cs.system.io.Directory" params="" file="/usr/lib/haxe/std/cs/system/io/Directory.hx" extern="1">
		<CreateDirectory public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></CreateDirectory>
		<Delete public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></Delete>
		<Exists public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></Exists>
		<GetCurrentDirectory public="1" set="method" static="1"><f a=""><c path="String"/></f></GetCurrentDirectory>
		<GetDirectories public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDirectories>
		<GetDirectoryRoot public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></GetDirectoryRoot>
		<GetFiles public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetFiles>
		<GetFileSystemEntries public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetFileSystemEntries>
		<GetCreationTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetCreationTime>
		<GetLastAccessTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastAccessTime>
		<GetLastWriteTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastWriteTime>
		<Move public="1" set="method" static="1"><f a="path:newpath">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></Move>
		<SetCurrentDirectory public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></SetCurrentDirectory>
		<meta><m n=":native"><e>"System.IO.Directory"</e></m></meta>
	</class>
	<class path="cs.system.io.Stream" params="" file="/usr/lib/haxe/std/cs/system/io/Stream.hx" extern="1">
		<CanRead public="1" set="null"><x path="Bool"/></CanRead>
		<CanSeek public="1" set="null"><x path="Bool"/></CanSeek>
		<CanTimeout public="1" set="null"><x path="Bool"/></CanTimeout>
		<CanWrite public="1" set="null"><x path="Bool"/></CanWrite>
		<Length public="1" set="null"><c path="haxe.Int64"/></Length>
		<Position public="1" set="null"><c path="haxe.Int64"/></Position>
		<ReadTimeout public="1"><x path="Bool"/></ReadTimeout>
		<WriteTimeout public="1"><x path="Bool"/></WriteTimeout>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<CopyTo public="1" set="method"><f a="dest">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></CopyTo>
		<Dispose public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<Flush public="1" set="method"><f a=""><x path="Void"/></f></Flush>
		<Read public="1" set="method"><f a="buf:offset:count">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read>
		<ReadByte public="1" set="method"><f a=""><x path="Int"/></f></ReadByte>
		<Seek public="1" set="method"><f a="offset:origin">
	<c path="haxe.Int64"/>
	<e path="cs.system.io.SeekOrigin"/>
	<c path="haxe.Int64"/>
</f></Seek>
		<SetLength public="1" set="method"><f a="value">
	<c path="haxe.Int64"/>
	<x path="Void"/>
</f></SetLength>
		<Write public="1" set="method"><f a="buf:offset:count">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
		<WriteByte public="1" set="method"><f a="value">
	<t path="cs.UInt8"/>
	<x path="Void"/>
</f></WriteByte>
		<meta><m n=":native"><e>"System.IO.Stream"</e></m></meta>
	</class>
	<class path="cs.system.io.MemoryStream" params="" file="/usr/lib/haxe/std/cs/system/io/MemoryStream.hx" extern="1">
		<extends path="cs.system.io.Stream"/>
		<GetBuffer public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.UInt8"/></c></f></GetBuffer>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"System.IO.MemoryStream"</e></m></meta>
	</class>
	<enum path="cs.system.io.SeekOrigin" params="" file="/usr/lib/haxe/std/cs/system/io/SeekOrigin.hx">
		<Begin/>
		<Current/>
		<End/>
		<meta><m n=":native"><e>"System.IO.SeekOrigin"</e></m></meta>
	</enum>
	<class path="cs.system.io.StreamReader" params="" file="/usr/lib/haxe/std/cs/system/io/StreamReader.hx" extern="1">
		<BaseStream public="1" set="null"><c path="cs.system.io.Stream"/></BaseStream>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.IO.StreamReader"</e></m></meta>
	</class>
	<class path="cs.system.io.StreamWriter" params="" file="/usr/lib/haxe/std/cs/system/io/StreamWriter.hx" extern="1">
		<BaseStream public="1" set="null"><c path="cs.system.io.Stream"/></BaseStream>
		<haxe_doc>Warning: This class definition is incomplete.
	In order to get most current extern definitions, install hxcs library with:
		haxelib install hxcs
	Please refer to http://lib.haxe.org/p/hxcs for more information.</haxe_doc>
		<meta><m n=":native"><e>"System.IO.StreamWriter"</e></m></meta>
	</class>
	<class path="cs.system.reflection.MethodBase" params="" file="/usr/lib/haxe/std/cs/system/reflection/MethodBase.hx" extern="1">
		<Name public="1" set="null"><c path="String"/></Name>
		<ContainsGenericParameters public="1" set="null"><x path="Bool"/></ContainsGenericParameters>
		<GetParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<GetGenericArguments public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<Invoke public="1" set="method">
			<f a="obj:args">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads><Invoke public="1" set="method"><f a=""><d/></f></Invoke></overloads>
		</Invoke>
		<meta><m n=":native"><e>"System.Reflection.MethodBase"</e></m></meta>
	</class>
	<class path="cs.system.reflection.ConstructorInfo" params="" file="/usr/lib/haxe/std/cs/system/reflection/ConstructorInfo.hx" extern="1">
		<extends path="cs.system.reflection.MethodBase"/>
		<Invoke public="1" set="method" override="1">
			<f a="obj:args">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads><Invoke public="1" set="method"><f a="args">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke></overloads>
		</Invoke>
		<meta><m n=":native"><e>"System.Reflection.ConstructorInfo"</e></m></meta>
	</class>
	<class path="cs.system.reflection.MethodInfo" params="" file="/usr/lib/haxe/std/cs/system/reflection/MethodInfo.hx" extern="1">
		<extends path="cs.system.reflection.MethodBase"/>
		<MakeGenericMethod public="1" set="method"><f a="g">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></MakeGenericMethod>
		<meta><m n=":native"><e>"System.Reflection.MethodInfo"</e></m></meta>
	</class>
	<class path="cs.system.reflection.ParameterInfo" params="" file="/usr/lib/haxe/std/cs/system/reflection/ParameterInfo.hx" extern="1">
		<ParameterType public="1" set="null"><c path="cs.system.Type"/></ParameterType>
		<meta><m n=":native"><e>"System.Reflection.ParameterInfo"</e></m></meta>
	</class>
	<class path="cs.system.text.Encoding" params="" file="/usr/lib/haxe/std/cs/system/text/Encoding.hx" extern="1">
		<UTF8 public="1" set="null" static="1"><c path="cs.system.text.Encoding"/></UTF8>
		<GetString public="1" set="method"><f a="b:index:count">
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></GetString>
		<GetBytes public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.UInt8"/></c>
</f></GetBytes>
		<meta><m n=":native"><e>"System.Text.Encoding"</e></m></meta>
	</class>
	<class path="cs.system.text.regularExpressions.Regex" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" extern="1">
		<Match public="1" set="method">
			<f a="input">
				<c path="String"/>
				<c path="cs.system.text.regularExpressions.Match"/>
			</f>
			<overloads>
				<Match public="1" set="method"><f a="input:startPos:len">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.regularExpressions.Match"/>
</f></Match>
				<Match public="1" set="method"><f a="input:startPos">
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.system.text.regularExpressions.Match"/>
</f></Match>
			</overloads>
		</Match>
		<Split public="1" set="method"><f a="input">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
		<Replace public="1" set="method">
			<f a="input:replacement">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><Replace public="1" set="method"><f a="input:replacement:max">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></Replace></overloads>
		</Replace>
		<new public="1" set="method"><f a="pattern:options">
	<c path="String"/>
	<e path="cs.system.text.regularExpressions.RegexOptions"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.Regex"</e></m></meta>
	</class>
	<enum path="cs.system.text.regularExpressions.RegexOptions" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex">
		<None/>
		<IgnoreCase/>
		<Multiline/>
		<ExplicitCapture/>
		<Compiled/>
		<Singleline/>
		<IgnorePatternWhitespace/>
		<RightToLeft/>
		<ECMAScript/>
		<CultureInvariant/>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.RegexOptions"</e></m></meta>
	</enum>
	<class path="cs.system.text.regularExpressions.Capture" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex" extern="1">
		<Index public="1" set="null"><x path="Int"/></Index>
		<Length public="1" set="null"><x path="Int"/></Length>
		<Value public="1" set="null"><c path="String"/></Value>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.Capture"</e></m></meta>
	</class>
	<class path="cs.system.text.regularExpressions.Group" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex" extern="1">
		<extends path="cs.system.text.regularExpressions.Capture"/>
		<Success public="1" set="null"><x path="Bool"/></Success>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.Group"</e></m></meta>
	</class>
	<class path="cs.system.text.regularExpressions.Match" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex" extern="1">
		<extends path="cs.system.text.regularExpressions.Group"/>
		<Captures public="1" set="null"><c path="cs.system.text.regularExpressions.CaptureCollection"/></Captures>
		<Groups public="1" set="null"><c path="cs.system.text.regularExpressions.GroupCollection"/></Groups>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.Match"</e></m></meta>
	</class>
	<class path="cs.system.text.regularExpressions.CaptureCollection" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex" extern="1">
		<Count public="1" set="null"><x path="Int"/></Count>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.CaptureCollection"</e></m></meta>
	</class>
	<class path="cs.system.text.regularExpressions.GroupCollection" params="" file="/usr/lib/haxe/std/cs/system/text/regularExpressions/Regex.hx" module="cs.system.text.regularExpressions.Regex" extern="1">
		<Count public="1" set="null"><x path="Int"/></Count>
		<meta><m n=":native"><e>"System.Text.RegularExpressions.GroupCollection"</e></m></meta>
	</class>
	<typedef path="cs.system.threading.ThreadStart" params="" file="/usr/lib/haxe/std/cs/system/threading/Thread.hx" module="cs.system.threading.Thread">
		<f a=""><x path="Void"/></f>
		<meta>
			<m n=":native"><e>"System.Threading.ThreadStart"</e></m>
			<m n=":delegate"/>
		</meta>
	</typedef>
	<class path="cs.system.threading.Thread" params="" file="/usr/lib/haxe/std/cs/system/threading/Thread.hx" extern="1">
		<AllocateDataStoreSlot public="1" set="method" static="1"><f a=""><c path="cs.system.LocalDataStoreSlot"/></f></AllocateDataStoreSlot>
		<GetData public="1" set="method" static="1"><f a="slot">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
</f></GetData>
		<SetData public="1" set="method" static="1"><f a="slot:data">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
	<x path="Void"/>
</f></SetData>
		<Sleep public="1" set="method" static="1"><f a="ms">
	<x path="Int"/>
	<x path="Void"/>
</f></Sleep>
		<Abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Abort public="1" set="method"><f a="obj">
	<d/>
	<x path="Void"/>
</f></Abort></overloads>
		</Abort>
		<Join public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Join public="1" set="method"><f a="msTimeout">
	<x path="Int"/>
	<x path="Void"/>
</f></Join></overloads>
		</Join>
		<Start public="1" set="method"><f a=""><x path="Void"/></f></Start>
		<new public="1" set="method">
			<f a="s">
				<t path="cs.system.threading.ThreadStart"/>
				<x path="Void"/>
			</f>
			<overloads><new public="1" set="method"><f a="s:maxStack">
	<t path="cs.system.threading.ThreadStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta><m n=":native"><e>"System.Threading.Thread"</e></m></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<abstract path="haxe._Int64.NativeInt64" params="" file="/usr/lib/haxe/std/cs/_std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="haxe._Int64.NativeUInt64" params="" file="/usr/lib/haxe/std/cs/_std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="haxe.Int64" params="" file="/usr/lib/haxe/std/cs/_std/haxe/Int64.hx">
		<asNative get="inline" set="null" line="30" static="1">
			<f a="i">
				<c path="haxe.Int64"/>
				<x path="haxe._Int64.NativeInt64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</asNative>
		<ofNative get="inline" set="null" line="31" static="1">
			<f a="i">
				<x path="haxe._Int64.NativeInt64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</ofNative>
		<mkNative get="inline" set="null" line="32" static="1">
			<f a="i">
				<d/>
				<x path="haxe._Int64.NativeInt64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</mkNative>
		<make public="1" get="inline" set="null" line="34" static="1"><f a="high:low">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></make>
		<getLow public="1" get="inline" set="null" line="39" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></getLow>
		<getHigh public="1" get="inline" set="null" line="44" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></getHigh>
		<ofInt public="1" get="inline" set="null" line="48" static="1"><f a="x">
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="52" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></toInt>
		<add public="1" get="inline" set="null" line="57" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></add>
		<sub public="1" get="inline" set="null" line="62" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="67" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mul>
		<divMod set="method" line="71" static="1"><f a="modulus:divisor">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<a>
		<quotient><c path="haxe.Int64"/></quotient>
		<modulus><c path="haxe.Int64"/></modulus>
	</a>
</f></divMod>
		<div public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></div>
		<mod public="1" get="inline" set="null" line="82" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="90" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="98" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></and>
		<or public="1" get="inline" set="null" line="103" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></or>
		<xor public="1" get="inline" set="null" line="108" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="113" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="118" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<x path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="123" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<x path="Bool"/>
</f></isZero>
		<compare public="1" get="inline" set="null" line="128" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="133" static="1">
			<f a="a:b">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compare two Int64 in unsigned mode.</haxe_doc>
		</ucompare>
		<toStr public="1" get="inline" set="null" line="140" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="String"/>
</f></toStr>
		<meta>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="521" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="169"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="206"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="224">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<serializeException public="1" set="method" line="498"><f a="e">
	<d/>
	<x path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:
	
	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:
		
		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="433" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<getResolver public="1" set="method" line="139">
			<f a=""><t path="haxe.TypeResolver"/></f>
			<haxe_doc>Gets the type resolver of `this` Unserializer instance.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</getResolver>
		<get get="inline" set="null" line="143"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<unserializeObject set="method" line="172"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="187"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="219">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:
	
	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<encode public="1" set="method" line="127" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="132" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<encodeString public="1" set="method" line="111"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encodeString>
		<decodeString public="1" set="method" line="119"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decodeString>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionnary.</haxe_doc>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/lib/haxe/std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="26" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<make public="1" set="method" line="36" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<str2blks set="method" line="104" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bytes2blks set="method" line="121" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="58"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<rol get="inline" set="null" line="141">
			<f a="num:cnt">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Bitwise rotate a 32-bit number to the left</haxe_doc>
		</rol>
		<ft set="method" line="148">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="158">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<hex set="method" line="168"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.
		
		If `key` is already bound to a value, that binding disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.
		
		If `key` is not bound to any value, `null` is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.
		
		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.
		
		Otherwise the binding of `key` is removed and true is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.
		
		This method returns true even if `key` is bound to null.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="115">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="126">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</keys>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<iteratorLoop set="method" line="153"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<keysLoop set="method" line="161"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="205"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.
	
	Operations have a logarithmic average and worst-case cost.
	
	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="231">
			<f a=""><x path="Int"/></f>
			<meta><m n=":extern"/></meta>
		</get_height>
		<toString public="1" set="method" line="233"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.
	
	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
	<_new public="1" set="method" line="25" static="1">
		<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<set public="1" get="inline" set="null" line="28" static="1">
		<f a="this:k:v">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<c path="haxe.ds.HashMap.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="32" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
	<exists public="1" get="inline" set="null" line="35" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</exists>
	<remove public="1" get="inline" set="null" line="38" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<keys public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</keys>
	<iterator public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
</class></impl>
	</abstract>
	<class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
		<_new public="1" set="method" line="25" static="1">
			<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<set public="1" get="inline" set="null" line="28" static="1">
			<f a="this:k:v">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="32" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
		<exists public="1" get="inline" set="null" line="35" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</exists>
		<remove public="1" get="inline" set="null" line="38" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<keys public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</keys>
		<iterator public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/cs/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="38" static="1"><x path="Float"/></HASH_UPPER>
		<assert get="inline" set="null" line="403" static="1"><f a="x">
	<x path="Bool"/>
	<x path="Void"/>
</f></assert>
		<defaultK get="inline" set="null" line="410" static="1"><f a=""><x path="Int"/></f></defaultK>
		<arrayCopy get="inline" set="null" line="412" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arrayCopy>
		<getInc get="inline" set="null" line="415" static="1"><f a="k:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInc>
		<hash get="inline" set="null" line="418" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<flagIsEmpty get="inline" set="null" line="421" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></flagIsEmpty>
		<flagIsDel get="inline" set="null" line="424" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></flagIsDel>
		<isEither get="inline" set="null" line="427" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></isEither>
		<setIsDelFalse get="inline" set="null" line="430" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsDelFalse>
		<setIsEmptyFalse get="inline" set="null" line="433" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsEmptyFalse>
		<setIsBothFalse get="inline" set="null" line="436" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsBothFalse>
		<setIsDelTrue get="inline" set="null" line="439" static="1"><f a="flag:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsDelTrue>
		<roundUp get="inline" set="null" line="442" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></roundUp>
		<flagsSize get="inline" set="null" line="453" static="1"><f a="m">
	<x path="Int"/>
	<x path="Int"/>
</f></flagsSize>
		<flags><c path="cs.NativeArray"><x path="Int"/></c></flags>
		<_keys><c path="cs.NativeArray"><x path="Int"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.IntMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><x path="Int"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="57">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="113">
			<f a="key">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<get public="1" set="method" line="135">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="155"><f a="key:def">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
	<c path="haxe.ds.IntMap.T"/>
</f></getDefault>
		<exists public="1" set="method" line="175">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="195">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<resize set="method" line="223">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":final"/></meta>
		</resize>
		<keys public="1" set="method" line="329">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="360">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="388">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/cs/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":extern"/></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="425" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</roundUp>
		<getInc get="inline" set="null" line="436" static="1">
			<f a="k:mask">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInc>
		<isEither get="inline" set="null" line="439" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEither>
		<isEmpty get="inline" set="null" line="442" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEmpty>
		<isDel get="inline" set="null" line="445" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isDel>
		<hash params="K" get="inline" set="null" line="449" static="1">
			<f a="s">
				<c path="hash.K"/>
				<t path="haxe.ds._ObjectMap.HashType"/>
			</f>
			<meta><m n=":extern"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="477" static="1">
			<f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</arrayCopy>
		<assert get="inline" set="null" line="480" static="1">
			<f a="x">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</assert>
		<hashes>
			<c path="cs.NativeArray"><t path="haxe.ds._ObjectMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="cs.NativeArray"><c path="haxe.ds.ObjectMap.K"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.ObjectMap.V"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="haxe.ds.ObjectMap.K"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="64">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="129">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<resize set="method" line="160">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":final"/>
				<m n=":private"/>
			</meta>
		</resize>
		<get public="1" set="method" line="263">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="283"><f a="key:def">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
	<c path="haxe.ds.ObjectMap.V"/>
</f></getDefault>
		<exists public="1" set="method" line="303">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="323">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="351">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="382">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="410">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.
	
	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="haxe.ds._ObjectMap.HashType" params="" file="/usr/lib/haxe/std/cs/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap"><x path="Int"/></typedef>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/cs/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":extern"/></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="425" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</roundUp>
		<getInc get="inline" set="null" line="436" static="1">
			<f a="k:mask">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInc>
		<isEither get="inline" set="null" line="439" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEither>
		<isEmpty get="inline" set="null" line="442" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEmpty>
		<isDel get="inline" set="null" line="445" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isDel>
		<hash get="inline" set="null" line="449" static="1">
			<f a="s">
				<c path="String"/>
				<t path="haxe.ds._StringMap.HashType"/>
			</f>
			<meta><m n=":extern"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="477" static="1">
			<f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</arrayCopy>
		<assert get="inline" set="null" line="480" static="1">
			<f a="x">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</assert>
		<hashes>
			<c path="cs.NativeArray"><t path="haxe.ds._StringMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="cs.NativeArray"><c path="String"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.StringMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="String"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="64">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="129">
			<f a="key">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<resize set="method" line="160">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":final"/>
				<m n=":private"/>
			</meta>
		</resize>
		<get public="1" set="method" line="263">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="283"><f a="key:def">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
	<c path="haxe.ds.StringMap.T"/>
</f></getDefault>
		<exists public="1" set="method" line="303">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="323">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="351">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="382">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="410">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="haxe.ds._StringMap.HashType" params="" file="/usr/lib/haxe/std/cs/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap"><x path="Int"/></typedef>
	<class path="haxe.ds.WeakMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/WeakMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.WeakMap.K"/>
			<c path="haxe.ds.WeakMap.V"/>
		</implements>
		<set public="1" set="method" line="44">
			<f a="key:value">
				<c path="haxe.ds.WeakMap.K"/>
				<c path="haxe.ds.WeakMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="50">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<t path="Null"><c path="haxe.ds.WeakMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="57">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="85">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new WeakMap.</haxe_doc>
		</new>
		<haxe_doc>WeakMap allows mapping of object keys to arbitrary values.
	
	The keys are considered to be weak references on static targets.
	
	See `Map` for documentation details.</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="250" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="275" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="324" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<fastGet public="1" get="inline" set="null" line="342" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="34"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="50"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method" line="68"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<sub public="1" set="method" line="99"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="125"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<readString public="1" set="method" line="163"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="211"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="232"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="246"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="cs.system.io.MemoryStream"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="63"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" get="inline" set="null" line="75"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="93"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="112"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="138">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="cs.NativeArray"><t path="cs.UInt8"/></c></typedef>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_position get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_position>
		<get_length get="inline" set="null" line="68"><f a=""><x path="Int"/></f></get_length>
		<set_position set="method" line="76"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="84" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="105" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CInt a="v"><c path="String"/></CInt>
		<CFloat a="f"><c path="String"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<CIdent a="s"><c path="String"/></CIdent>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd/>
		<OpMult/>
		<OpDiv/>
		<OpSub/>
		<OpAssign/>
		<OpEq/>
		<OpNotEq/>
		<OpGt/>
		<OpGte/>
		<OpLt/>
		<OpLte/>
		<OpAnd/>
		<OpOr/>
		<OpXor/>
		<OpBoolAnd/>
		<OpBoolOr/>
		<OpShl/>
		<OpShr/>
		<OpUShr/>
		<OpMod/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpInterval/>
		<OpArrow/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement/>
		<OpDecrement/>
		<OpNot/>
		<OpNeg/>
		<OpNegBits/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<x path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EVars a="vars"><c path="Array"><t path="haxe.macro.Var"/></c></EVars>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Case"/></c>
			<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		</ESwitch>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Catch"/></c>
		</ETry>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EBreak/>
		<EContinue/>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EDisplay>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<EMeta a="s:e">
			<t path="haxe.macro.MetadataEntry"/>
			<t path="haxe.macro.Expr"/>
		</EMeta>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><x path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<APublic/>
		<APrivate/>
		<AStatic/>
		<AOverride/>
		<ADynamic/>
		<AInline/>
		<AMacro/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
		<FProp a="get:set:?t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><x path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDEnum/>
		<TDStructure/>
		<TDClass a="?superClass:?interfaces:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<x path="Bool"/>
		</TDClass>
		<TDAlias a="t"><e path="haxe.macro.ComplexType"/></TDAlias>
		<TDAbstract a="tthis:?from:?to">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		</TDAbstract>
	</enum>
	<class path="haxe.macro.Error" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<message public="1"><c path="String"/></message>
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<toString set="method" line="239"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="235"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<class path="haxe.remoting.AsyncConnection" params="" file="/usr/lib/haxe/std/haxe/remoting/AsyncConnection.hx" interface="1">
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method"><f a="params:?result">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method"><f a="error">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.remoting.Context" params="" file="/usr/lib/haxe/std/haxe/remoting/Context.hx">
		<share public="1" set="method" line="55" static="1"><f a="name:obj">
	<c path="String"/>
	<a/>
	<c path="haxe.remoting.Context"/>
</f></share>
		<objects><c path="haxe.ds.StringMap"><a>
	<rec><x path="Bool"/></rec>
	<obj><d/></obj>
</a></c></objects>
		<addObject public="1" set="method" line="32"><f a="name:obj:?recursive">
	<c path="String"/>
	<a/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addObject>
		<call public="1" set="method" line="36"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="/usr/lib/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></TAG_NAME>
		<BODY public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></CHILDS>
		<CLOSE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></CLOSE>
		<WAIT_END public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></PCDATA>
		<HEADER public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></HEADER>
		<COMMENT public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></COMMENT>
		<DOCTYPE public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DOCTYPE>
		<CDATA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></CDATA>
		<ESCAPE public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></ESCAPE>
	</class>
	<class path="haxe.xml.Parser" params="" file="/usr/lib/haxe/std/haxe/xml/Parser.hx">
		<escapes line="51" static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></escapes>
		<parse public="1" set="method" line="62" static="1"><f a="str">
	<c path="String"/>
	<c path="Xml"/>
</f></parse>
		<doParse set="method" line="69" static="1"><f a="str:?p:?parent">
	<c path="String"/>
	<x path="Int"/>
	<c path="Xml"/>
	<x path="Int"/>
</f></doParse>
		<isValidChar get="inline" set="null" line="343" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
	</class>
	<class path="jabber.Attention" params="" file="../../jabber/Attention.hx">
		<capture public="1" set="method" line="33" static="1">
			<f a="stream:jid:message">
				<c path="jabber.Stream"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends a message packet to the given entity inluding a property to get attention</haxe_doc>
		</capture>
		<haxe_doc>Extension for getting the attention of another user.
	XEP 224 - Attention: http://www.xmpp.org/extensions/xep-0224.html</haxe_doc>
	</class>
	<class path="jabber.EntityCapabilities" params="" file="../../jabber/EntityCapabilities.hx">
		<onCaps public="1" set="dynamic" line="34">
			<f a="jid:caps:cb">
				<c path="String"/>
				<c path="xmpp.Caps"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback to application for checking if caps already exist (in cache)</haxe_doc>
		</onCaps>
		<onInfo public="1" set="dynamic" line="37">
			<f a="jid:info:?ver">
				<c path="String"/>
				<c path="xmpp.disco.Info"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fired when a new entity capability got discovered</haxe_doc>
		</onInfo>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<node public="1" set="null">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application,
		typically a URL at the website of the project or company that produces the software</haxe_doc>
		</node>
		<ver public="1" set="null">
			<c path="String"/>
			<haxe_doc>My own verification string</haxe_doc>
		</ver>
		<collector><c path="jabber.PacketCollector"/></collector>
		<x><c path="Xml"/></x>
		<createVerificationString public="1" set="method" line="80">
			<f a="identities:features:?dataform">
				<c path="Array"><t path="xmpp.disco.Identity"/></c>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create/Recreate the verification string
		Call if your stream changes features</haxe_doc>
		</createVerificationString>
		<interceptPacket public="1" set="method" line="84"><f a="p">
	<c path="xmpp.Packet"/>
	<c path="xmpp.Packet"/>
</f></interceptPacket>
		<dispose public="1" set="method" line="100"><f a=""><x path="Void"/></f></dispose>
		<handlePresence set="method" line="105"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<handleInfoResponse set="method" line="114"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoResponse>
		<requestDiscoInfo set="method" line="131"><f a="jid:?node">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></requestDiscoInfo>
		<new public="1" set="method" line="57"><f a="stream:node:identities:?ext">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for broadcasting and dynamically discovering client, device, or generic entity capabilities.

	XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="jabber.EntityTime" params="" file="../../jabber/EntityTime.hx">
		<onLoad public="1" set="dynamic" line="31"><f a="jid:t">
	<c path="String"/>
	<c path="xmpp.EntityTime"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request the local time of another jabber entity.</haxe_doc>
		</load>
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<new public="1" set="method" line="36"><f a="s">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for requesting the local time of an entity.

	XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.EntityTimeListener" params="" file="../../jabber/EntityTimeListener.hx">
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<time public="1" set="null"><c path="xmpp.EntityTime"/></time>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<handleRequest set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<new public="1" set="method" line="36"><f a="stream:?tzo">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers entity time requests.

	XEP 202 - EntityTime http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.JID" params="" file="../../jabber/JID.hx">
		<node public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</node>
		<domain public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</domain>
		<resource public="1">
			<c path="String"/>
			<haxe_doc>Resourcepart, uniquely identifies a specific connection (e.g., a device or location)</haxe_doc>
		</resource>
		<bare public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>JID without resource</haxe_doc>
		</bare>
		<s public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Just a shortcut for toString()</haxe_doc>
		</s>
		<get_bare set="method" line="65"><f a=""><c path="String"/></f></get_bare>
		<get_s get="inline" set="null" line="69"><f a=""><c path="String"/></f></get_s>
		<copy public="1" set="method" line="71"><f a=""><c path="jabber.JID"/></f></copy>
		<toString public="1" set="method" line="79"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="55"><f a="?t">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Unique Jabber-ID.

	A JID is made up of a node (generally a username), a domain, and a resource.

		jid             = [ node "@" ] domain [ "/" resource ]
		domain          = fqdn / address-literal
		fqdn            = (sub-domain 1*("." sub-domain))
		sub-domain      = (internationalized domain label)
		address-literal = IPv4address / IPv6address

	Each allowable portion of a JID (node, domain, and resource) must not be more than 1023 bytes in length,
	resulting in a maximum total size (including the '@' and '/' separators) of 3071 bytes.</haxe_doc>
	</class>
	<class path="jabber.JIDUtil" params="" file="../../jabber/JIDUtil.hx">
		<MIN_LENGTH public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></MIN_LENGTH>
		<MAX_PARTSIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_PARTSIZE>
		<MAX_SIZE public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></MAX_SIZE>
		<EREG public="1" line="38" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid JID</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="57" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID is valid formed.</haxe_doc>
		</isValid>
		<node public="1" get="inline" set="null" line="74" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The node of the given JID.</haxe_doc>
		</node>
		<domain public="1" set="method" line="81" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The domain of the given JID.</haxe_doc>
		</domain>
		<resource public="1" set="method" line="90" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The resource of the given JID.</haxe_doc>
		</resource>
		<bare public="1" set="method" line="98" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes The resource from a JID.</haxe_doc>
		</bare>
		<hasResource public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID has a valid resource.</haxe_doc>
		</hasResource>
		<parts public="1" set="method" line="113" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>@returns A String array with parsed node, domain and resource.</haxe_doc>
		</parts>
		<splitBare public="1" set="method" line="122" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits the given JID into parts and returns it as array excluding the resource.</haxe_doc>
		</splitBare>
		<compare public="1" set="method" line="130" static="1">
			<f a="a:b">
				<c path="jabber.JID"/>
				<c path="jabber.JID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</compare>
		<escapeNode public="1" set="method" line="145" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escapes the node portion of a JID according to "JID Escaping" (XEP-0106).
	    Escaping replaces characters prohibited by node-prep with escape sequences.

	    Typically, escaping is performed only by a client that is processing information
	    provided by a human user in unescaped form, or by a gateway to some external system
	    (e.g., email or LDAP) that needs to generate a JID.</haxe_doc>
		</escapeNode>
		<unescapeNode public="1" set="method" line="169" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Un-escapes the node portion of a JID according to XEP-0106:JID Escaping (http://www.xmpp.org/extensions/xep-0106.html).
     	Escaping replaces characters prohibited by node-prep with escape sequences.

     	Typically, unescaping is performed only by a client that wants to display JIDs
     	containing escaped characters to a human user, or by a gateway to some
     	external system (e.g., email or LDAP) that needs to generate identifiers
     	for foreign systems.</haxe_doc>
		</unescapeNode>
		<haxe_doc>Static methods for jabber-id validation and manipulation.</haxe_doc>
	</class>
	<class path="jabber.LastActivity" params="" file="../../jabber/LastActivity.hx">
		<onLoad public="1" set="dynamic" line="29"><f a="entity:secs">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<request public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Requests the given entity for their last activity.<br/>
		Given a bare jid will be handled by the server on roster subscription basis.<br/>
		Otherwise the request will be fowarded to the resource of the client entity.<br/>]]></haxe_doc>
		</request>
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.LastActivityListener" params="" file="../../jabber/LastActivityListener.hx">
		<time public="1">
			<x path="Int"/>
			<haxe_doc>Seconds passed after last user activity</haxe_doc>
		</time>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="43"><f a=""><x path="Void"/></f></dispose>
		<handleRequest set="method" line="51"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<new public="1" set="method" line="35"><f a="stream:?time">
	<c path="jabber.Stream"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.MUCUtil" params="" file="../../jabber/MUCUtil.hx">
		<EREG public="1" line="30" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid MUC address</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="36" static="1">
			<f a="t:?nick">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given string is a valid muchat address.
		The 'nick' parameter indicates if a full adress (including nickname) is expected.</haxe_doc>
		</isValid>
		<getRoom public="1" get="inline" set="null" line="45" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the room of the muc jid.</haxe_doc>
		</getRoom>
		<getHost public="1" get="inline" set="null" line="52" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the host of the muc jid.</haxe_doc>
		</getHost>
		<getNick public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the occupant name of the muc jid.</haxe_doc>
		</getNick>
		<getParts public="1" set="method" line="67" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns array existing of roomname[0], host[1] and (optional) occupantname[2] of the given muc address.</haxe_doc>
		</getParts>
		<haxe_doc>Static methods for parsing of mutliuser chat addresses.</haxe_doc>
	</class>
	<class path="jabber.PacketListener" params="T" file="../../jabber/PacketListener.hx">
		<onPacket public="1" set="dynamic" line="30">
			<f a="p">
				<c path="jabber.PacketListener.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Packet recieved callback</haxe_doc>
		</onPacket>
		<listen public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Activates/Deactivates packet collecting</haxe_doc>
		</listen>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<collector><c path="jabber.PacketCollector"/></collector>
		<set_listen set="method" line="47"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_listen>
		<handlePacket set="method" line="53"><f a="p">
	<c path="jabber.PacketListener.T"/>
	<x path="Void"/>
</f></handlePacket>
		<new set="method" line="38"><f a="stream:handler:type:listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="jabber.PacketListener.T"/>
		<x path="Void"/>
	</f>
	<e path="xmpp.PacketType"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for top level packet listeners (jabber.PresenceListener, jabber.MessageListener).</haxe_doc>
	</class>
	<class path="jabber.MessageListener" params="" file="../../jabber/MessageListener.hx">
		<extends path="jabber.PacketListener"><c path="xmpp.Message"/></extends>
		<new public="1" set="method" line="34"><f a="stream:handler:?listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="xmpp.Message"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Utility (shortcut) to listen/report incoming message packets.

	Usage:
	var l = new MessageListener( stream, function(m){
		trace("Received message: "+m);
	});</haxe_doc>
	</class>
	<class path="jabber.PacketCollector" params="" file="../../jabber/PacketCollector.hx">
		<filters public="1" set="null">
			<c path="jabber._PacketCollector.FilterList"/>
			<haxe_doc>This collectors filters</haxe_doc>
		</filters>
		<handlers public="1">
			<c path="Array"><f a="">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></c>
			<haxe_doc>Callbacks to which collected packets get delivered to.</haxe_doc>
		</handlers>
		<permanent public="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the the collector should get removed from the stream after collecting.</haxe_doc>
		</permanent>
		<block public="1">
			<x path="Bool"/>
			<haxe_doc>Block remaining collectors</haxe_doc>
		</block>
		<accept public="1" set="method" line="58">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given XMPP packet passes through all filters.</haxe_doc>
		</accept>
		<deliver public="1" set="method" line="68">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Delivers the given packet to all registerd handlers.</haxe_doc>
		</deliver>
		<new public="1" set="method" line="44"><f a="filters:handler:?permanent:?block">
	<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Default XMPP packet collector implementation.</haxe_doc>
	</class>
	<class path="jabber._PacketCollector.FilterList" params="" file="../../jabber/PacketCollector.hx" private="1" module="jabber.PacketCollector">
		<fid><c path="Array"><t path="xmpp.PacketFilter"/></c></fid>
		<f><c path="Array"><t path="xmpp.PacketFilter"/></c></f>
		<clear public="1" get="inline" set="null" line="83"><f a=""><x path="Void"/></f></clear>
		<iterator public="1" get="inline" set="null" line="88"><f a=""><t path="Iterator"><t path="xmpp.PacketFilter"/></t></f></iterator>
		<addIDFilter public="1" get="inline" set="null" line="92"><f a="_f">
	<c path="xmpp.filter.PacketIDFilter"/>
	<x path="Void"/>
</f></addIDFilter>
		<addFilter public="1" get="inline" set="null" line="96"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></addFilter>
		<push public="1" get="inline" set="null" line="100"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></push>
		<unshift public="1" get="inline" set="null" line="104"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></unshift>
		<remove public="1" get="inline" set="null" line="108"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Bool"/>
</f></remove>
		<new public="1" set="method" line="79"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="jabber.PacketInterceptor" params="" file="../../jabber/PacketInterceptor.hx">
		<a><interceptPacket set="method">
	<f a="p">
		<c path="xmpp.Packet"/>
		<c path="xmpp.Packet"/>
	</f>
	<haxe_doc>Intercepts outgoing XMPP packet before sending.</haxe_doc>
</interceptPacket></a>
		<haxe_doc>Modifies XMPP packets and/or runs additional processes before sending.</haxe_doc>
	</typedef>
	<class path="jabber.PersonalEvent" params="" file="../../jabber/PersonalEvent.hx">
		<onPublish public="1" set="dynamic" line="31"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onPublish>
		<onDisable public="1" set="dynamic" line="32"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onDisable>
		<onError public="1" set="dynamic" line="33"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<publish public="1" set="method" line="45">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Publish a personal event.</haxe_doc>
		</publish>
		<disable public="1" set="method" line="54">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disable publishing.</haxe_doc>
		</disable>
		<sendIQ set="method" line="58"><f a="e:x:h">
	<c path="xmpp.PersonalEvent"/>
	<c path="Xml"/>
	<f a="">
		<c path="xmpp.PersonalEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<new public="1" set="method" line="38"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Send personal updates or "events" to other users, who are typically contacts in the user's roster.
	
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<typedef path="jabber._PersonalEventListener.Listener" params="" file="../../jabber/PersonalEventListener.hx" private="1" module="jabber.PersonalEventListener"><a>
	<xmlns><c path="String"/></xmlns>
	<type><x path="Class"><c path="xmpp.PersonalEvent"/></x></type>
	<handler><f a=":">
	<c path="xmpp.Message"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></handler>
</a></typedef>
	<class path="jabber.PersonalEventListener" params="" file="../../jabber/PersonalEventListener.hx">
		<stream public="1" set="null">
			<c path="jabber.Stream"/>
			<haxe_doc>Optional to collect ALL events</haxe_doc>
		</stream>
		<listeners><c path="List"><t path="jabber._PersonalEventListener.Listener"/></c></listeners>
		<iterator public="1" get="inline" set="null" line="52"><f a=""><t path="Iterator"><t path="jabber._PersonalEventListener.Listener"/></t></f></iterator>
		<add public="1" set="method" line="59">
			<f a="t:h">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<f a=":">
					<c path="xmpp.Message"/>
					<c path="Xml"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add listener for the given type.</haxe_doc>
		</add>
		<remove public="1" set="method" line="76">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove listener for the given type.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clear all listeners.</haxe_doc>
		</clear>
		<getListener public="1" set="method" line="93">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<t path="jabber._PersonalEventListener.Listener"/>
			</f>
			<haxe_doc>Returns the listeners for the given type.</haxe_doc>
		</getListener>
		<handlePersonalEvent set="method" line="100"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePersonalEvent>
		<new public="1" set="method" line="44"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listener for incoming personal events from other entities.
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<class path="jabber.Pong" params="" file="../../jabber/Pong.hx">
		<onPong public="1" set="dynamic" line="31">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Informational callback on ping-pong</haxe_doc>
		</onPong>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<handlePing set="method" line="52"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<new public="1" set="method" line="37"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming ping messages and automaticly responds with a pong.
	XEP 199 - XMPP Ping: http://www.xmpp.org/extensions/xep-0199.html</haxe_doc>
	</class>
	<class path="jabber.PrivacyLists" params="" file="../../jabber/PrivacyLists.hx">
		<onLists public="1" set="dynamic" line="32"><f a="l">
	<c path="xmpp.PrivacyLists"/>
	<x path="Void"/>
</f></onLists>
		<onInfo public="1" set="dynamic" line="33"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onInfo>
		<onUpdate public="1" set="dynamic" line="34"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onUpdate>
		<onRemoved public="1" set="dynamic" line="35"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onRemoved>
		<onActivate public="1" set="dynamic" line="36"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onActivate>
		<onDeactivate public="1" set="dynamic" line="37"><f a=""><x path="Void"/></f></onDeactivate>
		<onDefaultChange public="1" set="dynamic" line="38"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onDefaultChange>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<loadLists public="1" set="method" line="53"><f a=""><x path="Void"/></f></loadLists>
		<load public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></load>
		<activate public="1" set="method" line="69"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></activate>
		<deactivate public="1" set="method" line="77"><f a=""><x path="Void"/></f></deactivate>
		<changeDefault public="1" set="method" line="84"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></changeDefault>
		<update public="1" set="method" line="101"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></update>
		<add public="1" set="method" line="105"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="109"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<_update set="method" line="118"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></_update>
		<sendRequest set="method" line="126"><f a="iqType:resultHandler:?active:?_default:?list">
	<e path="xmpp.IQType"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></sendRequest>
		<handleListPush set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleListPush>
		<new public="1" set="method" line="43"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for blocking communication with unknown or undesirable entities.
	Depricated! Use jabber.ComBlock instead.

	XEP-0016: Privacy Lists: http://xmpp.org/extensions/xep-0016.html</haxe_doc>
	</class>
	<class path="jabber.PrivateStorage" params="" file="../../jabber/PrivateStorage.hx">
		<onLoad public="1" set="dynamic" line="30"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onLoad>
		<onStored public="1" set="dynamic" line="31"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onStored>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="43">
			<f a="name:namespace">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Load private data.</haxe_doc>
		</load>
		<store public="1" set="method" line="59">
			<f a="name:namespace:data">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store private data.</haxe_doc>
		</store>
		<new public="1" set="method" line="36"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension to store any arbitrary XML on the server side.
	XEP-0049: Private XML Storage: http://xmpp.org/extensions/xep-0049.html</haxe_doc>
	</class>
	<class path="jabber.PubSub" params="" file="../../jabber/PubSub.hx">
		<onError public="1" set="dynamic" line="34"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onNodeCreate public="1" set="dynamic" line="35"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeCreate>
		<onNodeDelete public="1" set="dynamic" line="37"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeDelete>
		<onSubscriptions public="1" set="dynamic" line="38"><f a="subs">
	<c path="xmpp.pubsub.Subscriptions"/>
	<x path="Void"/>
</f></onSubscriptions>
		<onSubscribe public="1" set="dynamic" line="39"><f a="sub">
	<c path="xmpp.pubsub.Subscription"/>
	<x path="Void"/>
</f></onSubscribe>
		<onUnsubscribe public="1" set="dynamic" line="40"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onUnsubscribe>
		<onPublish public="1" set="dynamic" line="41"><f a="node:item">
	<c path="String"/>
	<c path="xmpp.pubsub.Item"/>
	<x path="Void"/>
</f></onPublish>
		<onItems public="1" set="dynamic" line="42"><f a="items">
	<c path="xmpp.pubsub.Items"/>
	<x path="Void"/>
</f></onItems>
		<onAffiliations public="1" set="dynamic" line="43"><f a="a">
	<c path="xmpp.pubsub.Affiliations"/>
	<x path="Void"/>
</f></onAffiliations>
		<onRetract public="1" set="dynamic" line="44"><f a="r">
	<c path="xmpp.pubsub.Retract"/>
	<x path="Void"/>
</f></onRetract>
		<onPurge public="1" set="dynamic" line="45"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onPurge>
		<service public="1" set="null">
			<c path="String"/>
			<haxe_doc>Name of the pubsub service</haxe_doc>
		</service>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<createNode public="1" set="method" line="59">
			<f a="name:?config">
				<c path="String"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Create a pubsub node with the given name (http://xmpp.org/extensions/xep-0060.html#owner-create).</haxe_doc>
		</createNode>
		<deleteNode public="1" set="method" line="73">
			<f a="name">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Delete pubsub node with given name (http://xmpp.org/extensions/xep-0060.html#owner-delete")</haxe_doc>
		</deleteNode>
		<loadSubscriptions public="1" set="method" line="104">
			<f a="?node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load list of current subscriptions.</haxe_doc>
		</loadSubscriptions>
		<subscribe public="1" set="method" line="123">
			<f a="node:?jid">
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc><![CDATA[Subscribe to given pubsub node.
		The 'jid' attribute specifying the exact XMPP address to be used as the subscribed JID.
		Often a bare JID (<localpart@domain.tld> or <domain.tld>)
		or full JID <localpart@domain.tld/resource>
		or <domain.tld/resource>.]]></haxe_doc>
		</subscribe>
		<unsubscribe public="1" set="method" line="141">
			<f a="node:?jid:?subid">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Unsubscribe from given pubsub node.</haxe_doc>
		</unsubscribe>
		<loadAffiliations public="1" set="method" line="170">
			<f a=""><c path="xmpp.IQ"/></f>
			<haxe_doc>Load list of affiliations for all nodes at the service.</haxe_doc>
		</loadAffiliations>
		<loadItems public="1" set="method" line="186">
			<f a="node:?subid:?maxItems:?ids">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load (all) items from the given node.</haxe_doc>
		</loadItems>
		<retract public="1" set="method" line="210">
			<f a="retract">
				<c path="xmpp.pubsub.Retract"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publisher deletes an item once it has been published to a node that supports persistent items.</haxe_doc>
		</retract>
		<purge public="1" set="method" line="226">
			<f a="node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Remove all items from the persistent store, with the exception of the last published item, which MAY be cached.
		(This is a optional feature for a pubsub service).</haxe_doc>
		</purge>
		<publish public="1" set="method" line="241">
			<f a="node:item:?options">
				<c path="String"/>
				<c path="xmpp.pubsub.Item"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publish an item to a node.</haxe_doc>
		</publish>
		<sendIQ set="method" line="264"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="xmpp.IQ"/>
</f></sendIQ>
		<new public="1" set="method" line="51"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[PubSub client extension.

	http://xmpp.org/extensions/xep-0060.html">XEP-0060: Publish-Subscribe]]></haxe_doc>
	</class>
	<class path="jabber.PubSubListener" params="" file="../../jabber/PubSubListener.hx">
		<onMessage public="1" set="dynamic" line="31">
			<f a="m">
				<c path="xmpp.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Every(!) full pubsub event message</haxe_doc>
		</onMessage>
		<onItems public="1" set="dynamic" line="36">
			<f a="service:items">
				<c path="String"/>
				<c path="xmpp.pubsub.Items"/>
				<x path="Void"/>
			</f>
			<haxe_doc>New pubsub item(s) recieved</haxe_doc>
		</onItems>
		<onConfig public="1" set="dynamic" line="38">
			<f a="service:config">
				<c path="String"/>
				<a>
					<node><c path="String"/></node>
					<form><c path="xmpp.DataForm"/></form>
				</a>
				<x path="Void"/>
			</f>
			<haxe_doc>Configuration got changed</haxe_doc>
		</onConfig>
		<onDelete public="1" set="dynamic" line="40">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got deleted</haxe_doc>
		</onDelete>
		<onPurge public="1" set="dynamic" line="42">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got purged</haxe_doc>
		</onPurge>
		<onSubscription public="1" set="dynamic" line="44">
			<f a="service:subscription">
				<c path="String"/>
				<c path="xmpp.pubsub.Subscription"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscription action notification</haxe_doc>
		</onSubscription>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="58"><f a=""><x path="Void"/></f></dispose>
		<handlePubSubEvent set="method" line="62"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePubSubEvent>
		<new public="1" set="method" line="50"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming pubsub events from a given service.
	XEP-0060: Publish-Subscribe: http://xmpp.org/extensions/xep-0060.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscovery" params="" file="../../jabber/ServiceDiscovery.hx">
		<onInfo public="1" set="dynamic" line="39"><f a="jid:info">
	<c path="String"/>
	<c path="xmpp.disco.Info"/>
	<x path="Void"/>
</f></onInfo>
		<onItems public="1" set="dynamic" line="40"><f a="jid:items">
	<c path="String"/>
	<c path="xmpp.disco.Items"/>
	<x path="Void"/>
</f></onItems>
		<onError public="1" set="dynamic" line="41"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<info public="1" set="method" line="52">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for information.</haxe_doc>
		</info>
		<items public="1" set="method" line="65">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for items.</haxe_doc>
		</items>
		<handleInfo set="method" line="75"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfo>
		<handleItems set="method" line="99"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItems>
		<new public="1" set="method" line="45"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages discovery of services from XMPP entities.
	Two kinds of information can be discovered:
		The identity and capabilities of an entity, including the protocols and features it supports.
		The items associated with an entity, such as the list of rooms hosted at a multi-user chat service.

	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscoveryListener" params="" file="../../jabber/ServiceDiscoveryListener.hx">
		<defaultIdentity public="1" line="33" static="1"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></defaultIdentity>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<onInfoQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom info request handler relay</haxe_doc>
		</onInfoQuery>
		<onItemsQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom items request handler relay</haxe_doc>
		</onItemsQuery>
		<c_info><c path="jabber.PacketCollector"/></c_info>
		<c_items><c path="jabber.PacketCollector"/></c_items>
		<dispose public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<handleInfoQuery set="method" line="68"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoQuery>
		<handleItemsQuery set="method" line="90"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItemsQuery>
		<new public="1" set="method" line="49"><f a="stream:?identities">
	<c path="jabber.Stream"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers incoming service discovery requests.
	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<typedef path="jabber.SocketConnection" params="" file="../../jabber/SocketConnection.hx"><c path="jabber.net.SocketConnection_sys"/></typedef>
	<class path="jabber.SoftwareVersion" params="" file="../../jabber/SoftwareVersion.hx">
		<onLoad public="1" set="dynamic" line="29"><f a="jid:sv">
	<c path="String"/>
	<c path="xmpp.SoftwareVersion"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="41">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests the software version of the given entity.</haxe_doc>
		</load>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="jabber.SoftwareVersionListener" params="" file="../../jabber/SoftwareVersionListener.hx">
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity (optional)</haxe_doc>
		</os>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<handleQuery set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleQuery>
		<new public="1" set="method" line="45"><f a="stream:name:version:?os">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for retrieving information about the software application associated with an XMPP entity
	XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<typedef path="jabber._Stream.Server" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream"><a><features><x path="Map">
	<c path="String"/>
	<c path="Xml"/>
</x></features></a></typedef>
	<class path="jabber._Stream.StreamFeatures" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream">
		<l><c path="Array"><c path="String"/></c></l>
		<iterator public="1" get="inline" set="null" line="47"><f a=""><t path="Iterator"><c path="String"/></t></f></iterator>
		<add public="1" set="method" line="51"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></add>
		<has public="1" get="inline" set="null" line="57"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" get="inline" set="null" line="61"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="65"><f a="f">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<toString public="1" get="inline" set="null" line="70"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="jabber.Stream" params="" file="../../jabber/Stream.hx">
		<defaultPacketIdLength public="1" line="81" static="1"><x path="Int"/></defaultPacketIdLength>
		<defaultMaxBufSize public="1" line="82" static="1"><x path="Int"/></defaultMaxBufSize>
		<onOpen public="1" set="dynamic" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the XMPP stream is opened and ready to exchange XMPP data</haxe_doc>
		</onOpen>
		<onClose public="1" set="dynamic" line="92">
			<f a="?e">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when the XMPP stream closes, optionally reporting stream errors if occured</haxe_doc>
		</onClose>
		<status public="1">
			<e path="jabber.StreamStatus"/>
			<haxe_doc>Current status of the XMPP stream</haxe_doc>
		</status>
		<cnx public="1" set="accessor">
			<c path="jabber.StreamConnection"/>
			<haxe_doc>The connection used to transport xmpp data</haxe_doc>
		</cnx>
		<features public="1" set="null">
			<c path="jabber._Stream.StreamFeatures"/>
			<haxe_doc>Clients stream features</haxe_doc>
		</features>
		<server public="1" set="null">
			<t path="jabber._Stream.Server"/>
			<haxe_doc></haxe_doc>
		</server>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>Stream-id</haxe_doc>
		</id>
		<lang public="1" set="null">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</lang>
		<jid public="1" set="accessor">
			<c path="jabber.JID"/>
			<haxe_doc>Jabber-id of this entity</haxe_doc>
		</jid>
		<dataFilters public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataFilter"/></c>
			<haxe_doc></haxe_doc>
		</dataFilters>
		<dataInterceptors public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataInterceptor"/></c>
			<haxe_doc></haxe_doc>
		</dataInterceptors>
		<bufSize public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Incoming data buffer size</haxe_doc>
		</bufSize>
		<maxBufSize public="1">
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</maxBufSize>
		<buf><c path="StringBuf"/></buf>
		<collectors_id><c path="Array"><c path="jabber.PacketCollector"/></c></collectors_id>
		<collectors><c path="Array"><c path="jabber.PacketCollector"/></c></collectors>
		<interceptors><c path="Array"><t path="jabber.PacketInterceptor"/></c></interceptors>
		<numPacketsSent><x path="Int"/></numPacketsSent>
		<set_jid set="method" line="140"><f a="j">
	<c path="jabber.JID"/>
	<c path="jabber.JID"/>
</f></set_jid>
		<set_cnx set="method" line="146"><f a="c">
	<c path="jabber.StreamConnection"/>
	<c path="jabber.StreamConnection"/>
</f></set_cnx>
		<nextID public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>Create/Returns the next unique id for this XMPP stream</haxe_doc>
		</nextID>
		<open public="1" set="method" line="185">
			<f a="jid">
				<c path="jabber.JID"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Open the XMPP stream.</haxe_doc>
		</open>
		<close public="1" set="method" line="201">
			<f a="?disconnect">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Closes the XMPP stream.<br/>
		Passed argument indicates if the data connection to the server should also get disconnected.]]></haxe_doc>
		</close>
		<sendMessage public="1" set="method" line="216">
			<f a="to:body:?subject:?type:?thread:?from">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="xmpp.MessageType"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Send a message packet (default type is 'chat').</haxe_doc>
		</sendMessage>
		<sendPresence public="1" set="method" line="223">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send a presence packet.</haxe_doc>
		</sendPresence>
		<sendPresenceTo public="1" get="inline" set="null" line="230">
			<f a="jid:?show:?status:?priority:?type">
				<c path="String"/>
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send directed presence</haxe_doc>
		</sendPresenceTo>
		<sendIQ public="1" set="method" line="239">
			<f a="iq:?handler">
				<c path="xmpp.IQ"/>
				<f a="">
					<c path="xmpp.IQ"/>
					<x path="Void"/>
				</f>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Send an IQ packet and forwards the response to the given handler function.</haxe_doc>
		</sendIQ>
		<sendIQResult public="1" get="inline" set="null" line="257">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create and send the resulting iq for given request</haxe_doc>
		</sendIQResult>
		<sendPacket public="1" params="T" set="method" line="264">
			<f a="p:?intercept">
				<c path="sendPacket.T"/>
				<x path="Bool"/>
				<c path="sendPacket.T"/>
			</f>
			<haxe_doc>Intercept/Send/Return XMPP packet.</haxe_doc>
		</sendPacket>
		<sendData public="1" set="method" line="275">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Send raw string.</haxe_doc>
		</sendData>
		<sendBytes public="1" set="method" line="296"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></sendBytes>
		<interceptPacket public="1" set="method" line="307">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Runs the XMPP packet interceptor on the given packet.</haxe_doc>
		</interceptPacket>
		<collect public="1" set="method" line="315">
			<f a="filters:handler:?permanent">
				<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Creates, adds and returns a XMPP packet collector.</haxe_doc>
		</collect>
		<addIDCollector public="1" set="method" line="324">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Adds an packet collector which filters XMPP packets by ids.
		These collectors get processed before any other.</haxe_doc>
		</addIDCollector>
		<addCollector public="1" set="method" line="333">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Adds a XMPP packet collector to this stream and starts the timeout if not null.</haxe_doc>
		</addCollector>
		<removeCollector public="1" set="method" line="342">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeCollector>
		<addInterceptor public="1" set="method" line="351">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</addInterceptor>
		<removeInterceptor public="1" set="method" line="360">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeInterceptor>
		<handleData public="1" set="method" line="366">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleData>
		<handleString public="1" set="method" line="377">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleString>
		<handleXml public="1" set="method" line="465">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="xmpp.Packet"/></c>
			</f>
			<haxe_doc>Inject incoming XML data.
		Returns array of handled XMPP packets.</haxe_doc>
		</handleXml>
		<handlePacket public="1" set="method" line="479">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Handles incoming XMPP packets.
		Returns true if the packet got handled.</haxe_doc>
		</handlePacket>
		<buffer set="method" line="543"><f a="t">
	<c path="String"/>
	<x path="Void"/>
</f></buffer>
		<resetBuffer set="method" line="548"><f a=""><x path="Void"/></f></resetBuffer>
		<processStreamInit set="method" line="571"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<handleConnect set="method" line="575"><f a=""><x path="Void"/></f></handleConnect>
		<handleDisconnect set="method" line="581"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleDisconnect>
		<handleStreamOpen set="method" line="586"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleStreamClose set="method" line="590"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleStreamClose>
		<cleanup set="method" line="596"><f a=""><x path="Void"/></f></cleanup>
		<new set="method" line="133"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for handling a XMPP data stream to and from another entity.
	
	See: http://xmpp.org/rfcs/rfc6120.html#streams</haxe_doc>
	</class>
	<class path="jabber.StreamConnection" params="" file="../../jabber/StreamConnection.hx">
		<__onConnect public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Succesfully connected callback</haxe_doc>
		</__onConnect>
		<__onDisconnect public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Disconnected callback. Parameter is an optional error message</haxe_doc>
		</__onDisconnect>
		<__onData public="1">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Bytes recieved callback</haxe_doc>
		</__onData>
		<__onString public="1">
			<f a="">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>String recieved callback</haxe_doc>
		</__onString>
		<__onSecured public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>TLS negotiation complete callback</haxe_doc>
		</__onSecured>
		<host public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>Hostname or IP address of the XMPP server.</haxe_doc>
		</host>
		<connected public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if connected and ready to read and write.</haxe_doc>
		</connected>
		<secure public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this is a secure connection (TLS negotiation complete)</haxe_doc>
		</secure>
		<secured public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if TLS is negotiation is complete and data transfered is encrypted</haxe_doc>
		</secured>
		<http public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this data connection is a HTTP (BOSH) connection (default is false)</haxe_doc>
		</http>
		<set_host set="method" line="68"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_host>
		<connect public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</connect>
		<disconnect public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</disconnect>
		<setSecure public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</setSecure>
		<read public="1" set="method" line="95">
			<f a="?yes">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Starts/Stops reading data input, returns true if successfully started</haxe_doc>
		</read>
		<write public="1" set="method" line="103">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send a string, returns true on succeess</haxe_doc>
		</write>
		<writeBytes public="1" set="method" line="111">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send raw bytes, returns true on succeess</haxe_doc>
		</writeBytes>
		<new set="method" line="61"><f a="host:secure:?http">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for XMPP stream connections.</haxe_doc>
	</class>
	<typedef path="jabber.StreamDataFilter" params="" file="../../jabber/StreamDataFilter.hx"><a><filterData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Filter raw incoming data before processing</haxe_doc>
</filterData></a></typedef>
	<typedef path="jabber.StreamDataInterceptor" params="" file="../../jabber/StreamDataInterceptor.hx"><a><interceptData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Modify raw outgoing XMPP data before sending</haxe_doc>
</interceptData></a></typedef>
	<enum path="jabber.StreamStatus" params="" file="../../jabber/StreamStatus.hx">
		<closed><haxe_doc>XMPP stream is inactive.</haxe_doc></closed>
		<pending><haxe_doc>Request to open XMPP stream sent but no response so far.</haxe_doc></pending>
		<starttls><haxe_doc>TLS negotiation in progress.</haxe_doc></starttls>
		<open><haxe_doc>XMPP stream is open and ready to exchange data.</haxe_doc></open>
	</enum>
	<class path="jabber.UserSearch" params="" file="../../jabber/UserSearch.hx">
		<onFields public="1" set="dynamic" line="29"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onFields>
		<onResult public="1" set="dynamic" line="30"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onResult>
		<onError public="1" set="dynamic" line="31"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<requestFields public="1" set="method" line="39"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></requestFields>
		<search public="1" set="method" line="46"><f a="jid:item">
	<c path="String"/>
	<t path="xmpp.UserSearchItem"/>
	<x path="Void"/>
</f></search>
		<sendIQ set="method" line="56"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a=":">
		<c path="String"/>
		<c path="xmpp.UserSearch"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<new public="1" set="method" line="35"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0055: Search: http://xmpp.org/extensions/xep-0055.html</haxe_doc>
	</class>
	<class path="jabber.XMPPDebug" params="" file="../../jabber/XMPPDebug.hx">
		<active public="1" line="80" static="1">
			<x path="Bool"/>
			<haxe_doc>Activate/Deactivate output.
		Default is true.</haxe_doc>
		</active>
		<lastPrintWasOutgoing public="1" set="null" line="83" static="1">
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</lastPrintWasOutgoing>
		<beautify public="1" line="91" static="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the XMPP debug output should get formatted/beautified.
		Mind: If active, it is not ensured that the formatted string matches exactly the sent/recieved ones!
		Default value is false.
		Currently only supported in terminal targets.</haxe_doc>
		</beautify>
		<showDate public="1" line="96" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current date in meta information</haxe_doc>
		</showDate>
		<showTime public="1" line="101" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current time in meta information</haxe_doc>
		</showTime>
		<i public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print incoming XMPP data</haxe_doc>
		</i>
		<o public="1" get="inline" set="null" line="113" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print outgoing XMPP data</haxe_doc>
		</o>
		<print public="1" set="method" line="124" static="1">
			<f a="t:out:?level">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print manually to console</haxe_doc>
		</print>
		<color_out public="1" line="142" static="1"><x path="Int"/></color_out>
		<color_inc public="1" line="143" static="1"><x path="Int"/></color_inc>
		<__print public="1" set="method" line="147" static="1">
			<f a="t:?color">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</__print>
		<haxe_doc>Utility for debugging XMPP transfer.
	Set the compiler flag: -D xmpp_debug to activate it.
	
	* Terminal targets: Color highlighted
	* Browser targets: Printed to the default debug console
	* Adobe air: Printed to fdb 'trace'</haxe_doc>
		<meta><m n=":require"><e>xmpp_debug</e></m></meta>
	</class>
	<class path="xmpp.ErrorPacket" params="" file="../../xmpp/ErrorPacket.hx">
		<parseInto set="method" line="72" static="1"><f a="p:x:xmlns">
	<c path="xmpp.ErrorPacket"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Bool"/>
</f></parseInto>
		<condition public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</condition>
		<text public="1">
			<c path="String"/>
			<haxe_doc>Describes the error in more detail</haxe_doc>
		</text>
		<lang public="1">
			<c path="String"/>
			<haxe_doc>Language of the text content XML character data</haxe_doc>
		</lang>
		<app public="1">
			<t path="xmpp.ApplicationErrorCondition"/>
			<haxe_doc>Application-specific error condition</haxe_doc>
		</app>
		<_toXml set="method" line="53"><f a="p:ns">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
</f></_toXml>
		<new set="method" line="45"><f a="condition:?text:?lang:?app">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for xmpp.Error and xmpp.StreamError</haxe_doc>
	</class>
	<class path="xmpp.Error" params="" file="../../xmpp/Error.hx">
		<extends path="xmpp.ErrorPacket"/>
		<XMLNS public="1" set="null" line="30" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Error"/>
</f></parse>
		<type public="1"><e path="xmpp.ErrorType"/></type>
		<code public="1"><t path="Null"><x path="Int"/></t></code>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="35"><f a="type:condition:?code:?text:?lang:?app">
	<e path="xmpp.ErrorType"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.XMPPError" params="" file="../../jabber/XMPPError.hx">
		<extends path="xmpp.Error"/>
		<from public="1" set="null"><c path="String"/></from>
		<toString public="1" set="method" line="37"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Used to dispatch and track XMPP protocol errors.</haxe_doc>
	</class>
	<class path="jabber.client.Account" params="" file="../../jabber/client/Account.hx">
		<onFields public="1" set="dynamic" line="32">
			<f a="fields">
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for recieved registration fields</haxe_doc>
		</onFields>
		<onRegister public="1" set="dynamic" line="35">
			<f a="node">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for account registering success</haxe_doc>
		</onRegister>
		<onRemove public="1" set="dynamic" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback for account remove success</haxe_doc>
		</onRemove>
		<onPasswordChange public="1" set="dynamic" line="41">
			<f a="pass">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for password change success</haxe_doc>
		</onPasswordChange>
		<onError public="1" set="dynamic" line="44">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<requestRegistrationFields public="1" set="method" line="55">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request required registration fields from server</haxe_doc>
		</requestRegistrationFields>
		<register public="1" set="method" line="87">
			<f a="reg">
				<c path="xmpp.Register"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Register new account.</haxe_doc>
		</register>
		<remove public="1" set="method" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Delete account from server.</haxe_doc>
		</remove>
		<changePassword public="1" set="method" line="145">
			<f a="node:pass">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change account password.</haxe_doc>
		</changePassword>
		<new public="1" set="method" line="48"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration: http://www.xmpp.org/extensions/xep-0077.html</haxe_doc>
	</class>
	<class path="jabber.client.AuthenticationBase" params="" file="../../jabber/client/AuthenticationBase.hx">
		<onSuccess public="1" set="dynamic" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Authenication was success full callback</haxe_doc>
		</onSuccess>
		<onFail public="1" set="dynamic" line="33">
			<f a="info">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Authenication failed callback</haxe_doc>
		</onFail>
		<resource public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid resource to authenticate</haxe_doc>
		</resource>
		<stream public="1" set="null">
			<c path="jabber.client.Stream"/>
			<haxe_doc></haxe_doc>
		</stream>
		<start public="1" set="method" line="48">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Start the authentication process.</haxe_doc>
		</start>
		<new set="method" line="41"><f a="s">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract client account authentication class.</haxe_doc>
	</class>
	<class path="jabber.client.Authentication" params="" file="../../jabber/client/Authentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<onNegotiated public="1" set="dynamic" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback on SASL negotiation completed</haxe_doc>
		</onNegotiated>
		<mechanisms public="1" set="null">
			<c path="Array"><t path="jabber.sasl.Mechanism"/></c>
			<haxe_doc>Clients SASL mechanisms (in prefered order)</haxe_doc>
		</mechanisms>
		<serverMechanisms public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>Available SASL mechanisms offered by server</haxe_doc>
		</serverMechanisms>
		<mechanism public="1" set="null">
			<t path="jabber.sasl.Mechanism"/>
			<haxe_doc>Used SASL method</haxe_doc>
		</mechanism>
		<onStreamOpenHandler><f a=""><x path="Void"/></f></onStreamOpenHandler>
		<c_challenge><c path="jabber.PacketCollector"/></c_challenge>
		<c_fail><c path="jabber.PacketCollector"/></c_fail>
		<c_success><c path="jabber.PacketCollector"/></c_success>
		<start public="1" set="method" line="76" override="1">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Inits SASL authentication.
		Returns false if no supported SASL mechanism got offered by the server.</haxe_doc>
		</start>
		<handleSASLFailed set="method" line="105"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLFailed>
		<handleSASLChallenge set="method" line="113"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLChallenge>
		<handleSASLSuccess set="method" line="119"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLSuccess>
		<handleStreamOpen set="method" line="130"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleBind set="method" line="141"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleBind>
		<handleSession set="method" line="165"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSession>
		<removeSASLCollectors set="method" line="176"><f a=""><x path="Void"/></f></removeSASLCollectors>
		<new public="1" set="method" line="59"><f a="stream:mechanisms">
	<c path="jabber.client.Stream"/>
	<t path="Iterable"><t path="jabber.sasl.Mechanism"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>SASL client authentication.

	Responsible for:
		* Authenticating a client account using SASL
		* Binding the resource to the connection
		* Establishing a session with the server

	RFC3920-SASL http://xmpp.org/rfcs/rfc3920.html#sasl
	RFC3920-BIND http://xmpp.org/rfcs/rfc3920.html#bind</haxe_doc>
	</class>
	<class path="jabber.client.GMailNotify" params="" file="../../jabber/client/GMailNotify.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<onMail public="1" set="dynamic" line="34"><f a="m">
	<c path="Xml"/>
	<x path="Void"/>
</f></onMail>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<request public="1" set="method" line="57">
			<f a="?newerThanTime:?newerThanTid:?q">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param newerThanTime The time of the oldest unread email to retrieve, in milliseconds
		
		@param newerThanTid The highest thread number of messages to return, where higher numbers are more recent email threads.
		The server will return only threads newer than that specified by this attribute.
		If using this attribute, you should also use newer-than-time for best results.
		When querying for the first time, you should omit this value.
		
		@param q Specifies an optional search query string.
		This string uses the same syntax as the search box in Gmail, including supported operators.
		
		The server will also subscribe the client to receive notifications when new mail is received.</haxe_doc>
		</request>
		<dispose public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops collecting/reporting mail notifications.
		This does NOT unsubscribe from getting mail notifications (currently not provided by the service).</haxe_doc>
		</dispose>
		<handleNotification set="method" line="77"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleNotification>
		<new public="1" set="method" line="40"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A custom google extension to XMPP to enable users to query their Gmail account for emails,
	and receive notifications when a new message arrives.

	https://developers.google.com/talk/jep_extensions/gmail</haxe_doc>
	</class>
	<class path="jabber.client.MUCOccupant" params="" file="../../jabber/client/MUChat.hx" module="jabber.client.MUChat">
		<nick public="1"><c path="String"/></nick>
		<jid public="1"><c path="String"/></jid>
		<presence public="1"><c path="xmpp.Presence"/></presence>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.client.MUChat" params="" file="../../jabber/client/MUChat.hx">
		<onJoin public="1" set="dynamic" line="55"><f a=""><x path="Void"/></f></onJoin>
		<onLeave public="1" set="dynamic" line="56"><f a=""><x path="Void"/></f></onLeave>
		<onUnlock public="1" set="dynamic" line="57"><f a=""><x path="Void"/></f></onUnlock>
		<onMessage public="1" set="dynamic" line="58"><f a="o:m">
	<c path="jabber.client.MUCOccupant"/>
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></onMessage>
		<onPresence public="1" set="dynamic" line="60"><f a="o">
	<c path="jabber.client.MUCOccupant"/>
	<x path="Void"/>
</f></onPresence>
		<onSubject public="1" set="dynamic" line="61"><f a="o:t">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></onSubject>
		<onKick public="1" set="dynamic" line="62"><f a="nick">
	<c path="String"/>
	<x path="Void"/>
</f></onKick>
		<onError public="1" set="dynamic" line="63"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<jid public="1" set="null"><c path="String"/></jid>
		<room public="1" set="null"><c path="String"/></room>
		<joined public="1" set="null"><x path="Bool"/></joined>
		<myjid public="1" set="null"><c path="String"/></myjid>
		<nick public="1" set="null"><c path="String"/></nick>
		<password public="1" set="null"><c path="String"/></password>
		<role public="1" set="null"><e path="xmpp.muc.Role"/></role>
		<affiliation public="1" set="null"><e path="xmpp.muc.Affiliation"/></affiliation>
		<occupants public="1" set="null"><c path="Array"><c path="jabber.client.MUCOccupant"/></c></occupants>
		<subject public="1" set="null"><c path="String"/></subject>
		<me public="1" get="accessor" set="null"><c path="jabber.client.MUCOccupant"/></me>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<presence><c path="xmpp.Presence"/></presence>
		<message><c path="xmpp.Message"/></message>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<get_me set="method" line="104"><f a=""><c path="jabber.client.MUCOccupant"/></f></get_me>
		<getOccupant public="1" set="method" line="121"><f a="nick">
	<c path="String"/>
	<c path="jabber.client.MUCOccupant"/>
</f></getOccupant>
		<join public="1" set="method" line="130">
			<f a="nick:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Sends initial presence to room.</haxe_doc>
		</join>
		<leave public="1" set="method" line="145">
			<f a="?message">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Sends unavailable presence to the room, exits room.</haxe_doc>
		</leave>
		<sendPresence public="1" set="method" line="159">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</sendPresence>
		<speak public="1" set="method" line="169">
			<f a="t:?properties">
				<c path="String"/>
				<c path="Array"><c path="Xml"/></c>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Sends message to all room occupants.</haxe_doc>
		</speak>
		<changeSubject public="1" set="method" line="179">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeSubject>
		<changeNick public="1" set="method" line="190">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeNick>
		<kick public="1" set="method" line="201">
			<f a="nick:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</kick>
		<invite public="1" set="method" line="231">
			<f a="jid:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends an (mediated) invitation message to the given entity .</haxe_doc>
		</invite>
		<handleMessage set="method" line="251"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handleMessage>
		<handlePresence set="method" line="275"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<sendMyPresence set="method" line="436"><f a="?priority">
	<x path="Int"/>
	<c path="xmpp.Presence"/>
</f></sendMyPresence>
		<getOccupantName get="inline" set="null" line="449"><f a="j">
	<c path="String"/>
	<c path="String"/>
</f></getOccupantName>
		<destroy set="method" line="453"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="84"><f a="stream:host:roomName">
	<c path="jabber.client.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Multiuser chatroom.

	http://www.xmpp.org/extensions/xep-0045.html
	http://www.xmpp.org/extensions/xep-0249.html</haxe_doc>
	</class>
	<class path="jabber.client.NonSASLAuthentication" params="" file="../../jabber/client/NonSASLAuthentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<active public="1" set="null"><x path="Bool"/></active>
		<usePlainText public="1" set="null"><x path="Bool"/></usePlainText>
		<username public="1" set="null"><c path="String"/></username>
		<password public="1" set="null"><c path="String"/></password>
		<start public="1" set="method" line="48" override="1"><f a="password:?resource">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></start>
		<handleResponse set="method" line="64"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResponse>
		<handleResult set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResult>
		<new public="1" set="method" line="37"><f a="stream:?usePlainText">
	<c path="jabber.client.Stream"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Obsolete, superseded in favor of SASL authentication (jabber.client.Authentication)!
	<a href="http://xmpp.org/extensions/xep-0078.html">XEP-0078: Non-SASL Authentication</a>]]></haxe_doc>
	</class>
	<enum path="jabber.client.RosterSubscriptionMode" params="" file="../../jabber/client/RosterSubscriptionMode.hx">
		<rejectAll><haxe_doc>Reject all subscription requests.</haxe_doc></rejectAll>
		<manual><haxe_doc>Ask how to proceed.</haxe_doc></manual>
		<acceptAll a="subscribe">
			<x path="Bool"/>
			<haxe_doc>Accept all subscription and unsubscription requests.</haxe_doc>
		</acceptAll>
		<haxe_doc>Configuration how to handle recieved presence subscriptions</haxe_doc>
	</enum>
	<class path="jabber.client.Roster" params="" file="../../jabber/client/Roster.hx">
		<defaultSubscriptionMode public="1" line="39" static="1"><e path="jabber.client.RosterSubscriptionMode"/></defaultSubscriptionMode>
		<onLoad public="1" set="dynamic" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Roster got loaded</haxe_doc>
		</onLoad>
		<onAdd public="1" set="dynamic" line="45">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got added to the roster</haxe_doc>
		</onAdd>
		<onRemove public="1" set="dynamic" line="48">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got removed from your roster</haxe_doc>
		</onRemove>
		<onUpdate public="1" set="dynamic" line="51">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got updated</haxe_doc>
		</onUpdate>
		<onSubscribed public="1" set="dynamic" line="54">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscribed to the presence of the contact</haxe_doc>
		</onSubscribed>
		<onUnsubscribed public="1" set="dynamic" line="57">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Unsubscribed presence of the contact</haxe_doc>
		</onUnsubscribed>
		<onAsk public="1" set="dynamic" line="60">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Incoming presence subscription request</haxe_doc>
		</onAsk>
		<onSubscription public="1" set="dynamic" line="63">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact subscribed to your presence</haxe_doc>
		</onSubscription>
		<onUnsubscription public="1" set="dynamic" line="66">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact unsubscribed from your presence</haxe_doc>
		</onUnsubscription>
		<onError public="1" set="dynamic" line="69">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc>A roster manipulation error occured</haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<subscriptionMode public="1"><e path="jabber.client.RosterSubscriptionMode"/></subscriptionMode>
		<available public="1" set="null"><x path="Bool"/></available>
		<items public="1" set="null"><c path="Array"><c path="xmpp.roster.Item"/></c></items>
		<groups public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></groups>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<get_groups set="method" line="91"><f a=""><c path="Array"><c path="String"/></c></f></get_groups>
		<dispose public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<getItem public="1" set="method" line="119">
			<f a="jid">
				<c path="String"/>
				<c path="xmpp.roster.Item"/>
			</f>
			<haxe_doc></haxe_doc>
		</getItem>
		<hasItem public="1" get="inline" set="null" line="126">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</hasItem>
		<load public="1" set="method" line="132">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</load>
		<addItem public="1" set="method" line="146">
			<f a="jid:?groups">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add entry to your roster</haxe_doc>
		</addItem>
		<removeItem public="1" set="method" line="156">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove entry from remote roster</haxe_doc>
		</removeItem>
		<subscribe public="1" set="method" line="180">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Subscribe to the presence of the entity.
		You will get presence updates from this entity (if confirmed).</haxe_doc>
		</subscribe>
		<unsubscribe public="1" set="method" line="207">
			<f a="jid:?cancelSubscription">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Unsubscribe from entities presence.
		The entity will no longer recieve presence updates.</haxe_doc>
		</unsubscribe>
		<cancelSubscription public="1" set="method" line="223">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Cancel the subscription from entity.
		You will no longer recieve presence updates.</haxe_doc>
		</cancelSubscription>
		<confirmSubscription public="1" set="method" line="231">
			<f a="jid:?allow:?subscribe">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the requesting entity to recieve presence updates from you.</haxe_doc>
		</confirmSubscription>
		<sendPresence set="method" line="241"><f a="jid:type">
	<c path="String"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></sendPresence>
		<sendAddItemRequest set="method" line="247"><f a="jid:?groups">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></sendAddItemRequest>
		<handleIQ set="method" line="270"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<handlePresence set="method" line="316"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<new public="1" set="method" line="80"><f a="stream:?subscriptionMode">
	<c path="jabber.client.Stream"/>
	<e path="jabber.client.RosterSubscriptionMode"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client roster (serverside saved contact list)</haxe_doc>
	</class>
	<class path="jabber.client.Stream" params="" file="../../jabber/client/Stream.hx">
		<extends path="jabber.Stream"/>
		<PORT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></PORT>
		<PORT_SECURE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></PORT_SECURE>
		<defaultPort public="1" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for socket connections</haxe_doc>
		</defaultPort>
		<defaultPortSecure public="1" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for secure socket connections</haxe_doc>
		</defaultPortSecure>
		<version><x path="Bool"/></version>
		<handleConnect set="method" line="56" override="1"><f a=""><x path="Void"/></f></handleConnect>
		<processStreamInit set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<parseServerStreamFeatures set="method" line="136"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></parseServerStreamFeatures>
		<new public="1" set="method" line="48"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client-Server XMPP stream.

	See: http://xmpp.org/rfcs/rfc6120.html#examples-c2s</haxe_doc>
	</class>
	<class path="jabber.client.VCardBase" params="T" file="../../jabber/client/VCardBase.hx">
		<onLoad public="1" set="dynamic" line="33">
			<f a="jid:data">
				<c path="String"/>
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>VCard loaded callback</haxe_doc>
		</onLoad>
		<onUpdate public="1" set="dynamic" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Own vcard updated callback</haxe_doc>
		</onUpdate>
		<onError public="1" set="dynamic" line="37">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<load public="1" set="method" line="48">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or own no jid is given.</haxe_doc>
		</load>
		<update public="1" set="method" line="55">
			<f a="vc">
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Update own vcard.</haxe_doc>
		</update>
		<_load set="method" line="61"><f a="x:jid">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></_load>
		<handleLoad set="method" line="67"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<_handleLoad set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<handleUpdate set="method" line="84"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleUpdate>
		<new set="method" line="41"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for vcard classes (jabber.client.VCard and jabber.client.VCardTemp)</haxe_doc>
	</class>
	<class path="jabber.client.VCardTemp" params="" file="../../jabber/client/VCardTemp.hx">
		<extends path="jabber.client.VCardBase"><c path="xmpp.VCardTemp"/></extends>
		<load public="1" set="method" line="38" override="1">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or from its own if jid is null.</haxe_doc>
		</load>
		<_handleLoad set="method" line="42" override="1"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<new public="1" set="method" line="31"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html

	Depricated but still widely implementd by servers (use jabber.client.VCard)</haxe_doc>
	</class>
	<class path="jabber.lop.Farm" params="" file="../../jabber/lop/Farm.hx">
		<createFormField set="method" line="199" static="1"><f a="name:value:type">
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.dataform.FieldType"/>
	<c path="xmpp.dataform.Field"/>
</f></createFormField>
		<createFormFieldMulti set="method" line="206" static="1"><f a="name:values">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<c path="xmpp.dataform.Field"/>
</f></createFormFieldMulti>
		<onJob public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<c path="String"/>
</f></onJob>
		<onVMKill public="1" set="dynamic" line="39"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></onVMKill>
		<onPing public="1" set="dynamic" line="40"><f a="ping">
	<c path="xmpp.lop.Ping"/>
	<c path="String"/>
</f></onPing>
		<onSetBindings public="1" set="dynamic" line="41"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onSetBindings>
		<onGetBindings public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<c path="xmpp.lop.Bindings"/>
</f></onGetBindings>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<species public="1" set="null"><x path="Map">
	<c path="String"/>
	<f a=":">
		<c path="jabber.JID"/>
		<c path="xmpp.lop.SpawnVM"/>
		<c path="String"/>
	</f>
</x></species>
		<password public="1" set="null"><c path="String"/></password>
		<ip public="1"><c path="String"/></ip>
		<vm_species public="1"><c path="String"/></vm_species>
		<vm_time_to_live public="1"><x path="Float"/></vm_time_to_live>
		<job_timeout public="1"><x path="Float"/></job_timeout>
		<job_queue_capacity public="1"><t path="Null"><x path="Int"/></t></job_queue_capacity>
		<max_concurrent_vms public="1"><t path="Null"><x path="Int"/></t></max_concurrent_vms>
		<farm_start_time public="1"><c path="String"/></farm_start_time>
		<read_file public="1"><c path="Array"><c path="String"/></c></read_file>
		<write_file public="1"><c path="Array"><c path="String"/></c></write_file>
		<delete_file public="1"><c path="Array"><c path="String"/></c></delete_file>
		<open_connection public="1"><t path="Null"><x path="Bool"/></t></open_connection>
		<listen_for_connection public="1"><t path="Null"><x path="Bool"/></t></listen_for_connection>
		<accept_connection public="1"><t path="Null"><x path="Bool"/></t></accept_connection>
		<perform_multicast public="1"><t path="Null"><x path="Bool"/></t></perform_multicast>
		<handleIQ public="1" set="method" line="87">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleIQ>
		<getDataForm public="1" set="method" line="179">
			<f a=""><c path="xmpp.DataForm"/></f>
			<haxe_doc>Generate a dataform of this farms settings.</haxe_doc>
		</getDataForm>
		<new public="1" set="method" line="63"><f a="stream:?password:?vm_species:?vm_time_to_live:?job_timeout">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages the spawning of virtual machines.
	The disco 'identity' of a farm MUST be of category="client" and type="bot" (name is up to the implementation).
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html</haxe_doc>
	</class>
	<class path="jabber.lop.Villein" params="" file="../../jabber/lop/Villein.hx">
		<onSpawn public="1" set="dynamic" line="37"><f a="s">
	<c path="xmpp.lop.SpawnVM"/>
	<x path="Void"/>
</f></onSpawn>
		<onResult public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<x path="Void"/>
</f></onResult>
		<onFail public="1" set="dynamic" line="39"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onFail>
		<onTerminate public="1" set="dynamic" line="40"><f a="vm">
	<c path="String"/>
	<x path="Void"/>
</f></onTerminate>
		<onTerminateFail public="1" set="dynamic" line="41"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onTerminateFail>
		<onBind public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onBind>
		<onBindFail public="1" set="dynamic" line="43"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onBindFail>
		<onVariables public="1" set="dynamic" line="44"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onVariables>
		<onVariablesFail public="1" set="dynamic" line="45"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onVariablesFail>
		<farm public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid of the farm</haxe_doc>
		</farm>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<spawnVM public="1" set="method" line="58">
			<f a="species:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</spawnVM>
		<submitJob public="1" set="method" line="66">
			<f a="id:job">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</submitJob>
		<pingJob public="1" set="method" line="75">
			<f a="vm_id:job_id">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</pingJob>
		<abortJob public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</abortJob>
		<getBindings public="1" set="method" line="91">
			<f a="id:names">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</getBindings>
		<setBindings public="1" set="method" line="102">
			<f a="id:list">
				<c path="String"/>
				<t path="Iterable"><t path="xmpp.lop.Binding"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</setBindings>
		<terminateVM public="1" set="method" line="115">
			<f a="vm_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</terminateVM>
		<handleVMSpawn set="method" line="121"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleVMSpawn>
		<handleJob set="method" line="131"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleJob>
		<handlePing set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<handleTerminate set="method" line="155"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleTerminate>
		<handleGetBindings set="method" line="167"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleGetBindings>
		<handleSetBindings set="method" line="179"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSetBindings>
		<new public="1" set="method" line="51"><f a="stream:farm">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Communicates with a resource provider's farm in order to spawn and compute with virtual machines that leverage provided resources.<br/>
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html]]></haxe_doc>
	</class>
	<typedef path="jabber.net._SocketConnectionBase_sys.AbstractSocket" params="" file="../../jabber/net/SocketConnectionBase_sys.hx" private="1" module="jabber.net.SocketConnectionBase_sys"><a>
	<write set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
	<shutdown set="method"><f a="read:write">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></shutdown>
	<setTimeout set="method"><f a="t">
	<x path="Float"/>
	<x path="Void"/>
</f></setTimeout>
	<output set="null"><c path="haxe.io.Output"/></output>
	<input set="null"><c path="haxe.io.Input"/></input>
	<connect set="method"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
	<close set="method"><f a=""><x path="Void"/></f></close>
</a></typedef>
	<class path="jabber.net.SocketConnectionBase_sys" params="" file="../../jabber/net/SocketConnectionBase_sys.hx">
		<extends path="jabber.StreamConnection"/>
		<defaultBufSize public="1" line="42" static="1"><x path="Int"/></defaultBufSize>
		<defaultMaxBufSize public="1" line="43" static="1"><x path="Int"/></defaultMaxBufSize>
		<defaultTimeout public="1" line="44" static="1"><x path="Int"/></defaultTimeout>
		<port public="1" set="null"><x path="Int"/></port>
		<maxbufsize public="1" set="null"><x path="Int"/></maxbufsize>
		<timeout public="1" set="null"><x path="Int"/></timeout>
		<socket public="1" set="null"><t path="jabber.net._SocketConnectionBase_sys.AbstractSocket"/></socket>
		<reading public="1" set="null"><x path="Bool"/></reading>
		<buf><c path="haxe.io.Bytes"/></buf>
		<bufpos><x path="Int"/></bufpos>
		<bufsize><x path="Int"/></bufsize>
		<disconnect public="1" set="method" line="69" override="1"><f a=""><x path="Void"/></f></disconnect>
		<read public="1" set="method" line="79" override="1"><f a="?yes">
	<x path="Bool"/>
	<x path="Bool"/>
</f></read>
		<readData set="method" line="91"><f a=""><x path="Void"/></f></readData>
		<error set="method" line="116"><f a="info">
	<c path="String"/>
	<x path="Void"/>
</f></error>
		<new set="method" line="56"><f a="host:port:secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.net.SocketConnection_sys" params="" file="../../jabber/net/SocketConnection_sys.hx">
		<extends path="jabber.net.SocketConnectionBase_sys"/>
		<connect public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></connect>
		<setSecure public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></setSecure>
		<write public="1" set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></write>
		<writeBytes public="1" set="method" line="86" override="1"><f a="t">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></writeBytes>
		<new public="1" set="method" line="30"><f a="?host:?port:?secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.remoting.Connection" params="" file="../../jabber/remoting/Connection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" get="inline" set="null" line="103" static="1"><f a="stream:target">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="jabber.remoting.Connection"/>
</f></create>
		<target public="1">
			<c path="String"/>
			<haxe_doc>Jid of opposite</haxe_doc>
		</target>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<__error><f a="">
	<d/>
	<x path="Void"/>
</f></__error>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="49"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" get="inline" set="null" line="62"><f a="h">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method" line="66"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<new set="method" line="42"><f a="stream:target:path:error">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>Haxe remoting connection to another XMPP entity.
	User ServiceDiscovery to determine if an entity supports haxe-remoting (hxr).

	http://haxe.org/doc/remoting</haxe_doc>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="jabber.remoting.Host" params="" file="../../jabber/remoting/Host.hx">
		<numActive public="1" set="null" static="1"><x path="Int"/></numActive>
		<processRequest public="1" set="method" line="75" static="1"><f a="data:ctx">
	<c path="String"/>
	<c path="haxe.remoting.Context"/>
	<c path="String"/>
</f></processRequest>
		<client public="1" set="null">
			<c path="String"/>
			<haxe_doc>JID of current/last processed entity</haxe_doc>
		</client>
		<ctx public="1"><c path="haxe.remoting.Context"/></ctx>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<close public="1" set="method" line="53"><f a=""><x path="Void"/></f></close>
		<handleIQ set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<new public="1" set="method" line="45"><f a="stream:ctx">
	<c path="jabber.Stream"/>
	<c path="haxe.remoting.Context"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[HaXe remoting host.<br/>
	<a href="http://haxe.org/doc/remoting">http://haxe.org/doc/remoting</a>]]></haxe_doc>
	</class>
	<class path="jabber.sasl.LOGINMechanism" params="" file="../../jabber/sasl/LOGINMechanism.hx">
		<NAME public="1" get="inline" set="null" line="35" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<password><c path="String"/></password>
		<username><c path="String"/></username>
		<nChallenges><x path="Int"/></nChallenges>
		<createAuthenticationText public="1" set="method" line="48">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" set="method" line="56">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" get="inline" set="null" line="43"><f a=""><x path="Void"/></f></new>
		<haxe_doc>LOGIN SASL Mechanism.
	
	Obsolete clear-text user/password Simple Authentication and Security Layer (SASL) mechanism called the LOGIN mechanism.
	The LOGIN mechanism was intended to be used, in combination with data confidentiality services provided by a lower layer,
	in protocols which lack a simple password authentication command.

	http://tools.ietf.org/id/draft-murchison-sasl-login-00.txt</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Calculator" params="" file="../../jabber/sasl/MD5Calculator.hx">
		<parseChallenge public="1" set="method" line="35" static="1">
			<f a="challenge">
				<c path="String"/>
				<a>
					<realm><c path="String"/></realm>
					<nonce><c path="String"/></nonce>
				</a>
			</f>
			<haxe_doc>* Parses the initial challenge and returns calculated realm and nonce</haxe_doc>
		</parseChallenge>
		<run public="1" set="method" line="56" static="1">
			<f a="host:serverType:username:realm:pass:nonce">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Caluclate/Create the MD5 challenge response</haxe_doc>
		</run>
		<h get="inline" set="null" line="89" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></h>
		<hh get="inline" set="null" line="90" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></hh>
		<quote get="inline" set="null" line="91" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<unquote get="inline" set="null" line="92" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></unquote>
		<haxe_doc>Static methods for computing SASL-MD5 credentials.</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Mechanism" params="" file="../../jabber/sasl/MD5Mechanism.hx">
		<NAME public="1" get="inline" set="null" line="30" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<serverType public="1"><c path="String"/></serverType>
		<username><c path="String"/></username>
		<host><c path="String"/></host>
		<pass><c path="String"/></pass>
		<resource><c path="String"/></resource>
		<createAuthenticationText public="1" set="method" line="46">
			<f a="username:host:pass:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" set="method" line="55">
			<f a="challenge">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" set="method" line="40"><f a="?serverType">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Using Digest Authentication as a SASL Mechanism: ftp://ietf.org//rfc/rfc2831.txt
	SASL and DIGEST-MD5 for XMPP: http://web.archive.org/web/20050224191820/http://cataclysm.cx/wip/digest-md5-crash.html</haxe_doc>
	</class>
	<typedef path="jabber.sasl.Mechanism" params="" file="../../jabber/sasl/Mechanism.hx">
		<a>
			<id set="null">
				<c path="String"/>
				<haxe_doc>The id of this mechanism, for example PLAIN, DIGEST-MD5, ...</haxe_doc>
			</id>
			<createChallengeResponse set="method">
				<f a="challenge">
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createChallengeResponse>
			<createAuthenticationText set="method">
				<f a="user:host:password:resource">
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createAuthenticationText>
		</a>
		<haxe_doc>SASL mechanism type.</haxe_doc>
	</typedef>
	<class path="jabber.sasl.PlainMechanism" params="" file="../../jabber/sasl/PlainMechanism.hx">
		<NAME public="1" get="inline" set="null" line="32" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<createAuthenticationText public="1" get="inline" set="null" line="41">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" get="inline" set="null" line="51">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The PLAIN mechanism should not be used without adequate data security protection
	as this mechanism affords no integrity or confidentiality protections itself.
	
	The PLAIN Simple Authentication and Security Layer (SASL) Mechanism: http://www.ietf.org/rfc/rfc4616.txt</haxe_doc>
	</class>
	<class path="jabber.util.Base64" params="" file="../../jabber/util/Base64.hx">
		<CHARS public="1" line="39" static="1"><c path="String"/></CHARS>
		<encode public="1" set="method" line="45" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<decode public="1" set="method" line="74" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</decode>
		<encodeBytes public="1" set="method" line="101" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</encodeBytes>
		<decodeBytes public="1" set="method" line="120" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</decodeBytes>
		<random public="1" set="method" line="138" static="1">
			<f a="?len:?chars">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Create a random (base64 compatible) string of given length.</haxe_doc>
		</random>
		<haxe_doc>Base64 encoding/decoding utility.</haxe_doc>
	</class>
	<class path="jabber.util.DateUtil" params="" file="../../jabber/util/DateUtil.hx"><formatTimePartValue public="1" set="method" line="30" static="1"><f a="v">
	<x path="Int"/>
	<c path="String"/>
</f></formatTimePartValue></class>
	<class path="jabber.util.MD5" params="" file="../../jabber/util/MD5.hx">
		<encode public="1" get="inline" set="null" line="36" static="1">
			<f a="s:?raw">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<inst line="74" static="1"><c path="jabber.util.MD5"/></inst>
		<rhex set="method" line="78"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></rhex>
		<bitOR set="method" line="88"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="94"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="100"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="106"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<str2blks set="method" line="112"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<rol set="method" line="131"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="135"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="139"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="143"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="147"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="151"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<str2bin set="method" line="155"><f a="inp">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2bin>
		<bin2str set="method" line="167"><f a="inp">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></bin2str>
		<doEncodeRaw set="method" line="177"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncodeRaw>
		<doEncode set="method" line="185"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncode>
		<__encode set="method" line="190"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></__encode>
		<new set="method" line="76"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.
	Modified version from the haxe std lib to provide raw encoding as well as support for non official compiler targets.</haxe_doc>
	</class>
	<class path="jabber.util.SHA1" params="" file="../../jabber/util/SHA1.hx"><encode public="1" get="inline" set="null" line="38" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode></class>
	<class path="jabber.util.SystemUtil" params="" file="../../jabber/util/SystemUtil.hx"><systemName public="1" get="inline" set="null" line="31" static="1">
	<f a=""><c path="String"/></f>
	<haxe_doc>Returns the name of the operating system used (crossplatform).</haxe_doc>
</systemName></class>
	<class path="jabber.util.XMLBeautify" params="" file="../../jabber/util/XMLBeautify.hx">
		<it public="1" set="method" line="35" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format given string to something readable.
		Only for debugging, do NOT use in production.</haxe_doc>
		</it>
		<createNode set="method" line="43" static="1"><f a="x:b:depth">
	<c path="Xml"/>
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createNode>
		<indent get="inline" set="null" line="77" static="1"><f a="b:n">
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></indent>
		<haxe_doc>Utility to 'beautify' XML strings (for debugging).</haxe_doc>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/lib/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
	</enum>
	<class path="sys.io.Process" params="" file="/usr/lib/haxe/std/cs/_std/sys/io/Process.hx">
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<native><c path="sys.io._Process.NativeProcess"/></native>
		<getPid public="1" set="method" line="59"><f a=""><x path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="64"><f a=""><x path="Int"/></f></exitCode>
		<close public="1" set="method" line="70"><f a=""><x path="Void"/></f></close>
		<kill public="1" set="method" line="75"><f a=""><x path="Void"/></f></kill>
		<new public="1" set="method" line="37"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io._Process.NativeProcess" params="" file="/usr/lib/haxe/std/cs/_std/sys/io/Process.hx" private="1" module="sys.io.Process" extern="1">
		<ExitCode public="1" set="null"><x path="Int"/></ExitCode>
		<Id public="1" set="null"><x path="Int"/></Id>
		<StartInfo public="1" set="null"><c path="sys.io._Process.NativeStartInfo"/></StartInfo>
		<StandardError public="1" set="null"><c path="cs.system.io.StreamReader"/></StandardError>
		<StandardInput public="1" set="null"><c path="cs.system.io.StreamWriter"/></StandardInput>
		<StandardOutput public="1" set="null"><c path="cs.system.io.StreamReader"/></StandardOutput>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<Kill public="1" set="method"><f a=""><x path="Void"/></f></Kill>
		<Start public="1" set="method"><f a=""><x path="Void"/></f></Start>
		<WaitForExit public="1" set="method"><f a=""><x path="Void"/></f></WaitForExit>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"System.Diagnostics.Process"</e></m></meta>
	</class>
	<class path="sys.io._Process.NativeStartInfo" params="" file="/usr/lib/haxe/std/cs/_std/sys/io/Process.hx" private="1" module="sys.io.Process" extern="1">
		<Arguments public="1"><c path="String"/></Arguments>
		<FileName public="1"><c path="String"/></FileName>
		<RedirectStandardError public="1"><x path="Bool"/></RedirectStandardError>
		<RedirectStandardInput public="1"><x path="Bool"/></RedirectStandardInput>
		<RedirectStandardOutput public="1"><x path="Bool"/></RedirectStandardOutput>
		<UseShellExecute public="1"><x path="Bool"/></UseShellExecute>
		<new public="1" set="method"><f a="filename:args">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"System.Diagnostics.ProcessStartInfo"</e></m></meta>
	</class>
	<class path="sys.net.Host" params="" file="/usr/lib/haxe/std/sys/net/Host.hx" extern="1">
		<localhost public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the local computer host name</haxe_doc>
		</localhost>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<reverse public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Perform a reverse-DNS query to resolve a host name from an IP.</haxe_doc>
		</reverse>
		<new public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/lib/haxe/std/sys/net/Socket.hx" extern="1">
		<select public="1" set="method" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		[read] contains sockets on which we want to wait for available data to be read,
		[write] contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		[others] contains sockets on which we want to wait for exceptional conditions.
		[select] will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a [timeout] (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use [setBlocking(false)] or [setTimeout] to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use [setBlocking(false)] or [setTimeout] to prevent that.</haxe_doc>
		</output>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retreive your custom infos after a [select].
	*</haxe_doc>
		</custom>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<read public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.</haxe_doc>
		</read>
		<write public="1" set="method">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.</haxe_doc>
		</write>
		<connect public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't sucessfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use [accept()] to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<peer public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about the other side of a connected socket.</haxe_doc>
		</peer>
		<host public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about our side of a connected socket.</haxe_doc>
		</host>
		<setTimeout public="1" set="method">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<waitForRead public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setBlocking public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediatly by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediatly send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
	</class>
	<class path="xmpp.Attention" params="" file="../../xmpp/Attention.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<createXml public="1" get="inline" set="null" line="28" static="1"><f a=""><c path="Xml"/></f></createXml>
	</class>
	<class path="xmpp.Auth" params="" file="../../xmpp/Auth.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Auth"/>
</f></parse>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<digest public="1"><c path="String"/></digest>
		<resource public="1"><c path="String"/></resource>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?username:?password:?digest:?resource">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ extension used for inband account authentication.</haxe_doc>
	</class>
	<class path="xmpp.Bind" params="" file="../../xmpp/Bind.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Bind"/>
</f></parse>
		<resource public="1"><c path="String"/></resource>
		<jid public="1"><c path="String"/></jid>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="37"><f a="?resource:?jid">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[IQ extension used to bind a resource to a stream.
	http://xmpp.org/rfcs/rfc3920.html#bind">RFC3920#bind]]></haxe_doc>
	</class>
	<class path="xmpp.Packet" params="" file="../../xmpp/Packet.hx">
		<PROTOCOL public="1" set="null" line="29" static="1"><c path="String"/></PROTOCOL>
		<parse public="1" set="method" line="82" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses given XML into a XMPP packet object.</haxe_doc>
		</parse>
		<parseAttributes set="method" line="94" static="1">
			<f a="p:x">
				<c path="xmpp.Packet"/>
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses/adds basic attributes to the XMPP packet.</haxe_doc>
		</parseAttributes>
		<_type public="1" set="null">
			<e path="xmpp.PacketType"/>
			<haxe_doc>The top level type of the XMPP packet</haxe_doc>
		</_type>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<id public="1"><c path="String"/></id>
		<lang public="1"><c path="String"/></lang>
		<properties public="1"><c path="Array"><c path="Xml"/></c></properties>
		<errors public="1"><c path="Array"><c path="xmpp.Error"/></c></errors>
		<toXml public="1" set="method" line="52">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates/Returns the XML representation of this XMPP packet.</haxe_doc>
		</toXml>
		<toString public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Creates/Returns the string representation of this XMPP packet.</haxe_doc>
		</toString>
		<addAttributes set="method" line="66">
			<f a="x">
				<c path="Xml"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Adds the basic packet attributes to the given XML.</haxe_doc>
		</addAttributes>
		<new set="method" line="40"><f a="?to:?from:?id:?lang">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.Caps" params="" file="../../xmpp/Caps.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc></haxe_doc>
		</parse>
		<has public="1" set="method" line="83" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given xmpp packet has a caps property</haxe_doc>
		</has>
		<fromPresence public="1" set="method" line="101" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc>Extracts the caps information from given presence packet</haxe_doc>
		</fromPresence>
		<createVerfificationString public="1" set="method" line="111" static="1">
			<f a="identities:features:?dataform">
				<t path="Iterable"><t path="xmpp.disco.Identity"/></t>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<c path="String"/>
			</f>
			<haxe_doc>http://xmpp.org/extensions/xep-0115.html#ver</haxe_doc>
		</createVerfificationString>
		<sortIdentities set="method" line="149" static="1"><f a="a:b">
	<t path="xmpp.disco.Identity"/>
	<t path="xmpp.disco.Identity"/>
	<x path="Int"/>
</f></sortIdentities>
		<sortDataFormFields set="method" line="162" static="1"><f a="a:b">
	<c path="xmpp.dataform.Field"/>
	<c path="xmpp.dataform.Field"/>
	<x path="Int"/>
</f></sortDataFormFields>
		<sortString set="method" line="166" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></sortString>
		<hash public="1">
			<c path="String"/>
			<haxe_doc>The hashing algorithm used to generate the verification string, fe: sha-1.</haxe_doc>
		</hash>
		<node public="1">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application, typically a URL at the website
		of the project or company that produces the software</haxe_doc>
		</node>
		<ver public="1">
			<c path="String"/>
			<haxe_doc>A string that is used to verify the identity and supported features of the entity</haxe_doc>
		</ver>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>A set of nametokens specifying additional feature bundles.
		This attribute is deprecated!</haxe_doc>
		</ext>
		<toXml public="1" set="method" line="64"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="57"><f a="hash:node:ver:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="xmpp.DataForm" params="" file="../../xmpp/DataForm.hx">
		<XMLNS public="1" set="null" line="34" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.DataForm"/>
</f></parse>
		<type public="1"><e path="xmpp.dataform.FormType"/></type>
		<title public="1"><c path="String"/></title>
		<instructions public="1"><c path="String"/></instructions>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<reported public="1"><c path="xmpp.dataform.Reported"/></reported>
		<items public="1"><c path="Array"><c path="xmpp.dataform.Item"/></c></items>
		<toXml public="1" set="method" line="49"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="43"><f a="?type">
	<e path="xmpp.dataform.FormType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>DataForm packet extension (for iq and message packets).

	XEP-0004: Data Forms: http://xmpp.org/extensions/xep-0004.html</haxe_doc>
	</class>
	<class path="xmpp.DateTime" params="" file="../../xmpp/DateTime.hx">
		<EREG_DATE public="1" line="35" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC date expression.
		CCYY-MM-DDThh:mm:ss[.sss]TZD</haxe_doc>
		</EREG_DATE>
		<EREG_TIME public="1" line="41" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC time expression.
		hh:mm:ss[.sss][TZD]</haxe_doc>
		</EREG_TIME>
		<isValidDate public="1" get="inline" set="null" line="43" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidDate>
		<isValidTime public="1" get="inline" set="null" line="47" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidTime>
		<now public="1" get="inline" set="null" line="54" static="1">
			<f a="?offset">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the current time as UTC formatted string</haxe_doc>
		</now>
		<fromDate public="1" get="inline" set="null" line="61" static="1">
			<f a="d:?offset">
				<c path="Date"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromDate>
		<fromTime public="1" get="inline" set="null" line="68" static="1">
			<f a="t:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromTime>
		<toDate public="1" set="method" line="79" static="1">
			<f a="utc:?tzo">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc><![CDATA[Create a Date object from a UTC time string

		//TODO this offset thing will fail!
		// TODO 24+ -> 0
		//untested!]]></haxe_doc>
		</toDate>
		<utc public="1" set="method" line="105" static="1">
			<f a="t:?offset">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Formats a (regular) date string to a XMPP compatible UTC date string (CCYY-MM-DDThh:mm:ss[.sss]TZD)
		For example: 2008-11-01 18:45:47 gets 2008-11-01T18:45:47Z
		Optionally a timezone offset could be attached.</haxe_doc>
		</utc>
		<getParts public="1" set="method" line="152" static="1">
			<f a="utc">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Return the parts of a UTC time string
		//TODO include tzo</haxe_doc>
		</getParts>
		<getTZOValue public="1" set="method" line="170" static="1">
			<f a="tzo">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the given TZO as integer value</haxe_doc>
		</getTZOValue>
		<getTimeValue public="1" set="method" line="177" static="1"><f a="t">
	<c path="String"/>
	<x path="Int"/>
</f></getTimeValue>
		<haxe_doc>Standardization of ISO 8601 profiles and their lexical representation.

	XMPP Date and Time Profiles: http://xmpp.org/extensions/xep-0082.html</haxe_doc>
	</class>
	<class path="xmpp.EntityTime" params="" file="../../xmpp/EntityTime.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="78" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.EntityTime"/>
</f></parse>
		<utc public="1">
			<c path="String"/>
			<haxe_doc>The UTC time according to the responding entity.
		 The format conforms to the dateTime profile specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html)
		 and MUST be expressed in UTC.</haxe_doc>
		</utc>
		<tzo public="1">
			<c path="String"/>
			<haxe_doc>The entity's numeric time zone offset from UTC.
		The format conforms to the Time Zone Definition (TZD) specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html).
		Example: +02:00</haxe_doc>
		</tzo>
		<toXml public="1" set="method" line="70"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="48"><f a="?utc:?tzo">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<typedef path="xmpp.ApplicationErrorCondition" params="" file="../../xmpp/ErrorPacket.hx" module="xmpp.ErrorPacket"><a>
	<xmlns><c path="String"/></xmlns>
	<condition><c path="String"/></condition>
</a></typedef>
	<enum path="xmpp.ErrorType" params="" file="../../xmpp/ErrorType.hx">
		<auth><haxe_doc>Retry after providing credentials</haxe_doc></auth>
		<cancel><haxe_doc>Do not retry (the error is unrecoverable)</haxe_doc></cancel>
		<continue_><haxe_doc>Proceed (the condition was only a warning)</haxe_doc></continue_>
		<modify><haxe_doc>Retry after changing the data sent</haxe_doc></modify>
		<wait><haxe_doc>Retry after waiting (the error is temporary)</haxe_doc></wait>
	</enum>
	<class path="xmpp.HXR" params="" file="../../xmpp/HXR.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<create public="1" set="method" line="33" static="1">
			<f a="?d">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</create>
		<getData public="1" get="inline" set="null" line="42" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</getData>
		<haxe_doc>Haxe/XMPP remoting extension</haxe_doc>
	</class>
	<class path="xmpp.IQ" params="" file="../../xmpp/IQ.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="82" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.IQ"/>
</f></parse>
		<createQueryXml public="1" set="method" line="105" static="1">
			<f a="ns:?name">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc><![CDATA[Creates a '<query xmlns="namspace"/>' XML tag]]></haxe_doc>
		</createQueryXml>
		<createResult public="1" get="inline" set="null" line="114" static="1">
			<f a="iq:?from">
				<c path="xmpp.IQ"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a result type IQ from the given request</haxe_doc>
		</createResult>
		<createError public="1" set="method" line="121" static="1">
			<f a="iq:?errors:?from">
				<c path="xmpp.IQ"/>
				<c path="Array"><c path="xmpp.Error"/></c>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a error type IQ packet from given request</haxe_doc>
		</createError>
		<type public="1">
			<e path="xmpp.IQType"/>
			<haxe_doc>Either: get/set/result/error</haxe_doc>
		</type>
		<x public="1">
			<t path="xmpp.PacketElement"/>
			<haxe_doc>The exclusive child of the IQ packet</haxe_doc>
		</x>
		<toXml public="1" set="method" line="74" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="66"><f a="?type:?id:?to:?from">
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[InfoQuery XMPP packet

	Info/Query, or IQ, is a "request-response" mechanism, similar in some ways to the Hypertext Transfer Protocol [HTTP].
	The semantics of IQ enable an entity to make a request of, and receive a response from, another entity.
	The data content of the request and response is defined by the schema or other structural definition associated with the XML namespace that qualifies the direct child element of the IQ element,
	and the interaction is tracked by the requesting entity through use of the 'id' attribute. Thus, IQ interactions follow a common pattern of structured data exchange such as get/result or set/result (although an error can be returned in reply to a request if appropriate)

	Requesting                  Responding
	  Entity                      Entity
	----------                  ----------
	    |                            |
	    | <iq id='1' type='get'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='1' type='result'>  |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |
	    | <iq id='2' type='set'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='2' type='error'>   |
	    |   [ ... condition ... ]    |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |]]></haxe_doc>
	</class>
	<enum path="xmpp.IQType" params="" file="../../xmpp/IQType.hx">
		<get/>
		<set/>
		<result/>
		<error/>
	</enum>
	<class path="xmpp.LOP" params="" file="../../xmpp/LOP.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.LastActivity" params="" file="../../xmpp/LastActivity.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.LastActivity"/>
</f></parse>
		<parseSeconds public="1" get="inline" set="null" line="50" static="1">
			<f a="x">
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Parses/Returns the time value of the given IQ query xml.</haxe_doc>
		</parseSeconds>
		<seconds public="1"><x path="Int"/></seconds>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="33"><f a="?seconds">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="xmpp.MUC" params="" file="../../xmpp/MUC.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.MUCAdmin" params="" file="../../xmpp/MUCAdmin.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCAdmin"/>
</f></parse>
		<items public="1"><c path="Array"><c path="xmpp.muc.Item"/></c></items>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCOwner" params="" file="../../xmpp/MUCOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<items public="1"><c path="List"><c path="xmpp.muc.Item"/></c></items>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCUser" params="" file="../../xmpp/MUCUser.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCUser"/>
</f></parse>
		<decline public="1"><c path="xmpp.muc.Decline"/></decline>
		<destroy public="1"><c path="xmpp.muc.Destroy"/></destroy>
		<invite public="1"><c path="xmpp.muc.Invite"/></invite>
		<item public="1"><c path="xmpp.muc.Item"/></item>
		<password public="1"><c path="String"/></password>
		<status public="1"><c path="xmpp.muc.Status"/></status>
		<toXml public="1" set="method" line="44"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Message" params="" file="../../xmpp/Message.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="60" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Message"/>
</f></parse>
		<type public="1">
			<e path="xmpp.MessageType"/>
			<haxe_doc></haxe_doc>
		</type>
		<body public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</body>
		<subject public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</subject>
		<thread public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</thread>
		<toXml public="1" set="method" line="50" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?to:?body:?subject:?type:?thread:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.MessageType"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XMPP message packet.</haxe_doc>
	</class>
	<enum path="xmpp.MessageType" params="" file="../../xmpp/MessageType.hx">
		<normal/>
		<error/>
		<chat/>
		<groupchat/>
		<headline/>
		<haxe_doc></haxe_doc>
	</enum>
	<typedef path="xmpp.PacketElement" params="" file="../../xmpp/PacketElement.hx"><a><toXml set="method"><f a=""><c path="Xml"/></f></toXml></a></typedef>
	<typedef path="xmpp.PacketFilter" params="" file="../../xmpp/PacketFilter.hx"><a><accept set="method">
	<f a="packet">
		<c path="xmpp.Packet"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Returns true if the given XMPP packet passes through this filter.</haxe_doc>
</accept></a></typedef>
	<enum path="xmpp.PacketType" params="" file="../../xmpp/PacketType.hx">
		<iq><haxe_doc></haxe_doc></iq>
		<message><haxe_doc></haxe_doc></message>
		<presence><haxe_doc></haxe_doc></presence>
		<custom><haxe_doc></haxe_doc></custom>
		<haxe_doc>Core XMPP packet types.</haxe_doc>
	</enum>
	<class path="xmpp.PersonalEvent" params="" file="../../xmpp/PersonalEvent.hx">
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<xmlns public="1" set="null"><c path="String"/></xmlns>
		<getNode public="1" set="method" line="41">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the (subclass) namespace.</haxe_doc>
		</getNode>
		<empty public="1" set="method" line="48">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns a empty XML node for disabling the personal event.</haxe_doc>
		</empty>
		<toXml public="1" set="method" line="52"><f a=""><c path="Xml"/></f></toXml>
		<new set="method" line="33"><f a="nodeName:xmlns">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for personal event classes.
	The implementing class HAS TO HAVE a static XMLNS field (required by jabber.PersonalEventListener)!</haxe_doc>
	</class>
	<class path="xmpp.Ping" params="" file="../../xmpp/Ping.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<xml public="1" line="29" static="1"><c path="Xml"/></xml>
		<haxe_doc><![CDATA[<a href="http://www.xmpp.org/extensions/xep-0199.html">XEP 199 - XMPP Ping</a>]]></haxe_doc>
	</class>
	<class path="xmpp.PlainPacket" params="" file="../../xmpp/PlainPacket.hx">
		<extends path="xmpp.Packet"/>
		<src public="1">
			<c path="Xml"/>
			<haxe_doc>Plain XML content of the packet.</haxe_doc>
		</src>
		<toXml public="1" get="inline" set="null" line="40" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="src">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Plain/Custom XMPP packet.</haxe_doc>
	</class>
	<class path="xmpp.Presence" params="" file="../../xmpp/Presence.hx">
		<extends path="xmpp.Packet"/>
		<MAX_STATUS_SIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_STATUS_SIZE>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Presence"/>
</f></parse>
		<type public="1"><e path="xmpp.PresenceType"/></type>
		<show public="1"><e path="xmpp.PresenceShow"/></show>
		<status public="1" set="accessor"><c path="String"/></status>
		<priority public="1"><t path="Null"><x path="Int"/></t></priority>
		<set_status set="method" line="46"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_status>
		<toXml public="1" set="method" line="52" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="37"><f a="?show:?status:?priority:?type">
	<e path="xmpp.PresenceShow"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>RFC-3921 - Instant Messaging and Presence: http://xmpp.org/rfcs/rfc3921.html
	Exchanging Presence Information: http://www.xmpp.org/rfcs/rfc3921.html#presence</haxe_doc>
	</class>
	<enum path="xmpp.PresenceShow" params="" file="../../xmpp/PresenceShow.hx">
		<chat><haxe_doc>Especially socialable</haxe_doc></chat>
		<away><haxe_doc>Away from device</haxe_doc></away>
		<xa><haxe_doc>Extended Away</haxe_doc></xa>
		<dnd><haxe_doc>Busy</haxe_doc></dnd>
		<haxe_doc>Four elements, which provide insights into a human users availbility
	for and interest in communication.</haxe_doc>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="xmpp.PresenceType" params="" file="../../xmpp/PresenceType.hx">
		<error/>
		<probe/>
		<subscribe/>
		<subscribed/>
		<unavailable/>
		<unsubscribe/>
		<unsubscribed/>
	</enum>
	<class path="xmpp.PrivacyList" params="" file="../../xmpp/PrivacyList.hx">
		<parse public="1" set="method" line="42" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyList"/>
</f></parse>
		<name public="1"><c path="String"/></name>
		<items public="1"><c path="Array"><c path="xmpp.privacylist.Item"/></c></items>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PrivacyLists" params="" file="../../xmpp/PrivacyLists.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="59" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyLists"/>
</f></parse>
		<active public="1"><c path="String"/></active>
		<_default public="1"><c path="String"/></_default>
		<lists public="1"><c path="Array"><c path="xmpp.PrivacyList"/></c></lists>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<iterator public="1" get="inline" set="null" line="55"><f a=""><t path="Iterator"><c path="xmpp.PrivacyList"/></t></f></iterator>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.PrivateStorage" params="" file="../../xmpp/PrivateStorage.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivateStorage"/>
</f></parse>
		<name public="1"><c path="String"/></name>
		<namespace public="1"><c path="String"/></namespace>
		<data public="1"><c path="Xml"/></data>
		<toXml public="1" set="method" line="40"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="name:namespace:?data">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PubSub" params="" file="../../xmpp/PubSub.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="90" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSub"/>
</f></parse>
		<subscribe public="1"><a>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></subscribe>
		<options public="1"><c path="xmpp.pubsub.Options"/></options>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<create public="1"><c path="String"/></create>
		<configure public="1"><c path="xmpp.DataForm"/></configure>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<publish public="1"><c path="xmpp.pubsub.Publish"/></publish>
		<retract public="1"><c path="xmpp.pubsub.Retract"/></retract>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<unsubscribe public="1"><a>
	<subid><c path="String"/></subid>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></unsubscribe>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubEvent" params="" file="../../xmpp/PubSubEvent.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubEvent"/>
</f></parse>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<configuration public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configuration>
		<delete public="1"><c path="String"/></delete>
		<purge public="1"><c path="String"/></purge>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubOwner" params="" file="../../xmpp/PubSubOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubOwner"/>
</f></parse>
		<delete public="1">
			<c path="String"/>
			<haxe_doc>Set to "" (empty string) to add a empty delete element</haxe_doc>
		</delete>
		<purge public="1"><c path="String"/></purge>
		<configure public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configure>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<_default public="1"><a>
	<form><c path="xmpp.DataForm"/></form>
	<empty><x path="Bool"/></empty>
</a></_default>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Register" params="" file="../../xmpp/Register.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="96" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Register"/>
</f></parse>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<email public="1"><c path="String"/></email>
		<name public="1"><c path="String"/></name>
		<nick public="1"><c path="String"/></nick>
		<first public="1"><c path="String"/></first>
		<last public="1"><c path="String"/></last>
		<address public="1"><c path="String"/></address>
		<city public="1"><c path="String"/></city>
		<state public="1"><c path="String"/></state>
		<zip public="1"><c path="String"/></zip>
		<phone public="1"><c path="String"/></phone>
		<url public="1"><c path="String"/></url>
		<date public="1"><c path="String"/></date>
		<misc public="1"><c path="String"/></misc>
		<text public="1"><c path="String"/></text>
		<key public="1"><c path="String"/></key>
		<registered public="1"><x path="Bool"/></registered>
		<remove public="1"><x path="Bool"/></remove>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="61"><f a=""><c path="Xml"/></f></toXml>
		<createElement set="method" line="88"><f a="x:id">
	<c path="Xml"/>
	<c path="String"/>
	<c path="Xml"/>
</f></createElement>
		<new public="1" set="method" line="53"><f a="?username:?password:?email:?name">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration</haxe_doc>
	</class>
	<class path="xmpp.Roster" params="" file="../../xmpp/Roster.hx">
		<extends path="List"><c path="xmpp.roster.Item"/></extends>
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Roster"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?items">
	<t path="Iterable"><c path="xmpp.roster.Item"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ roster extension.</haxe_doc>
	</class>
	<class path="xmpp.SASL" params="" file="../../xmpp/SASL.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<EREG_FAILURE public="1" line="32" static="1"><c path="EReg"/></EREG_FAILURE>
		<createAuth public="1" set="method" line="36" static="1">
			<f a="mech:?text">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createAuth>
		<createResponse public="1" set="method" line="47" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createResponse>
		<parseMechanisms public="1" set="method" line="58" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Parses list of SASL mechanisms.</haxe_doc>
		</parseMechanisms>
		<haxe_doc>Static methods for creation/manipulation of SASL XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.SoftwareVersion" params="" file="../../xmpp/SoftwareVersion.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="56" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.SoftwareVersion"/>
</f></parse>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity</haxe_doc>
		</os>
		<toXml public="1" set="method" line="48"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="42"><f a="?name:?version:?os">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="xmpp.Stream" params="" file="../../xmpp/Stream.hx">
		<STREAM public="1" set="null" line="29" static="1"><c path="String"/></STREAM>
		<CLIENT public="1" set="null" line="30" static="1"><c path="String"/></CLIENT>
		<SERVER public="1" set="null" line="31" static="1"><c path="String"/></SERVER>
		<createOpenXml public="1" set="method" line="39" static="1">
			<f a="ns:to:?version:?lang:?header">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Creates the opening XML tag of a XMPP stream.</haxe_doc>
		</createOpenXml>
		<haxe_doc>Static stuff for creation/manipulation of XMPP stream opening/closing tags.</haxe_doc>
	</class>
	<class path="xmpp.UserSearch" params="" file="../../xmpp/UserSearch.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="62" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.UserSearch"/>
</f></parse>
		<getFieldValue set="method" line="88" static="1"><f a="x">
	<c path="Xml"/>
	<c path="String"/>
</f></getFieldValue>
		<instructions public="1"><c path="String"/></instructions>
		<first public="1"><c path="String"/></first>
		<last public="1"><c path="String"/></last>
		<nick public="1"><c path="String"/></nick>
		<email public="1"><c path="String"/></email>
		<items public="1"><c path="Array"><t path="xmpp.UserSearchItem"/></c></items>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="xmpp.UserSearchItem" params="" file="../../xmpp/UserSearchItem.hx"><a>
	<nick><c path="String"/></nick>
	<last><c path="String"/></last>
	<jid><c path="String"/></jid>
	<first><c path="String"/></first>
	<email><c path="String"/></email>
</a></typedef>
	<class path="xmpp.VCardTemp" params="" file="../../xmpp/VCardTemp.hx">
		<XMLNS public="1" set="null" line="42" static="1"><c path="String"/></XMLNS>
		<PROD_ID public="1" set="null" line="43" static="1"><c path="String"/></PROD_ID>
		<VERSION public="1" set="null" line="44" static="1"><c path="String"/></VERSION>
		<hasPhoto public="1" set="method" line="153" static="1">
			<f a="vc">
				<c path="xmpp.VCardTemp"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given vcard has a photo attached (all xmpp.vcard.Photo).</haxe_doc>
		</hasPhoto>
		<emptyXml public="1" set="method" line="158" static="1"><f a=""><c path="Xml"/></f></emptyXml>
		<parse public="1" set="method" line="167" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.VCardTemp"/>
</f></parse>
		<parsePhoto set="method" line="306" static="1"><f a="x">
	<c path="Xml"/>
	<t path="xmpp.vcard.Photo"/>
</f></parsePhoto>
		<fn public="1"><c path="String"/></fn>
		<n public="1"><t path="xmpp.vcard.Name"/></n>
		<nickname public="1"><c path="String"/></nickname>
		<photo public="1"><t path="xmpp.vcard.Photo"/></photo>
		<birthday public="1"><c path="String"/></birthday>
		<addresses public="1"><c path="Array"><t path="xmpp.vcard.Address"/></c></addresses>
		<tels public="1"><c path="Array"><t path="xmpp.vcard.Tel"/></c></tels>
		<email public="1"><t path="xmpp.vcard.EMail"/></email>
		<jid public="1"><c path="String"/></jid>
		<tz public="1"><c path="String"/></tz>
		<geo public="1"><t path="xmpp.vcard.Geo"><x path="Float"/></t></geo>
		<title public="1"><c path="String"/></title>
		<role public="1"><c path="String"/></role>
		<org public="1"><t path="xmpp.vcard.Org"/></org>
		<url public="1"><c path="String"/></url>
		<desc public="1"><c path="String"/></desc>
		<toXml public="1" set="method" line="68"><f a=""><c path="Xml"/></f></toXml>
		<addXmlField set="method" line="144"><f a="n:x:?name">
	<c path="String"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></addXmlField>
		<new public="1" set="method" line="63"><f a=""><x path="Void"/></f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html
	RFC2426: http://tools.ietf.org/html/rfc2426

	Depricated! Replaced by XEP0292 (see xmpp.VCard).
	This is just a subset of RFC2426!</haxe_doc>
	</class>
	<class path="xmpp.X" params="" file="../../xmpp/X.hx"><create public="1" set="method" line="28" static="1"><f a="ns:?childs">
	<c path="String"/>
	<t path="Iterable"><c path="Xml"/></t>
	<c path="Xml"/>
</f></create></class>
	<class path="xmpp.XMLUtil" params="" file="../../xmpp/XMLUtil.hx">
		<createElement public="1" set="method" line="33" static="1">
			<f a="n:t">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param n Name of xml element to create
		@param t Node content</haxe_doc>
		</createElement>
		<addElement public="1" get="inline" set="null" line="44" static="1">
			<f a="x:name:content">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param n Name of xml node
		@param t Node content</haxe_doc>
		</addElement>
		<addField public="1" set="method" line="56" static="1">
			<f a="x:o:n:?required">
				<c path="Xml"/>
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the element to
		@param o The target object, provider of value
		@param n Name of XML node
		@param t Node content</haxe_doc>
		</addField>
		<addFields public="1" set="method" line="69" static="1">
			<f a="x:o:?fields">
				<c path="Xml"/>
				<d/>
				<t path="Iterable"><c path="String"/></t>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param o The target object to retrieve the field values from
		@param fields Optional names of fields, gets reflected if null</haxe_doc>
		</addFields>
		<reflectElements public="1" params="T" set="method" line="78" static="1">
			<f a="target:x">
				<c path="reflectElements.T"/>
				<c path="Xml"/>
				<c path="reflectElements.T"/>
			</f>
			<haxe_doc>TODO use?</haxe_doc>
		</reflectElements>
		<ns public="1" set="method" line="90" static="1">
			<f a="x:?ns">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get (if no ns specified) or set the namespace of the given xml element.

		@param x XML element to attach the create element to
		@param ns Optional namespace to set</haxe_doc>
		</ns>
		<setNamespace public="1" get="inline" set="null" line="100" static="1">
			<f a="x:s">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Hack because flash is unable to set xml namespace (since haxe 2.06) //TODO</haxe_doc>
		</setNamespace>
		<haxe_doc>XML utilities.</haxe_doc>
	</class>
	<class path="xmpp.dataform.Field" params="" file="../../xmpp/dataform/Field.hx">
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Field"/>
</f></parse>
		<parseFields public="1" set="method" line="74" static="1">
			<f a="t:x">
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
				<c path="Xml"/>
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
			</f>
			<haxe_doc>Parses all dataform fields into the given dataform field container.</haxe_doc>
		</parseFields>
		<label public="1"><c path="String"/></label>
		<type public="1"><e path="xmpp.dataform.FieldType"/></type>
		<variable public="1"><c path="String"/></variable>
		<desc public="1"><c path="String"/></desc>
		<required public="1"><x path="Bool"/></required>
		<values public="1"><c path="Array"><c path="String"/></c></values>
		<options public="1"><c path="Array"><c path="xmpp.dataform.FieldOption"/></c></options>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="36"><f a="?type">
	<e path="xmpp.dataform.FieldType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.FieldOption" params="" file="../../xmpp/dataform/FieldOption.hx">
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.FieldOption"/>
</f></parse>
		<label public="1"><c path="String"/></label>
		<value public="1"><c path="String"/></value>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?label:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.dataform.FieldType" params="" file="../../xmpp/dataform/FieldType.hx">
		<boolean><haxe_doc>The field enables an entity to gather or provide an either-or choice between two options.
		The default value is "false".</haxe_doc></boolean>
		<fixed><haxe_doc><![CDATA[The field is intended for data description (e.g., human-readable text such as "section" headers) rather than data gathering or provision.
		The <value/> child SHOULD NOT contain newlines (the \n and \r characters);
		instead an application SHOULD generate multiple fixed fields, each with one <value/> child.]]></haxe_doc></fixed>
		<hidden><haxe_doc>The field is not shown to the form-submitting entity, but instead is returned with the form.
		The form-submitting entity SHOULD NOT modify the value of a hidden field, 
		but MAY do so if such behavior is defined for the "using protocol".</haxe_doc></hidden>
		<jid_multi><haxe_doc>The field enables an entity to gather or provide multiple Jabber IDs.
		Each provided JID SHOULD be unique (as determined by comparison that includes application of the Nodeprep, Nameprep, and Resourceprep profiles of Stringprep as specified in XMPP Core),
		and duplicate JIDs MUST be ignored.</haxe_doc></jid_multi>
		<jid_single><haxe_doc>The field enables an entity to gather or provide a single Jabber ID.</haxe_doc></jid_single>
		<list_multi><haxe_doc>The field enables an entity to gather or provide one or more options from among many.
		A form-submitting entity chooses one or more items from among the options presented by the form-processing entity and MUST NOT insert new options.
		The form-submitting entity MUST NOT modify the order of items as received from the form-processing entity,
		since the order of items MAY be significant.</haxe_doc></list_multi>
		<list_single><haxe_doc>The field enables an entity to gather or provide one option from among many.
		A form-submitting entity chooses one item from among the options presented by the form-processing entity and MUST NOT insert new options.</haxe_doc></list_single>
		<text_multi><haxe_doc>The field enables an entity to gather or provide multiple lines of text.</haxe_doc></text_multi>
		<text_private><haxe_doc>The field enables an entity to gather or provide a single line or word of text,
		which shall be obscured in an interface (e.g., with multiple instances of the asterisk character).</haxe_doc></text_private>
		<text_single><haxe_doc>The field enables an entity to gather or provide a single line or word of text, which may be shown in an interface.
		This field type is the default and MUST be assumed if a form-submitting entity receives a field type it does not understand.</haxe_doc></text_single>
	</enum>
	<enum path="xmpp.dataform.FormType" params="" file="../../xmpp/dataform/FormType.hx">
		<cancel><haxe_doc>The form-submitting entity has cancelled submission of data to the form-processing entity.</haxe_doc></cancel>
		<form><haxe_doc>The form-processing entity is asking the form-submitting entity to complete a form.</haxe_doc></form>
		<result><haxe_doc>The form-processing entity is returning data (e.g., search results) to the form-submitting entity,
		or the data is a generic data set.</haxe_doc></result>
		<submit><haxe_doc>The form-submitting entity is submitting data to the form-processing entity.
		The submission MAY include fields that were not provided in the empty form,
		but the form-processing entity MUST ignore any fields that it does not understand.</haxe_doc></submit>
	</enum>
	<class path="xmpp.dataform.Item" params="" file="../../xmpp/dataform/Item.hx">
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Item"/>
</f></parse>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<toXml public="1" set="method" line="32"><f a=""><c path="Xml"/></f></toXml>
		<createXml set="method" line="36"><f a="n">
	<c path="String"/>
	<c path="Xml"/>
</f></createXml>
		<new public="1" set="method" line="28"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.Reported" params="" file="../../xmpp/dataform/Reported.hx">
		<extends path="xmpp.dataform.Item"/>
		<parse public="1" get="inline" set="null" line="34" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Reported"/>
</f></parse>
		<toXml public="1" set="method" line="30" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="26"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="xmpp.disco.Identity" params="" file="../../xmpp/disco/Identity.hx"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></typedef>
	<class path="xmpp.disco.Info" params="" file="../../xmpp/disco/Info.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Info"/>
</f></parse>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<features public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>List of features/namespaces</haxe_doc>
		</features>
		<node public="1">
			<c path="String"/>
			<haxe_doc>Specific node</haxe_doc>
		</node>
		<x public="1">
			<c path="Xml"/>
			<haxe_doc>Dataform</haxe_doc>
		</x>
		<toXml public="1" set="method" line="46"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="40"><f a="?identities:?features:?node">
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Item" params="" file="../../xmpp/disco/Item.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Item"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<name public="1"><c path="String"/></name>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="jid:?name:?node">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Items" params="" file="../../xmpp/disco/Items.hx">
		<extends path="List"><c path="xmpp.disco.Item"/></extends>
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Items"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.filter.IQFilter" params="" file="../../xmpp/filter/IQFilter.hx">
		<xmlns public="1"><c path="String"/></xmlns>
		<node public="1"><c path="String"/></node>
		<type public="1"><e path="xmpp.IQType"/></type>
		<accept public="1" set="method" line="39">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="?xmlns:?type:?node">
	<c path="String"/>
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters IQ packets: namespace/nodename/iqtype</haxe_doc>
	</class>
	<class path="xmpp.filter.MessageFilter" params="" file="../../xmpp/filter/MessageFilter.hx">
		<type public="1"><e path="xmpp.MessageType"/></type>
		<accept public="1" set="method" line="38">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="?type">
	<e path="xmpp.MessageType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters message packets, optional including xmpp.MessageType.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromContainsFilter" params="" file="../../xmpp/filter/PacketFromContainsFilter.hx">
		<contains public="1" set="accessor"><c path="String"/></contains>
		<ereg><c path="EReg"/></ereg>
		<set_contains set="method" line="37"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_contains>
		<accept public="1" set="method" line="42">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="contains">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets where the from attribute contains the given string.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromFilter" params="" file="../../xmpp/filter/PacketFromFilter.hx">
		<jid public="1"><c path="String"/></jid>
		<accept public="1" get="inline" set="null" line="35"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Bool"/>
</f></accept>
		<new public="1" set="method" line="31"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching 'from' attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketIDFilter" params="" file="../../xmpp/filter/PacketIDFilter.hx">
		<id public="1"><c path="String"/></id>
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching id attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketNameFilter" params="" file="../../xmpp/filter/PacketNameFilter.hx">
		<expr public="1"><c path="EReg"/></expr>
		<accept public="1" set="method" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="expr">
	<c path="EReg"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters (just) custom XMPP packets with given nodename expression.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketPropertyFilter" params="" file="../../xmpp/filter/PacketPropertyFilter.hx">
		<ns public="1"><c path="String"/></ns>
		<name public="1"><c path="String"/></name>
		<accept public="1" set="method" line="36">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="ns:?name">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.filter.PacketTypeFilter" params="" file="../../xmpp/filter/PacketTypeFilter.hx">
		<type public="1"><e path="xmpp.PacketType"/></type>
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="type">
	<e path="xmpp.PacketType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters packets with matching xmpp.PacketType.</haxe_doc>
	</class>
	<typedef path="xmpp.lop.Binding" params="" file="../../xmpp/lop/Binding.hx"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
	<datatype><c path="String"/></datatype>
</a></typedef>
	<class path="xmpp.lop.Bindings" params="" file="../../xmpp/lop/Bindings.hx">
		<extends path="List"><t path="xmpp.lop.Binding"/></extends>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Bindings"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Ping" params="" file="../../xmpp/lop/Ping.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Ping"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<job_id public="1"><c path="String"/></job_id>
		<status public="1"><c path="String"/></status>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="vm_id:?job_id:?status">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.SpawnVM" params="" file="../../xmpp/lop/SpawnVM.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.SpawnVM"/>
</f></parse>
		<species public="1"><c path="String"/></species>
		<id public="1"><c path="String"/></id>
		<password public="1"><c path="String"/></password>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="species:?id:?password">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Submit" params="" file="../../xmpp/lop/Submit.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Submit"/>
</f></parse>
		<id public="1"><c path="String"/></id>
		<code public="1"><c path="String"/></code>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="id:?code">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Terminate" params="" file="../../xmpp/lop/Terminate.hx">
		<parse public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Terminate"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.muc.Affiliation" params="" file="../../xmpp/muc/Affiliation.hx">
		<none/>
		<owner/>
		<admin/>
		<member/>
		<outcast/>
		<haxe_doc>Long-lived association or connection with a room.
	Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Decline" params="" file="../../xmpp/muc/Decline.hx">
		<parse public="1" set="method" line="50" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Decline"/>
</f></parse>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<reason public="1"><c path="String"/></reason>
		<nodeName><c path="String"/></nodeName>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="35"><f a="?reason:?to:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Destroy" params="" file="../../xmpp/muc/Destroy.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Destroy"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<reason public="1"><c path="String"/></reason>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="?jid:?reason">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Invite" params="" file="../../xmpp/muc/Invite.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Invite"/>
</f></parse>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<reason public="1"><c path="String"/></reason>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="to:?reason:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Item" params="" file="../../xmpp/muc/Item.hx">
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Item"/>
</f></parse>
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<nick public="1"><c path="String"/></nick>
		<jid public="1"><c path="String"/></jid>
		<actor public="1"><c path="String"/></actor>
		<reason public="1"><c path="String"/></reason>
		<continue_ public="1"><c path="String"/></continue_>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?affiliation:?role:?nick:?jid">
	<e path="xmpp.muc.Affiliation"/>
	<e path="xmpp.muc.Role"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<enum path="xmpp.muc.Role" params="" file="../../xmpp/muc/Role.hx">
		<none/>
		<visitor/>
		<participant/>
		<moderator/>
		<haxe_doc>Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Status" params="" file="../../xmpp/muc/Status.hx">
		<MYSELF public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></MYSELF>
		<ROOMNICK_CHANGED public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></ROOMNICK_CHANGED>
		<WAITS_FOR_UNLOCK public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></WAITS_FOR_UNLOCK>
		<parse public="1" get="inline" set="null" line="42" static="1"><f a="x">
	<a><get set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get></a>
	<c path="xmpp.muc.Status"/>
</f></parse>
		<code public="1"><x path="Int"/></code>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.Action" params="" file="../../xmpp/privacylist/Action.hx">
		<allow/>
		<deny/>
	</enum>
	<class path="xmpp.privacylist.Item" params="" file="../../xmpp/privacylist/Item.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.privacylist.Item"/>
</f></parse>
		<type public="1"><e path="xmpp.privacylist.ItemType"/></type>
		<action public="1"><e path="xmpp.privacylist.Action"/></action>
		<value public="1"><c path="String"/></value>
		<order public="1"><x path="Int"/></order>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="action:?type:?value:?order">
	<e path="xmpp.privacylist.Action"/>
	<e path="xmpp.privacylist.ItemType"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.ItemType" params="" file="../../xmpp/privacylist/ItemType.hx">
		<group/>
		<jid/>
		<subscription/>
	</enum>
	<class path="xmpp.pubsub.Affiliation" params="" file="../../xmpp/pubsub/Affiliation.hx">
		<parse public="1" set="method" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliation"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<affiliation public="1"><e path="xmpp.pubsub.AffiliationState"/></affiliation>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="node:affiliation">
	<c path="String"/>
	<e path="xmpp.pubsub.AffiliationState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.AffiliationState" params="" file="../../xmpp/pubsub/AffiliationState.hx">
		<none/>
		<owner/>
		<publisher/>
		<member/>
		<outcast/>
		<haxe_doc><![CDATA[<a href="http://xmpp.org/extensions/xep-0060.html#affiliations">Affiliations</a>]]></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Affiliations" params="" file="../../xmpp/pubsub/Affiliations.hx">
		<extends path="List"><c path="xmpp.pubsub.Affiliation"/></extends>
		<parse public="1" set="method" line="33" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliations"/>
</f></parse>
		<toXml public="1" set="method" line="26"><f a=""><c path="Xml"/></f></toXml>
	</class>
	<class path="xmpp.pubsub.Item" params="" file="../../xmpp/pubsub/Item.hx">
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Item"/>
</f></parse>
		<id public="1"><c path="String"/></id>
		<payload public="1"><c path="Xml"/></payload>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?id:?payload">
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Items" params="" file="../../xmpp/pubsub/Items.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Items"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<maxItems public="1"><t path="Null"><x path="Int"/></t></maxItems>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="?node:?subid:?maxItems">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Options" params="" file="../../xmpp/pubsub/Options.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Options"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?jid:?node:?subid:?form">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.DataForm"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Publish" params="" file="../../xmpp/pubsub/Publish.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Publish"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="28"><f a="node:?items">
	<c path="String"/>
	<t path="Iterable"><c path="xmpp.pubsub.Item"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Retract" params="" file="../../xmpp/pubsub/Retract.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Retract"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<notify public="1"><x path="Bool"/></notify>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="node:?itemIDs:?notify">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Subscription" params="" file="../../xmpp/pubsub/Subscription.hx">
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscription"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<subscription public="1"><e path="xmpp.pubsub.SubscriptionState"/></subscription>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="jid:?node:?subid:?subscription">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.pubsub.SubscriptionState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.SubscriptionState" params="" file="../../xmpp/pubsub/SubscriptionState.hx">
		<none><haxe_doc>The node MUST NOT send event notifications or payloads to the Entity.</haxe_doc></none>
		<pending><haxe_doc>An entity has requested to subscribe to a node and the request has not yet been approved by a node owner.
		The node MUST NOT send event notifications or payloads to the entity while it is in this state.</haxe_doc></pending>
		<unconfigured><haxe_doc>An entity has subscribed but its subscription options have not yet been configured.
		The node MAY send event notifications or payloads to the entity while it is in this state.
		The service MAY timeout unconfigured subscriptions.</haxe_doc></unconfigured>
		<subscribed><haxe_doc>An entity is subscribed to a node.
		The node MUST send all event notifications (and, if configured, payloads) to the entity while it is in this state
		(subject to subscriber configuration and content filtering).</haxe_doc></subscribed>
		<haxe_doc></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Subscriptions" params="" file="../../xmpp/pubsub/Subscriptions.hx">
		<extends path="List"><c path="xmpp.pubsub.Subscription"/></extends>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscriptions"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="33"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="28"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.AskType" params="" file="../../xmpp/roster/AskType.hx">
		<subscribe><haxe_doc>Denotes that  a request to subscribe to a entities presence has been made.</haxe_doc></subscribe>
		<unsubscribe><haxe_doc>Denotes that a request to unscubscribe from a users presence has been made.</haxe_doc></unsubscribe>
		<haxe_doc>Roster ask types.</haxe_doc>
	</enum>
	<class path="xmpp.roster.Item" params="" file="../../xmpp/roster/Item.hx">
		<parse public="1" set="method" line="54" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.roster.Item"/>
</f></parse>
		<jid public="1" set="null"><c path="String"/></jid>
		<subscription public="1"><e path="xmpp.roster.Subscription"/></subscription>
		<name public="1"><c path="String"/></name>
		<askType public="1"><e path="xmpp.roster.AskType"/></askType>
		<groups public="1"><c path="List"><c path="String"/></c></groups>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="jid:?subscription:?name:?askType:?groups">
	<c path="String"/>
	<e path="xmpp.roster.Subscription"/>
	<c path="String"/>
	<e path="xmpp.roster.AskType"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.Subscription" params="" file="../../xmpp/roster/Subscription.hx">
		<none><haxe_doc>The user and subscriber have no interest in each other's presence.</haxe_doc></none>
		<to><haxe_doc>The user is interested in receiving presence updates from the subscriber.</haxe_doc></to>
		<from><haxe_doc>The subscriber is interested in receiving presence updates from the user.</haxe_doc></from>
		<both><haxe_doc>The user and subscriber have a mutual interest in each other's presence.</haxe_doc></both>
		<remove><haxe_doc>The user wishes to stop receiving presence updates from the subscriber.</haxe_doc></remove>
		<haxe_doc>Roster subscription states.</haxe_doc>
	</enum>
	<typedef path="xmpp.vcard.Address" params="" file="../../xmpp/vcard/Address.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<street>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</street>
	<region>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</region>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<postal>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</postal>
	<pobox>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pobox>
	<pcode>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcode>
	<parcel>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parcel>
	<locality>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</locality>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<extadd>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</extadd>
	<ctry>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</ctry>
</a></typedef>
	<typedef path="xmpp.vcard.EMail" params="" file="../../xmpp/vcard/EMail.hx"><a>
	<x400>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</x400>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<userid><c path="String"/></userid>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<internet>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</internet>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
</a></typedef>
	<typedef path="xmpp.vcard.Geo" params="T" file="../../xmpp/vcard/Geo.hx"><a>
	<lon><c path="xmpp.vcard.Geo.T"/></lon>
	<lat><c path="xmpp.vcard.Geo.T"/></lat>
</a></typedef>
	<typedef path="xmpp.vcard.Name" params="" file="../../xmpp/vcard/Name.hx"><a>
	<suffix><c path="String"/></suffix>
	<prefix><c path="String"/></prefix>
	<middle><c path="String"/></middle>
	<given><c path="String"/></given>
	<family><c path="String"/></family>
</a></typedef>
	<typedef path="xmpp.vcard.Org" params="" file="../../xmpp/vcard/Org.hx"><a>
	<orgunit><c path="String"/></orgunit>
	<orgname><c path="String"/></orgname>
</a></typedef>
	<typedef path="xmpp.vcard.Photo" params="" file="../../xmpp/vcard/Photo.hx"><a>
	<type><c path="String"/></type>
	<binval><c path="String"/></binval>
</a></typedef>
	<typedef path="xmpp.vcard.Tel" params="" file="../../xmpp/vcard/Tel.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<voice>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</voice>
	<video>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</video>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<pcs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcs>
	<pager>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pager>
	<number><c path="String"/></number>
	<msg>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</msg>
	<modem>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</modem>
	<isdn>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</isdn>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<fax>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</fax>
	<cell>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</cell>
	<bbs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</bbs>
</a></typedef>
</haxe>