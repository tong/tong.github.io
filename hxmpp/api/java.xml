<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/java/_std/Array.hx">
		<ofNative params="X" set="method" line="41" static="1">
			<f a="native">
				<c path="java.NativeArray"><c path="ofNative.X"/></c>
				<c path="Array"><c path="ofNative.X"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\treturn new Array<X>(_native);\n\t"]]></e></m></meta>
		</ofNative>
		<alloc params="Y" set="method" line="49" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="Array"><c path="alloc.Y"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\treturn new Array<Y>((Y[]) ((java.lang.Object)new java.lang.Object[size]));\n\t"]]></e></m></meta>
		</alloc>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<__a><c path="java.NativeArray"><c path="Array.T"/></c></__a>
		<concat public="1" set="method" line="60">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.
		
		This operation does not modify `this` Array.
		
		If `a` is the empty Array `[]`, a copy of `this` Array is returned.
		
		The length of the returned Array is equal to the sum of `this.length` 
		and `a.length`.
		
		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<concatNative set="method" line="71"><f a="a">
	<c path="java.NativeArray"><c path="Array.T"/></c>
	<x path="Void"/>
</f></concatNative>
		<join public="1" set="method" line="90">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.
		
		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`
		
		If `this` is the empty Array `[]`, the result is the empty String `""`. 
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.
		
		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method" line="109">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this.length` will decrease by 1.
		
		If `this` is the empty Array `[]`, null is returned and the length 
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="125">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the offset
		it was added at.
		
		This operation modifies `this` Array in place.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method" line="141">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="157">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.
		
		If `this` is the empty Array `[]`, `null` is returned and the length 
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="173">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.
		
		This operation does not modify `this` Array.
		
		The elements are not copied and retain their identity.
		
		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.
		
		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.
		
		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="195">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies `this` Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.
		
		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<quicksort set="method" line="202"><f a="lo:hi:f">
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="Array.T"/>
		<c path="Array.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></quicksort>
		<splice public="1" set="method" line="223">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.
		
		This operation modifies `this` Array in place.
		
		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].
		
		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.
		
		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<spliceVoid set="method" line="251"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></spliceVoid>
		<toString public="1" set="method" line="274">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="293">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.
		
		This operation modifies `this` Array in place.
		
		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method" line="312">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.
		
		This operation modifies `this` Array in place.
		
		The offset is calculated like so:
			
		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this` 
		  Array, i.e. `this.length + pos`. If this yields a negative value, the 
		  offset is 0.
		- Otherwise, the offset is `pos`.
		
		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="346">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<copy public="1" set="method" line="365">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.
		
		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However, 
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="374">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method" line="385">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method" line="392">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<__get set="method" line="400"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="409"><f a="idx:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__unsafe_get get="inline" set="null" line="429"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__unsafe_get>
		<__unsafe_set get="inline" set="null" line="434"><f a="idx:val">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__unsafe_set>
		<new public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a `List` which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":classCode"><e>"\n\tpublic Array(T[] _native)\n\t{\n\t\tthis.__a = _native;\n\t\tthis.length = _native.length;\n\t}\n"</e></m>
			<m n=":final"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/java/_std/Date.hx">
		<now public="1" set="method" line="92" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="99" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="106" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<date><c path="java.util.Date"/></date>
		<getTime public="1" get="inline" set="null" line="37">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" get="inline" set="null" line="42">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" get="inline" set="null" line="47">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" get="inline" set="null" line="52">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" get="inline" set="null" line="57">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" get="inline" set="null" line="67">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" get="inline" set="null" line="72">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="77">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="30">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":SuppressWarnings"><e>"deprecation"</e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/java/_std/EReg.hx">
		<convert set="method" line="52" static="1"><f a="r">
	<c path="String"/>
	<c path="String"/>
</f></convert>
		<pattern><c path="String"/></pattern>
		<matcher><c path="java.util.regex.Matcher"/></matcher>
		<cur><c path="String"/></cur>
		<isGlobal><x path="Bool"/></isGlobal>
		<match public="1" set="method" line="80">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.
		
		This method modifies the internal state.
		
		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="86">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.
		
		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.
		
		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.
		
		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="94">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="99">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="104">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="109">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.matchSub(s.substr(pos,len))` can be used instead.
		
		This method modifies the internal state.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="115">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.
		
		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.
		
		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.
		
		If two matching substrings appear next to each other, the result
		contains the empty String "" between them.
		
		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<start get="inline" set="null" line="139"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></start>
		<len get="inline" set="null" line="144"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></len>
		<replace public="1" set="method" line="149">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.
		
		If `this` EReg does not match any substring, the result is `s`.
		
		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.
		
		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.
		
		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="156">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string `s`, the function `f` is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the `g` flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</map>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.
		
		This is equivalent to the shorthand syntax `~/r/opt`
		
		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="IntIterator" params="" file="/usr/lib/haxe/std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" set="method" line="52">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="61">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.
		
		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" set="method" line="44">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).
		
		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.
	
	It is usually not used explicitly, but through it's special syntax:
	`min...max`
		
	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.
		
		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="54" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.
		
		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="68" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new List by applying function `f` to all elements of `it`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="82" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.
		
		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.
		
		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="115" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.
		
		This function returns true as soon as an element is found for which a
		call to `f` returns true.
		
		If no such element is found, the result is false.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="134" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.
		
		This function returns false as soon as an element is found for which a
		call to `f` returns false.
		
		If no such element is found, the result is true.
		
		In particular, this function always returns true if `it` is empty.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="146" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="159" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.
		
		If `it` is empty, the result is the empty List even if `f` is null.
		
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="179" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.
		
		If `it` has no elements, the result is `first`.
		
		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.
		
		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.
		
		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="206" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.
		
		This function uses operator `==` to check for equality.
		
		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="233" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new List containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<first public="1" set="method" line="81">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</first>
		<last public="1" set="method" line="90">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</last>
		<pop public="1" set="method" line="100">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		The element is removed from `this` List.</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="114">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.
		
		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.
		
		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.
		
		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="203">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` List.
		
		The result is enclosed in { } with the individual elements being
		separated by a comma.</haxe_doc>
		</toString>
		<join public="1" set="method" line="224">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` List, with `sep` separating
		each element.</haxe_doc>
		</join>
		<filter public="1" set="method" line="243">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with `f`. The returned list will contain all
		elements for which `f(x) == true`.</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="259">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted by the
		function `f`.</haxe_doc>
		</map>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
	<_new public="1" set="method" static="1">
		<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="70" static="1">
		<f a="this:key:value">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="87" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<t path="Null"><c path="Map.V"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="102" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
	</iterator>
	<toString public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
	</toString>
	<arrayWrite public="1" get="inline" set="null" line="131" static="1">
		<f a="this:k:v">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<c path="Map.V"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</arrayWrite>
	<toStringMap get="inline" set="null" line="136" static="1">
		<f a="t">
			<c path="IMap">
				<c path="String"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap get="inline" set="null" line="140" static="1">
		<f a="t">
			<c path="IMap">
				<x path="Int"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toEnumValueMapMap>
	<toObjectMap params="K" get="inline" set="null" line="148" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toObjectMap>
	<fromStringMap params="V" get="inline" set="null" line="152" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<fromIntMap params="V" get="inline" set="null" line="156" static="1">
		<f a="map">
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="Map">
				<x path="Int"/>
				<c path="fromIntMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntMap>
	<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
		<f a="map">
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
			<x path="Map">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectMap>
</class></impl>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
		<_new public="1" set="method" static="1">
			<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="70" static="1">
			<f a="this:key:value">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="87" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<t path="Null"><c path="Map.V"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="102" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
		</iterator>
		<toString public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
		</toString>
		<arrayWrite public="1" get="inline" set="null" line="131" static="1">
			<f a="this:k:v">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<c path="Map.V"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</arrayWrite>
		<toStringMap get="inline" set="null" line="136" static="1">
			<f a="t">
				<c path="IMap">
					<c path="String"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap get="inline" set="null" line="140" static="1">
			<f a="t">
				<c path="IMap">
					<x path="Int"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.EnumValueMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toEnumValueMapMap>
		<toObjectMap params="K" get="inline" set="null" line="148" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.ObjectMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toObjectMap>
		<fromStringMap params="V" get="inline" set="null" line="152" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<fromIntMap params="V" get="inline" set="null" line="156" static="1">
			<f a="map">
				<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
				<x path="Map">
					<x path="Int"/>
					<c path="fromIntMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntMap>
		<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
			<f a="map">
				<c path="haxe.ds.ObjectMap">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</c>
				<x path="Map">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectMap>
	</class>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<t path="Null"><c path="IMap.V"/></t>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="IMap.K"/>
	<c path="IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
	</class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/java/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.
		
		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.
		
		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.
		
		If `f` is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":native"><e>"java.lang.Math"</e></m>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/java/_std/Reflect.hx">
		<hasField public="1" set="method" line="34" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, false, true, false) != haxe.lang.Runtime.undefined;\n\n\t\treturn haxe.lang.Runtime.slowHasField(o, field);\n\t"</e></m></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.
		
		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="45" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, false, false, false);\n\n\t\treturn haxe.lang.Runtime.slowGetField(o, field, false);\n\t"</e></m></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" line="56" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\t\t((haxe.lang.IHxObject) o).__hx_setField(field, value, false);\n\t\telse\n\t\t\thaxe.lang.Runtime.slowSetField(o, field, value);\n\t"</e></m></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.
		
		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.
		
		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="70" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) o).__hx_getField(field, false, false, true);\n\n\t\tif (haxe.lang.Runtime.slowHasField(o, \"get_\" + field))\n\t\t\treturn haxe.lang.Runtime.slowCallField(o, \"get_\" + field, null);\n\n\t\treturn haxe.lang.Runtime.slowGetField(o, field, false);\n\t"</e></m></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="83" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\t\t((haxe.lang.IHxObject) o).__hx_setField(field, value, true);\n\t\telse if (haxe.lang.Runtime.slowHasField(o, \"set_\" + field))\n\t\t\thaxe.lang.Runtime.slowCallField(o, \"set_\" + field, new Array( new java.lang.Object[]{value} ));\n\t\telse\n\t\t\thaxe.lang.Runtime.slowSetField(o, field, value);\n\t"</e></m></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.
		
		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="91" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn ((haxe.lang.Function) func).__hx_invokeDynamic(args);\n\t"</e></m></meta>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="108" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (o instanceof haxe.lang.IHxObject)\n\t\t{\n\t\t\tArray<String> ret = new Array<String>();\n\t\t\t\t((haxe.lang.IHxObject) o).__hx_getFields(ret);\n\t\t\treturn ret;\n\t\t} else if (o instanceof java.lang.Class) {\n\t\t\treturn Type.getClassFields( (java.lang.Class) o);\n\t\t} else {\n\t\t\treturn new Array<String>();\n\t\t}\n\t"]]></e></m></meta>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="116" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn f instanceof haxe.lang.Function;\n\t"</e></m></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="124" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn haxe.lang.Runtime.compare(a, b);\n\t"</e></m></meta>
			<haxe_doc>Compares `a` and `b`.
		
		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.
		
		This function is only defined if `a` and `b` are of the same type.
		
		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.
		
		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:
		
		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified
		
		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="144" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\n\t\tif (f1 instanceof haxe.lang.Closure && f2 instanceof haxe.lang.Closure)\n\t\t{\n\t\t\thaxe.lang.Closure f1c = (haxe.lang.Closure) f1;\n\t\t\thaxe.lang.Closure f2c = (haxe.lang.Closure) f2;\n\n\t\t\treturn haxe.lang.Runtime.refEq(f1c.obj, f2c.obj) && f1c.field.equals(f2c.field);\n\t\t}\n\n\n\t\treturn false;\n\t"]]></e></m></meta>
			<haxe_doc>Compares the functions `f1` and `f2`.
		
		If `f1` or `f2` are not functions, the result is unspecified.
		
		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="152" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn v != null && !(v instanceof haxe.lang.Enum || v instanceof haxe.lang.Function || v instanceof java.lang.Enum || v instanceof java.lang.Number || v instanceof java.lang.Boolean);\n\t"]]></e></m></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.
		
		The result is true if `v` is one of the following:
			
		- class instance
		- structure
		- Class<T>
		- Enum<T>
			
		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="160" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn v != null && (v instanceof haxe.lang.Enum || v instanceof java.lang.Enum);\n\t"]]></e></m></meta>
			<haxe_doc>Tells if `v` is an enum value.
		
		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.
		
		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="170" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn (o instanceof haxe.lang.DynamicObject && ((haxe.lang.DynamicObject) o).__hx_deleteField(field));\n\t"]]></e></m></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.
		
		This method is only guaranteed to work on anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="175" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.
		
		This is only guaranteed to work on anonymous structures.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="184" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/java/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="56" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="60" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="133" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (x == null) return null;\n\n\t\tint ret = 0;\n\t\tint base = 10;\n\t\tint i = 0;\n\t\tint len = x.length();\n\n\t\tif (x.startsWith(\"0\") && len > 2)\n\t\t{\n\t\t\tchar c = x.charAt(1);\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t{\n\t\t\t\ti = 2;\n\t\t\t\tbase = 16;\n\t\t\t}\n\t\t}\n\n\t\tboolean foundAny = false;\n\t\tboolean isNeg = false;\n\t\tfor (; i < len; i++)\n\t\t{\n\t\t\tchar c = x.charAt(i);\n\t\t\tif (!foundAny)\n\t\t\t{\n\t\t\t\tswitch(c)\n\t\t\t\t{\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tisNeg = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\tcase '\\t':\n\t\t\t\t\tcase '\\r':\n\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tif (isNeg) return null;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c >= '0' && c <= '9')\n\t\t\t{\n\t\t\t\tif (!foundAny && c == '0')\n\t\t\t\t{\n\t\t\t\t\tfoundAny = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret *= base; foundAny = true;\n\n\t\t\t\tret += ((int) (c - '0'));\n\t\t\t} else if (base == 16) {\n\t\t\t\tif (c >= 'a' && c <= 'f') {\n\t\t\t\t\tret *= base; foundAny = true;\n\t\t\t\t\tret += ((int) (c - 'a')) + 10;\n\t\t\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\t\t\tret *= base; foundAny = true;\n\t\t\t\t\tret += ((int) (c - 'A')) + 10;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (foundAny)\n\t\t\treturn isNeg ? -ret : ret;\n\t\telse\n\t\t\treturn null;\n\t"]]></e></m></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="237" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (x == null) return java.lang.Double.NaN;\n\n\t\tx = x.trim();\n\t\tdouble ret = 0.0;\n\t\tdouble div = 0.0;\n\t\tdouble e = 0.0;\n\n\t\tint len = x.length();\n\t\tboolean foundAny = false;\n\t\tboolean isNeg = false;\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\tchar c = x.charAt(i);\n\t\t\tif (!foundAny)\n\t\t\t{\n\t\t\t\tswitch(c)\n\t\t\t\t{\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tisNeg = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\tcase '\\t':\n\t\t\t\t\tcase '\\r':\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tif (isNeg) return java.lang.Double.NaN;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tif (div != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t\tdiv = 1.0;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c >= '0' && c <= '9')\n\t\t\t{\n\t\t\t\tif (!foundAny && c == '0')\n\t\t\t\t{\n\t\t\t\t\tfoundAny = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret *= 10.0; foundAny = true; div *= 10.0;\n\n\t\t\t\tret += ((int) (c - '0'));\n\t\t\t} else if (foundAny && c == 'E' || c == 'e') {\n\t\t\t\tboolean eNeg = false;\n\t\t\t\tboolean eFoundAny = false;\n\n\t\t\t\tchar next = x.charAt(i + 1);\n\t\t\t\tif (i + 1 < len)\n\t\t\t\t{\n\t\t\t\t\tif (next == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\teNeg = true;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (next == '+') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (++i < len)\n\t\t\t\t{\n\t\t\t\t\tc = x.charAt(i);\n\t\t\t\t\tif (c >= '0' && c <= '9')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!eFoundAny && c == '0')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\teFoundAny = true;\n\t\t\t\t\t\te *= 10.0;\n\t\t\t\t\t\te += ((int) (c - '0'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (eNeg) e = -e;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (div == 0.0) div = 1.0;\n\n\t\tif (foundAny)\n\t\t{\n\t\t\tret = isNeg ? -(ret / div) : (ret / div);\n\t\t\tif (e != 0.0)\n\t\t\t{\n\t\t\t\treturn ret * Math.pow(10.0, e);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\treturn java.lang.Double.NaN;\n\t\t}\n\t"]]></e></m></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="241" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="java.lang.CharSequence" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/CharSequence.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.CharSequence"</e></m>
</meta></class>
	<class path="String" params="" file="/usr/lib/haxe/std/java/_std/String.hx" extern="1">
		<implements path="java.lang.CharSequence"/>
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<compareTo set="method"><f a="anotherString">
	<c path="String"/>
	<x path="Int"/>
</f></compareTo>
		<codePointAt set="method"><f a="idx">
	<x path="Int"/>
	<x path="Int"/>
</f></codePointAt>
		<getBytes set="method"><f a="encoding">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></getBytes>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
			<overloads>
				<new public="1" set="method"><f a="b:offset:length:charsetName">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="b:offset:length">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/java/_std/StringBuf.hx">
		<b><c path="java.lang.StringBuilder"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="34"><f a=""><x path="Int"/></f></get_length>
		<add public="1" set="method" line="38">
			<f a="x">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.
		
		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).
		
		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="49">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.
		
		If `s` or `pos` are null, the result is unspecified.
		
		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<addChar public="1" set="method" line="54">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.
		
		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<toString public="1" set="method" line="58">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.
		
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="37" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="62" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="98" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:
			
		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;
		
		If `quotes` is true, the following characters are also replaced:
		
		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="117" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: htmlUnescape(htmlEscape(s)) == s

		The replacements follow:
			
		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<startsWith public="1" get="inline" set="null" line="128" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" get="inline" set="null" line="145" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is null, the result is unspecified.

		If `end` is the empty String "", the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="166" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="180" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="205" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" get="inline" set="null" line="227" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="249" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="271" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="292" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="314" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="343" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`.

		This method is faster than String.charCodeAt() on most platforms.
		However, unlike String.charCodeAt(), the result is unspecified if
		`index` is negative or exceeds `s.length`.

		This operation is not guaranteed to work if `s` contains the \0
		character.</haxe_doc>
		</fastCodeAt>
		<isEof public="1" get="inline" set="null" line="370" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isEof>
		<_charAt get="inline" set="null" line="389" static="1"><f a="str:idx">
	<c path="String"/>
	<x path="Int"/>
	<x path="java.Char16"/>
</f></_charAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/java/_std/Sys.hx">
		<_args static="1"><c path="java.NativeArray"><c path="String"/></c></_args>
		<_env static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></_env>
		<_sysName static="1"><c path="String"/></_sysName>
		<print public="1" get="inline" set="null" line="31" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" get="inline" set="null" line="36" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<args public="1" set="method" line="41" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="53" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" line="59" static="1">
			<f a=""><c path="haxe.ds.StringMap"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" line="72" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="80" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="85" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="90" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="96" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" line="112" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="121" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="126" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="131" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="136" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<getChar public="1" set="method" line="141" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" line="147" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="153" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="158" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/java/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":keep"/></meta>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/java/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="42" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (o == null || o instanceof haxe.lang.DynamicObject || o instanceof java.lang.Class)\n\t\t\treturn null;\n\n\t\treturn (java.lang.Class<T>) o.getClass();\n\t"]]></e></m></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (o instanceof java.lang.Enum || o instanceof haxe.lang.Enum)\n\t\t\treturn o.getClass();\n\t\treturn null;\n\t"</e></m></meta>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.
		
		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.
		
		If `o` is null, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="63" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tjava.lang.Class cl = (c == null) ? null : c.getSuperclass();\n\t\tif (cl != null && !cl.getName().equals(\"haxe.lang.HxObject\") && !cl.getName().equals(\"java.lang.Object\") )\n\t\t\treturn cl;\n\t\treturn null;\n\t"]]></e></m></meta>
			<haxe_doc>Returns the super-class of class `c`.
		
		If `c` has no super class, null is returned.
		
		If `c` is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="68" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="85" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="113" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\ttry {\n\t\t\tif (name.indexOf(\".\") == -1)\n\t\t\t\tname = \"haxe.root.\" + name;\n\t\t\treturn java.lang.Class.forName(name);\n\t\t}\n\t\tcatch (java.lang.ClassNotFoundException e)\n\t\t{\n\t\t\tif (name.equals(\"haxe.root.Int\")) return int.class;\n\t\t\telse if (name.equals(\"haxe.root.Float\")) return double.class;\n\t\t\telse if (name.equals(\"haxe.root.String\")) return java.lang.String.class;\n\t\t\telse if (name.equals(\"haxe.root.Math\")) return java.lang.Math.class;\n\t\t\telse if (name.equals(\"haxe.root.Class\")) return java.lang.Class.class;\n\t\t\telse if (name.equals(\"haxe.root.Dynamic\")) return java.lang.Object.class;\n\t\t\treturn null;\n\t\t}\n\t"</e></m></meta>
			<haxe_doc>Resolves a class by name.
		
		If `name` is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If `name` is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="126" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (\"Bool\".equals(name)) return boolean.class;\n\t\tClass r = resolveClass(name);\n\t\tif (r != null && (r.getSuperclass() == java.lang.Enum.class || r.getSuperclass() == haxe.lang.Enum.class))\n\t\t\treturn r;\n\t\treturn null;\n\t"]]></e></m></meta>
			<haxe_doc>Resolves an enum by name.
		
		If `name` is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If `name` is null the result is unspecified.
		
		If `name` is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="244" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint len = args.length;\n\t\t\tjava.lang.Class[] cls = new java.lang.Class[len];\n\t\t\tjava.lang.Object[] objs = new java.lang.Object[len];\n\n\t\t\tjava.lang.reflect.Constructor[] ms = cl.getConstructors();\n\t\t\tint msl = ms.length;\n\t\t\tint realMsl = 0;\n\t\t\tfor(int i =0; i < msl; i++)\n\t\t\t{\n\t\t\t\tif (!ms[i].isVarArgs() && ms[i].getParameterTypes().length != len)\n\t\t\t\t{\n\t\t\t\t\tms[i] = null;\n\t\t\t\t} else {\n\t\t\t\t\tms[realMsl] = ms[i];\n\t\t\t\t\tif (realMsl != i)\n\t\t\t\t\t\tms[i] = null;\n\t\t\t\t\trealMsl++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasNumber = false;\n\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tObject o = args.__get(i);\n\t\t\t\tobjs[i]= o;\n\t\t\t\tcls[i] = o.getClass();\n\t\t\t\tboolean isNum = false;\n\n\t\t\t\tif (o instanceof java.lang.Number)\n\t\t\t\t{\n\t\t\t\t\tcls[i] = java.lang.Number.class;\n\t\t\t\t\tisNum = hasNumber = true;\n\t\t\t\t}\n\n\t\t\t\tmsl = realMsl;\n\t\t\t\trealMsl = 0;\n\n\t\t\t\tfor (int j = 0; j < msl; j++)\n\t\t\t\t{\n\t\t\t\t\tjava.lang.Class[] allcls = ms[j].getParameterTypes();\n\t\t\t\t\tif (i < allcls.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (! ((isNum && allcls[i].isPrimitive()) || allcls[i].isAssignableFrom(cls[i])) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tms[j] = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tms[realMsl] = ms[j];\n\t\t\t\t\t\t\tif (realMsl != j)\n\t\t\t\t\t\t\t\tms[j] = null;\n\t\t\t\t\t\t\trealMsl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjava.lang.reflect.Constructor found = ms[0];\n\n\t\t\tif (hasNumber)\n\t\t\t{\n\t\t\t\tjava.lang.Class[] allcls = found.getParameterTypes();\n\n\t\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tjava.lang.Object o = objs[i];\n\t\t\t\t\tif (o instanceof java.lang.Number)\n\t\t\t\t\t{\n\t\t\t\t\t\tjava.lang.Class curCls = null;\n\t\t\t\t\t\tif (i < allcls.length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurCls = allcls[i];\n\t\t\t\t\t\t\tif (!curCls.isAssignableFrom(o.getClass()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString name = curCls.getName();\n\t\t\t\t\t\t\t\tif (name.equals(\"double\") || name.equals(\"java.lang.Double\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).doubleValue();\n\t\t\t\t\t\t\t\t} else if (name.equals(\"int\") || name.equals(\"java.lang.Integer\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).intValue();\n\t\t\t\t\t\t\t\t} else if (name.equals(\"float\") || name.equals(\"java.lang.Float\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).floatValue();\n\t\t\t\t\t\t\t\t} else if (name.equals(\"byte\") || name.equals(\"java.lang.Byte\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).byteValue();\n\t\t\t\t\t\t\t\t} else if (name.equals(\"short\") || name.equals(\"java.lang.Short\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).shortValue();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} //else varargs not handled TODO\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\ttry {\n\t\t\tfound.setAccessible(true);\n\t\t\treturn (T) found.newInstance(objs);\n\t\t}\n\t\tcatch (java.lang.reflect.InvocationTargetException e)\n\t\t{\n\t\t\tthrow haxe.lang.HaxeException.wrap(e.getCause());\n\t\t}\n\n\t\tcatch (Throwable t)\n\t\t{\n\t\t\tthrow haxe.lang.HaxeException.wrap(t);\n\t\t}\n\t"]]></e></m></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="249" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.
		
		This function guarantees that the class constructor is not called.
		
		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="267" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (params == null || params.length == 0)\n\t\t{\n\t\t\tjava.lang.Object ret = haxe.lang.Runtime.slowGetField(e, constr, true);\n\t\t\tif (ret instanceof haxe.lang.Function)\n\t\t\t\tthrow haxe.lang.HaxeException.wrap(\"Constructor \" + constr + \" needs parameters\");\n\t\t\treturn (T) ret;\n\t\t} else {\n\t\t\treturn (T) haxe.lang.Runtime.slowCallField(e, constr, params);\n\t\t}\n\t"</e></m></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="272" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="302" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (c == java.lang.String.class)\n\t\t{\n\t\t\treturn haxe.lang.StringRefl.fields;\n\t\t}\n\n\t\tArray<String> ret = new Array<String>();\n\t\tfor (java.lang.reflect.Field f : c.getFields())\n\t\t{\n\t\t\tjava.lang.String fname = f.getName();\n\t\t\tif (!java.lang.reflect.Modifier.isStatic(f.getModifiers()) && !fname.startsWith(\"__hx_\"))\n\t\t\t\tret.push(fname);\n\t\t}\n\n\t\tfor (java.lang.reflect.Method m : c.getMethods())\n\t\t{\n\t\t\tif (m.getDeclaringClass() == java.lang.Object.class)\n\t\t\t\tcontinue;\n\t\t\tjava.lang.String mname = m.getName();\n\t\t\tif (!java.lang.reflect.Modifier.isStatic(m.getModifiers()) && !mname.startsWith(\"__hx_\"))\n\t\t\t\tret.push(mname);\n\t\t}\n\n\t\treturn ret;\n\t"]]></e></m></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`.
		
		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="332" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tArray<String> ret = new Array<String>();\n\t\tif (c == java.lang.String.class)\n\t\t{\n\t\t\tret.push(\"fromCharCode\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (java.lang.reflect.Field f : c.getDeclaredFields())\n\t\t{\n\t\t\tjava.lang.String fname = f.getName();\n\t\t\tif (java.lang.reflect.Modifier.isStatic(f.getModifiers()) && !fname.startsWith(\"__hx_\"))\n\t\t\tret.push(fname);\n\t\t}\n\n\t\tfor (java.lang.reflect.Method m : c.getDeclaredMethods())\n\t\t{\n\t\t\tif (m.getDeclaringClass() == java.lang.Object.class)\n\t\t\t\tcontinue;\n\t\t\tjava.lang.String mname = m.getName();\n\t\t\tif (java.lang.reflect.Modifier.isStatic(m.getModifiers()) && !mname.startsWith(\"__hx_\"))\n\t\t\t\tret.push(mname);\n\t\t}\n\n\t\treturn ret;\n\t"]]></e></m></meta>
			<haxe_doc>Returns a list of static fields of class `c`.
		
		This does not include static fields of parent classes.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="336" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="370" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (v == null) return ValueType.TNull;\n\n\t\tif (v instanceof haxe.lang.IHxObject) {\n\t\t\thaxe.lang.IHxObject vobj = (haxe.lang.IHxObject) v;\n\t\t\tjava.lang.Class cl = vobj.getClass();\n\t\t\tif (v instanceof haxe.lang.DynamicObject)\n\t\t\t\treturn ValueType.TObject;\n\t\t\telse\n\t\t\t\treturn ValueType.TClass(cl);\n\t\t} else if (v instanceof java.lang.Number) {\n\t\t\tjava.lang.Number n = (java.lang.Number) v;\n\t\t\tif (n.intValue() == n.doubleValue())\n\t\t\t\treturn ValueType.TInt;\n\t\t\telse\n\t\t\t\treturn ValueType.TFloat;\n\t\t} else if (v instanceof haxe.lang.Function) {\n\t\t\treturn ValueType.TFunction;\n\t\t} else if (v instanceof java.lang.Enum || v instanceof haxe.lang.Enum) {\n\t\t\treturn ValueType.TEnum(v.getClass());\n\t\t} else if (v instanceof java.lang.Boolean) {\n\t\t\treturn ValueType.TBool;\n\t\t} else if (v instanceof java.lang.Class) {\n\t\t\treturn ValueType.TObject;\n\t\t} else {\n\t\t\treturn ValueType.TClass(v.getClass());\n\t\t}\n\t"</e></m></meta>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="381" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (a instanceof haxe.lang.Enum)\n\t\t\t\treturn a.equals(b);\n\t\t\telse\n\t\t\t\treturn haxe.lang.Runtime.eq(a, b);\n\t"</e></m></meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="392" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (e instanceof java.lang.Enum)\n\t\t\treturn ((java.lang.Enum) e).name();\n\t\telse\n\t\t\treturn ((haxe.lang.Enum) e).getTag();\n\t"</e></m></meta>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="400" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn ( e instanceof java.lang.Enum ) ? new haxe.root.Array() : ((haxe.lang.Enum) e).params;\n\t"</e></m></meta>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" line="411" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (e instanceof java.lang.Enum)\n\t\t\treturn ((java.lang.Enum) e).ordinal();\n\t\telse\n\t\t\treturn ((haxe.lang.Enum) e).index;\n\t"</e></m></meta>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="416" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/java/_std/Xml.hx" module="Xml"><meta><m n=":native"><e>"_Xml.RealXmlType"</e></m></meta></enum>
	<enum path="_Xml.RealXmlType" params="" file="/usr/lib/haxe/std/java/_std/Xml.hx" private="1" module="Xml">
		<Element/>
		<PCData/>
		<CData/>
		<Comment/>
		<DocType/>
		<ProcessingInstruction/>
		<Document/>
	</enum>
	<class path="Xml" params="" file="/usr/lib/haxe/std/java/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="57" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="64" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="73" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="80" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="87" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="94" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="101" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="108" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" get="accessor" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><c path="haxe.ds.StringMap"><c path="String"/></c></_attributes>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<get_nodeName set="method" line="115"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName set="method" line="121"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue set="method" line="127"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue set="method" line="133"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get_parent set="method" line="139"><f a=""><c path="Xml"/></f></get_parent>
		<get public="1" set="method" line="143">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="149">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<remove public="1" set="method" line="155">
			<f a="att">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="161">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="167">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="173">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="187">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="219">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="254">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="259">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="272">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="279">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="287">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="294">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="61"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<typedef path="haxe._Int64.NativeInt64" params="" file="/usr/lib/haxe/std/java/_std/haxe/Int64.hx" private="1" module="haxe.Int64"><x path="Int"/></typedef>
	<class path="haxe.Int64" params="" file="/usr/lib/haxe/std/java/_std/haxe/Int64.hx">
		<asNative get="inline" set="null" line="29" static="1">
			<f a="i">
				<c path="haxe.Int64"/>
				<t path="haxe._Int64.NativeInt64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</asNative>
		<ofNative get="inline" set="null" line="30" static="1">
			<f a="i">
				<t path="haxe._Int64.NativeInt64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</ofNative>
		<mkNative get="inline" set="null" line="31" static="1">
			<f a="i">
				<d/>
				<t path="haxe._Int64.NativeInt64"/>
			</f>
			<meta><m n=":extern"/></meta>
		</mkNative>
		<make public="1" get="inline" set="null" line="33" static="1"><f a="high:low">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></make>
		<getLow public="1" get="inline" set="null" line="38" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></getLow>
		<getHigh public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></getHigh>
		<ofInt public="1" get="inline" set="null" line="48" static="1"><f a="x">
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="52" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></toInt>
		<add public="1" get="inline" set="null" line="57" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></add>
		<sub public="1" get="inline" set="null" line="62" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="67" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mul>
		<divMod set="method" line="71" static="1"><f a="modulus:divisor">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<a>
		<quotient><c path="haxe.Int64"/></quotient>
		<modulus><c path="haxe.Int64"/></modulus>
	</a>
</f></divMod>
		<div public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></div>
		<mod public="1" get="inline" set="null" line="82" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="90" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<x path="Int"/>
	<c path="haxe.Int64"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="98" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></and>
		<or public="1" get="inline" set="null" line="103" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></or>
		<xor public="1" get="inline" set="null" line="108" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="113" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="118" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<x path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="123" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<x path="Bool"/>
</f></isZero>
		<compare public="1" get="inline" set="null" line="128" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<x path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="133" static="1">
			<f a="a:b">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compare two Int64 in unsigned mode.</haxe_doc>
		</ucompare>
		<toStr public="1" get="inline" set="null" line="140" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="String"/>
</f></toStr>
		<meta>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="521" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="169"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="206"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="224">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<serializeException public="1" set="method" line="498"><f a="e">
	<d/>
	<x path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:
	
	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:
		
		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="433" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<getResolver public="1" set="method" line="139">
			<f a=""><t path="haxe.TypeResolver"/></f>
			<haxe_doc>Gets the type resolver of `this` Unserializer instance.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</getResolver>
		<get get="inline" set="null" line="143"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<unserializeObject set="method" line="172"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="187"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="219">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:
	
	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<encode public="1" set="method" line="127" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="132" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<encodeString public="1" set="method" line="111"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encodeString>
		<decodeString public="1" set="method" line="119"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decodeString>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionnary.</haxe_doc>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/lib/haxe/std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="26" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<make public="1" set="method" line="36" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<str2blks set="method" line="104" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bytes2blks set="method" line="121" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="58"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<rol get="inline" set="null" line="141">
			<f a="num:cnt">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Bitwise rotate a 32-bit number to the left</haxe_doc>
		</rol>
		<ft set="method" line="148">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="158">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<hex set="method" line="168"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.
		
		If `key` is already bound to a value, that binding disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.
		
		If `key` is not bound to any value, `null` is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.
		
		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.
		
		Otherwise the binding of `key` is removed and true is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.
		
		This method returns true even if `key` is bound to null.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="115">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="126">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</keys>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<iteratorLoop set="method" line="153"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<keysLoop set="method" line="161"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="205"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.
	
	Operations have a logarithmic average and worst-case cost.
	
	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="231">
			<f a=""><x path="Int"/></f>
			<meta><m n=":extern"/></meta>
		</get_height>
		<toString public="1" set="method" line="233"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.
	
	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
	<_new public="1" set="method" line="25" static="1">
		<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<set public="1" get="inline" set="null" line="28" static="1">
		<f a="this:k:v">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<c path="haxe.ds.HashMap.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="32" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
	<exists public="1" get="inline" set="null" line="35" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</exists>
	<remove public="1" get="inline" set="null" line="38" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<keys public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</keys>
	<iterator public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
</class></impl>
	</abstract>
	<class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
		<_new public="1" set="method" line="25" static="1">
			<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<set public="1" get="inline" set="null" line="28" static="1">
			<f a="this:k:v">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="32" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
		<exists public="1" get="inline" set="null" line="35" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</exists>
		<remove public="1" get="inline" set="null" line="38" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<keys public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</keys>
		<iterator public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/java/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="36" static="1"><x path="Float"/></HASH_UPPER>
		<assert get="inline" set="null" line="401" static="1"><f a="x">
	<x path="Bool"/>
	<x path="Void"/>
</f></assert>
		<defaultK get="inline" set="null" line="408" static="1"><f a=""><x path="Int"/></f></defaultK>
		<arrayCopy get="inline" set="null" line="410" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<d/>
	<x path="Int"/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arrayCopy>
		<getInc get="inline" set="null" line="413" static="1"><f a="k:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInc>
		<hash get="inline" set="null" line="416" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<flagIsEmpty get="inline" set="null" line="419" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></flagIsEmpty>
		<flagIsDel get="inline" set="null" line="422" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></flagIsDel>
		<isEither get="inline" set="null" line="425" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></isEither>
		<setIsDelFalse get="inline" set="null" line="428" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsDelFalse>
		<setIsEmptyFalse get="inline" set="null" line="431" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsEmptyFalse>
		<setIsBothFalse get="inline" set="null" line="434" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsBothFalse>
		<setIsDelTrue get="inline" set="null" line="437" static="1"><f a="flag:i">
	<c path="java.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsDelTrue>
		<roundUp get="inline" set="null" line="440" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></roundUp>
		<flagsSize get="inline" set="null" line="451" static="1"><f a="m">
	<x path="Int"/>
	<x path="Int"/>
</f></flagsSize>
		<flags><c path="java.NativeArray"><x path="Int"/></c></flags>
		<_keys><c path="java.NativeArray"><x path="Int"/></c></_keys>
		<vals><c path="java.NativeArray"><c path="haxe.ds.IntMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><x path="Int"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="55">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="111">
			<f a="key">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<get public="1" set="method" line="133">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="153"><f a="key:def">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
	<c path="haxe.ds.IntMap.T"/>
</f></getDefault>
		<exists public="1" set="method" line="173">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="193">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<resize set="method" line="221">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":final"/></meta>
		</resize>
		<keys public="1" set="method" line="327">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="358">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="386">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/java/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":extern"/></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="425" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</roundUp>
		<getInc get="inline" set="null" line="436" static="1">
			<f a="k:mask">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInc>
		<isEither get="inline" set="null" line="439" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEither>
		<isEmpty get="inline" set="null" line="442" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEmpty>
		<isDel get="inline" set="null" line="445" static="1">
			<f a="v">
				<t path="haxe.ds._ObjectMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isDel>
		<hash get="inline" set="null" line="449" static="1">
			<f a="s">
				<d/>
				<t path="haxe.ds._ObjectMap.HashType"/>
			</f>
			<meta><m n=":extern"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="477" static="1">
			<f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
				<d/>
				<x path="Int"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</arrayCopy>
		<assert get="inline" set="null" line="480" static="1">
			<f a="x">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</assert>
		<hashes>
			<c path="java.NativeArray"><t path="haxe.ds._ObjectMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="java.NativeArray"><c path="haxe.ds.ObjectMap.K"/></c></_keys>
		<vals><c path="java.NativeArray"><c path="haxe.ds.ObjectMap.V"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="haxe.ds.ObjectMap.K"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="64">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="129">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<resize set="method" line="160">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":final"/>
				<m n=":private"/>
			</meta>
		</resize>
		<get public="1" set="method" line="263">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="283"><f a="key:def">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
	<c path="haxe.ds.ObjectMap.V"/>
</f></getDefault>
		<exists public="1" set="method" line="303">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="323">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="351">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="382">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="410">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.
	
	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="haxe.ds._ObjectMap.HashType" params="" file="/usr/lib/haxe/std/java/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap"><x path="Int"/></typedef>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/java/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<HASH_UPPER get="inline" set="null" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":extern"/></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":extern"/></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="425" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</roundUp>
		<getInc get="inline" set="null" line="436" static="1">
			<f a="k:mask">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInc>
		<isEither get="inline" set="null" line="439" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEither>
		<isEmpty get="inline" set="null" line="442" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isEmpty>
		<isDel get="inline" set="null" line="445" static="1">
			<f a="v">
				<t path="haxe.ds._StringMap.HashType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":extern"/></meta>
		</isDel>
		<hash get="inline" set="null" line="449" static="1">
			<f a="s">
				<c path="String"/>
				<t path="haxe.ds._StringMap.HashType"/>
			</f>
			<meta><m n=":extern"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="477" static="1">
			<f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
				<d/>
				<x path="Int"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</arrayCopy>
		<assert get="inline" set="null" line="480" static="1">
			<f a="x">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</assert>
		<hashes>
			<c path="java.NativeArray"><t path="haxe.ds._StringMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="java.NativeArray"><c path="String"/></c></_keys>
		<vals><c path="java.NativeArray"><c path="haxe.ds.StringMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="String"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="64">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup set="method" line="129">
			<f a="key">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":final"/></meta>
		</lookup>
		<resize set="method" line="160">
			<f a="newNBuckets">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":final"/>
				<m n=":private"/>
			</meta>
		</resize>
		<get public="1" set="method" line="263">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<getDefault set="method" line="283"><f a="key:def">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
	<c path="haxe.ds.StringMap.T"/>
</f></getDefault>
		<exists public="1" set="method" line="303">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="323">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="351">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="382">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.
		Implementation detail: Do not set() any new value while iterating, as it may cause a resize, which will break iteration</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="410">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<new public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="haxe.ds._StringMap.HashType" params="" file="/usr/lib/haxe/std/java/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap"><x path="Int"/></typedef>
	<class path="haxe.ds.WeakMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/WeakMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.WeakMap.K"/>
			<c path="haxe.ds.WeakMap.V"/>
		</implements>
		<set public="1" set="method" line="44">
			<f a="key:value">
				<c path="haxe.ds.WeakMap.K"/>
				<c path="haxe.ds.WeakMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="50">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<t path="Null"><c path="haxe.ds.WeakMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="57">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="85">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new WeakMap.</haxe_doc>
		</new>
		<haxe_doc>WeakMap allows mapping of object keys to arbitrary values.
	
	The keys are considered to be weak references on static targets.
	
	See `Map` for documentation details.</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="250" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="275" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="324" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<fastGet public="1" get="inline" set="null" line="342" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="34"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="50"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method" line="68"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<sub public="1" set="method" line="99"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="125"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<readString public="1" set="method" line="163"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="211"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="232"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="246"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="java.io.ByteArrayOutputStream"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="63"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" get="inline" set="null" line="75"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="93"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="112"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="138">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="java.NativeArray"><x path="java.Int8"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<helper><c path="java.nio.ByteBuffer"/></helper>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="77"><f a="?bufsize">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="119"><f a="end">
	<x path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="144"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="198"><f a=""><x path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="271"><f a=""><x path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="278"><f a=""><x path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="287"><f a=""><x path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="293"><f a=""><x path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="303"><f a=""><x path="Int"/></f></readUInt24>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readString public="1" set="method" line="318"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_position get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_position>
		<get_length get="inline" set="null" line="68"><f a=""><x path="Int"/></f></get_length>
		<set_position set="method" line="76"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="84" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="105" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<LN2 line="31" static="1"><x path="Float"/></LN2>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<helper><c path="java.nio.ByteBuffer"/></helper>
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="65"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="71"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="78"><f a="s">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="97"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="151"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="228"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="234"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="239"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="250"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="255"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt24>
		<writeInt32 public="1" set="method" line="268"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="288">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="291"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CInt a="v"><c path="String"/></CInt>
		<CFloat a="f"><c path="String"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<CIdent a="s"><c path="String"/></CIdent>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd/>
		<OpMult/>
		<OpDiv/>
		<OpSub/>
		<OpAssign/>
		<OpEq/>
		<OpNotEq/>
		<OpGt/>
		<OpGte/>
		<OpLt/>
		<OpLte/>
		<OpAnd/>
		<OpOr/>
		<OpXor/>
		<OpBoolAnd/>
		<OpBoolOr/>
		<OpShl/>
		<OpShr/>
		<OpUShr/>
		<OpMod/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpInterval/>
		<OpArrow/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement/>
		<OpDecrement/>
		<OpNot/>
		<OpNeg/>
		<OpNegBits/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<x path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EVars a="vars"><c path="Array"><t path="haxe.macro.Var"/></c></EVars>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Case"/></c>
			<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		</ESwitch>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Catch"/></c>
		</ETry>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EBreak/>
		<EContinue/>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EDisplay>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<EMeta a="s:e">
			<t path="haxe.macro.MetadataEntry"/>
			<t path="haxe.macro.Expr"/>
		</EMeta>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><x path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<APublic/>
		<APrivate/>
		<AStatic/>
		<AOverride/>
		<ADynamic/>
		<AInline/>
		<AMacro/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
		<FProp a="get:set:?t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><x path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDEnum/>
		<TDStructure/>
		<TDClass a="?superClass:?interfaces:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<x path="Bool"/>
		</TDClass>
		<TDAlias a="t"><e path="haxe.macro.ComplexType"/></TDAlias>
		<TDAbstract a="tthis:?from:?to">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		</TDAbstract>
	</enum>
	<class path="haxe.macro.Error" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<message public="1"><c path="String"/></message>
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<toString set="method" line="239"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="235"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<class path="haxe.remoting.AsyncConnection" params="" file="/usr/lib/haxe/std/haxe/remoting/AsyncConnection.hx" interface="1">
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method"><f a="params:?result">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method"><f a="error">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.remoting.Context" params="" file="/usr/lib/haxe/std/haxe/remoting/Context.hx">
		<share public="1" set="method" line="55" static="1"><f a="name:obj">
	<c path="String"/>
	<a/>
	<c path="haxe.remoting.Context"/>
</f></share>
		<objects><c path="haxe.ds.StringMap"><a>
	<rec><x path="Bool"/></rec>
	<obj><d/></obj>
</a></c></objects>
		<addObject public="1" set="method" line="32"><f a="name:obj:?recursive">
	<c path="String"/>
	<a/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addObject>
		<call public="1" set="method" line="36"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="/usr/lib/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></TAG_NAME>
		<BODY public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></CHILDS>
		<CLOSE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></CLOSE>
		<WAIT_END public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></PCDATA>
		<HEADER public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></HEADER>
		<COMMENT public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></COMMENT>
		<DOCTYPE public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DOCTYPE>
		<CDATA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></CDATA>
		<ESCAPE public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></ESCAPE>
	</class>
	<class path="haxe.xml.Parser" params="" file="/usr/lib/haxe/std/haxe/xml/Parser.hx">
		<escapes line="51" static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></escapes>
		<parse public="1" set="method" line="62" static="1"><f a="str">
	<c path="String"/>
	<c path="Xml"/>
</f></parse>
		<doParse set="method" line="69" static="1"><f a="str:?p:?parent">
	<c path="String"/>
	<x path="Int"/>
	<c path="Xml"/>
	<x path="Int"/>
</f></doParse>
		<isValidChar get="inline" set="null" line="343" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
	</class>
	<class path="jabber.Attention" params="" file="../../jabber/Attention.hx">
		<capture public="1" set="method" line="33" static="1">
			<f a="stream:jid:message">
				<c path="jabber.Stream"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends a message packet to the given entity inluding a property to get attention</haxe_doc>
		</capture>
		<haxe_doc>Extension for getting the attention of another user.
	XEP 224 - Attention: http://www.xmpp.org/extensions/xep-0224.html</haxe_doc>
	</class>
	<class path="jabber.EntityCapabilities" params="" file="../../jabber/EntityCapabilities.hx">
		<onCaps public="1" set="dynamic" line="34">
			<f a="jid:caps:cb">
				<c path="String"/>
				<c path="xmpp.Caps"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback to application for checking if caps already exist (in cache)</haxe_doc>
		</onCaps>
		<onInfo public="1" set="dynamic" line="37">
			<f a="jid:info:?ver">
				<c path="String"/>
				<c path="xmpp.disco.Info"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fired when a new entity capability got discovered</haxe_doc>
		</onInfo>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<node public="1" set="null">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application,
		typically a URL at the website of the project or company that produces the software</haxe_doc>
		</node>
		<ver public="1" set="null">
			<c path="String"/>
			<haxe_doc>My own verification string</haxe_doc>
		</ver>
		<collector><c path="jabber.PacketCollector"/></collector>
		<x><c path="Xml"/></x>
		<createVerificationString public="1" set="method" line="80">
			<f a="identities:features:?dataform">
				<c path="Array"><t path="xmpp.disco.Identity"/></c>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create/Recreate the verification string
		Call if your stream changes features</haxe_doc>
		</createVerificationString>
		<interceptPacket public="1" set="method" line="84"><f a="p">
	<c path="xmpp.Packet"/>
	<c path="xmpp.Packet"/>
</f></interceptPacket>
		<dispose public="1" set="method" line="100"><f a=""><x path="Void"/></f></dispose>
		<handlePresence set="method" line="105"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<handleInfoResponse set="method" line="114"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoResponse>
		<requestDiscoInfo set="method" line="131"><f a="jid:?node">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></requestDiscoInfo>
		<new public="1" set="method" line="57"><f a="stream:node:identities:?ext">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for broadcasting and dynamically discovering client, device, or generic entity capabilities.

	XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="jabber.EntityTime" params="" file="../../jabber/EntityTime.hx">
		<onLoad public="1" set="dynamic" line="31"><f a="jid:t">
	<c path="String"/>
	<c path="xmpp.EntityTime"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request the local time of another jabber entity.</haxe_doc>
		</load>
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<new public="1" set="method" line="36"><f a="s">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for requesting the local time of an entity.

	XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.EntityTimeListener" params="" file="../../jabber/EntityTimeListener.hx">
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<time public="1" set="null"><c path="xmpp.EntityTime"/></time>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<handleRequest set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<new public="1" set="method" line="36"><f a="stream:?tzo">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers entity time requests.

	XEP 202 - EntityTime http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.JID" params="" file="../../jabber/JID.hx">
		<node public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</node>
		<domain public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</domain>
		<resource public="1">
			<c path="String"/>
			<haxe_doc>Resourcepart, uniquely identifies a specific connection (e.g., a device or location)</haxe_doc>
		</resource>
		<bare public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>JID without resource</haxe_doc>
		</bare>
		<s public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Just a shortcut for toString()</haxe_doc>
		</s>
		<get_bare set="method" line="65"><f a=""><c path="String"/></f></get_bare>
		<get_s get="inline" set="null" line="69"><f a=""><c path="String"/></f></get_s>
		<copy public="1" set="method" line="71"><f a=""><c path="jabber.JID"/></f></copy>
		<toString public="1" set="method" line="79"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="55"><f a="?t">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Unique Jabber-ID.

	A JID is made up of a node (generally a username), a domain, and a resource.

		jid             = [ node "@" ] domain [ "/" resource ]
		domain          = fqdn / address-literal
		fqdn            = (sub-domain 1*("." sub-domain))
		sub-domain      = (internationalized domain label)
		address-literal = IPv4address / IPv6address

	Each allowable portion of a JID (node, domain, and resource) must not be more than 1023 bytes in length,
	resulting in a maximum total size (including the '@' and '/' separators) of 3071 bytes.</haxe_doc>
	</class>
	<class path="java.io.Serializable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Serializable.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.io.Serializable"</e></m>
</meta></class>
	<class path="java.util.regex.Pattern" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern.class" extern="1">
		<implements path="java.io.Serializable"/>
		<_compile public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.regex.Pattern"/>
			</f>
			<meta>
				<m n=":native"><e>"compile"</e></m>
				<m n=":overload"/>
			</meta>
			<overloads><_compile public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<x path="Int"/>
		<c path="java.util.regex.Pattern"/>
	</f>
	<meta>
		<m n=":native"><e>"compile"</e></m>
		<m n=":overload"/>
	</meta>
</_compile></overloads>
		</_compile>
		<matches public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.lang.CharSequence"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</matches>
		<quote public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</quote>
		<UNICODE_CHARACTER_CLASS public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</UNICODE_CHARACTER_CLASS>
		<CANON_EQ public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</CANON_EQ>
		<UNICODE_CASE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</UNICODE_CASE>
		<DOTALL public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</DOTALL>
		<LITERAL public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</LITERAL>
		<MULTILINE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MULTILINE>
		<COMMENTS public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</COMMENTS>
		<CASE_INSENSITIVE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</CASE_INSENSITIVE>
		<UNIX_LINES public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</UNIX_LINES>
		<pattern public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</pattern>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<matcher public="1" set="method">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</matcher>
		<flags public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</flags>
		<split public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.CharSequence"/>
				<x path="Int"/>
				<c path="java.NativeArray"><c path="String"/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><split public="1" set="method">
	<f a="param1">
		<c path="java.lang.CharSequence"/>
		<c path="java.NativeArray"><c path="String"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</split></overloads>
		</split>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern"</e></m>
		</meta>
	</class>
	<class path="jabber.JIDUtil" params="" file="../../jabber/JIDUtil.hx">
		<MIN_LENGTH public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></MIN_LENGTH>
		<MAX_PARTSIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_PARTSIZE>
		<MAX_SIZE public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></MAX_SIZE>
		<EREG public="1" line="38" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid JID</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="57" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID is valid formed.</haxe_doc>
		</isValid>
		<node public="1" get="inline" set="null" line="74" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The node of the given JID.</haxe_doc>
		</node>
		<domain public="1" set="method" line="81" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The domain of the given JID.</haxe_doc>
		</domain>
		<resource public="1" set="method" line="90" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The resource of the given JID.</haxe_doc>
		</resource>
		<bare public="1" set="method" line="98" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes The resource from a JID.</haxe_doc>
		</bare>
		<hasResource public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID has a valid resource.</haxe_doc>
		</hasResource>
		<parts public="1" set="method" line="113" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>@returns A String array with parsed node, domain and resource.</haxe_doc>
		</parts>
		<splitBare public="1" set="method" line="122" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits the given JID into parts and returns it as array excluding the resource.</haxe_doc>
		</splitBare>
		<compare public="1" set="method" line="130" static="1">
			<f a="a:b">
				<c path="jabber.JID"/>
				<c path="jabber.JID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</compare>
		<escapeNode public="1" set="method" line="145" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escapes the node portion of a JID according to "JID Escaping" (XEP-0106).
	    Escaping replaces characters prohibited by node-prep with escape sequences.

	    Typically, escaping is performed only by a client that is processing information
	    provided by a human user in unescaped form, or by a gateway to some external system
	    (e.g., email or LDAP) that needs to generate a JID.</haxe_doc>
		</escapeNode>
		<unescapeNode public="1" set="method" line="169" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Un-escapes the node portion of a JID according to XEP-0106:JID Escaping (http://www.xmpp.org/extensions/xep-0106.html).
     	Escaping replaces characters prohibited by node-prep with escape sequences.

     	Typically, unescaping is performed only by a client that wants to display JIDs
     	containing escaped characters to a human user, or by a gateway to some
     	external system (e.g., email or LDAP) that needs to generate identifiers
     	for foreign systems.</haxe_doc>
		</unescapeNode>
		<haxe_doc>Static methods for jabber-id validation and manipulation.</haxe_doc>
	</class>
	<class path="jabber.LastActivity" params="" file="../../jabber/LastActivity.hx">
		<onLoad public="1" set="dynamic" line="29"><f a="entity:secs">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<request public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Requests the given entity for their last activity.<br/>
		Given a bare jid will be handled by the server on roster subscription basis.<br/>
		Otherwise the request will be fowarded to the resource of the client entity.<br/>]]></haxe_doc>
		</request>
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.LastActivityListener" params="" file="../../jabber/LastActivityListener.hx">
		<time public="1">
			<x path="Int"/>
			<haxe_doc>Seconds passed after last user activity</haxe_doc>
		</time>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="43"><f a=""><x path="Void"/></f></dispose>
		<handleRequest set="method" line="51"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<new public="1" set="method" line="35"><f a="stream:?time">
	<c path="jabber.Stream"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.MUCUtil" params="" file="../../jabber/MUCUtil.hx">
		<EREG public="1" line="30" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid MUC address</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="36" static="1">
			<f a="t:?nick">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given string is a valid muchat address.
		The 'nick' parameter indicates if a full adress (including nickname) is expected.</haxe_doc>
		</isValid>
		<getRoom public="1" get="inline" set="null" line="45" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the room of the muc jid.</haxe_doc>
		</getRoom>
		<getHost public="1" get="inline" set="null" line="52" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the host of the muc jid.</haxe_doc>
		</getHost>
		<getNick public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the occupant name of the muc jid.</haxe_doc>
		</getNick>
		<getParts public="1" set="method" line="67" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns array existing of roomname[0], host[1] and (optional) occupantname[2] of the given muc address.</haxe_doc>
		</getParts>
		<haxe_doc>Static methods for parsing of mutliuser chat addresses.</haxe_doc>
	</class>
	<class path="jabber.PacketListener" params="T" file="../../jabber/PacketListener.hx">
		<onPacket public="1" set="dynamic" line="30">
			<f a="p">
				<c path="jabber.PacketListener.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Packet recieved callback</haxe_doc>
		</onPacket>
		<listen public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Activates/Deactivates packet collecting</haxe_doc>
		</listen>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<collector><c path="jabber.PacketCollector"/></collector>
		<set_listen set="method" line="47"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_listen>
		<handlePacket set="method" line="53"><f a="p">
	<c path="jabber.PacketListener.T"/>
	<x path="Void"/>
</f></handlePacket>
		<new set="method" line="38"><f a="stream:handler:type:listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="jabber.PacketListener.T"/>
		<x path="Void"/>
	</f>
	<e path="xmpp.PacketType"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for top level packet listeners (jabber.PresenceListener, jabber.MessageListener).</haxe_doc>
	</class>
	<class path="jabber.MessageListener" params="" file="../../jabber/MessageListener.hx">
		<extends path="jabber.PacketListener"><c path="xmpp.Message"/></extends>
		<new public="1" set="method" line="34"><f a="stream:handler:?listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="xmpp.Message"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Utility (shortcut) to listen/report incoming message packets.

	Usage:
	var l = new MessageListener( stream, function(m){
		trace("Received message: "+m);
	});</haxe_doc>
	</class>
	<class path="jabber.PacketCollector" params="" file="../../jabber/PacketCollector.hx">
		<filters public="1" set="null">
			<c path="jabber._PacketCollector.FilterList"/>
			<haxe_doc>This collectors filters</haxe_doc>
		</filters>
		<handlers public="1">
			<c path="Array"><f a="">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></c>
			<haxe_doc>Callbacks to which collected packets get delivered to.</haxe_doc>
		</handlers>
		<permanent public="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the the collector should get removed from the stream after collecting.</haxe_doc>
		</permanent>
		<block public="1">
			<x path="Bool"/>
			<haxe_doc>Block remaining collectors</haxe_doc>
		</block>
		<accept public="1" set="method" line="58">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given XMPP packet passes through all filters.</haxe_doc>
		</accept>
		<deliver public="1" set="method" line="68">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Delivers the given packet to all registerd handlers.</haxe_doc>
		</deliver>
		<new public="1" set="method" line="44"><f a="filters:handler:?permanent:?block">
	<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Default XMPP packet collector implementation.</haxe_doc>
	</class>
	<class path="jabber._PacketCollector.FilterList" params="" file="../../jabber/PacketCollector.hx" private="1" module="jabber.PacketCollector">
		<fid><c path="Array"><t path="xmpp.PacketFilter"/></c></fid>
		<f><c path="Array"><t path="xmpp.PacketFilter"/></c></f>
		<clear public="1" get="inline" set="null" line="83"><f a=""><x path="Void"/></f></clear>
		<iterator public="1" get="inline" set="null" line="88"><f a=""><t path="Iterator"><t path="xmpp.PacketFilter"/></t></f></iterator>
		<addIDFilter public="1" get="inline" set="null" line="92"><f a="_f">
	<c path="xmpp.filter.PacketIDFilter"/>
	<x path="Void"/>
</f></addIDFilter>
		<addFilter public="1" get="inline" set="null" line="96"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></addFilter>
		<push public="1" get="inline" set="null" line="100"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></push>
		<unshift public="1" get="inline" set="null" line="104"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></unshift>
		<remove public="1" get="inline" set="null" line="108"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Bool"/>
</f></remove>
		<new public="1" set="method" line="79"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="jabber.PacketInterceptor" params="" file="../../jabber/PacketInterceptor.hx">
		<a><interceptPacket set="method">
	<f a="p">
		<c path="xmpp.Packet"/>
		<c path="xmpp.Packet"/>
	</f>
	<haxe_doc>Intercepts outgoing XMPP packet before sending.</haxe_doc>
</interceptPacket></a>
		<haxe_doc>Modifies XMPP packets and/or runs additional processes before sending.</haxe_doc>
	</typedef>
	<class path="jabber.PersonalEvent" params="" file="../../jabber/PersonalEvent.hx">
		<onPublish public="1" set="dynamic" line="31"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onPublish>
		<onDisable public="1" set="dynamic" line="32"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onDisable>
		<onError public="1" set="dynamic" line="33"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<publish public="1" set="method" line="45">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Publish a personal event.</haxe_doc>
		</publish>
		<disable public="1" set="method" line="54">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disable publishing.</haxe_doc>
		</disable>
		<sendIQ set="method" line="58"><f a="e:x:h">
	<c path="xmpp.PersonalEvent"/>
	<c path="Xml"/>
	<f a="">
		<c path="xmpp.PersonalEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<new public="1" set="method" line="38"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Send personal updates or "events" to other users, who are typically contacts in the user's roster.
	
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<typedef path="jabber._PersonalEventListener.Listener" params="" file="../../jabber/PersonalEventListener.hx" private="1" module="jabber.PersonalEventListener"><a>
	<xmlns><c path="String"/></xmlns>
	<type><x path="Class"><c path="xmpp.PersonalEvent"/></x></type>
	<handler><f a=":">
	<c path="xmpp.Message"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></handler>
</a></typedef>
	<class path="jabber.PersonalEventListener" params="" file="../../jabber/PersonalEventListener.hx">
		<stream public="1" set="null">
			<c path="jabber.Stream"/>
			<haxe_doc>Optional to collect ALL events</haxe_doc>
		</stream>
		<listeners><c path="List"><t path="jabber._PersonalEventListener.Listener"/></c></listeners>
		<iterator public="1" get="inline" set="null" line="52"><f a=""><t path="Iterator"><t path="jabber._PersonalEventListener.Listener"/></t></f></iterator>
		<add public="1" set="method" line="59">
			<f a="t:h">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<f a=":">
					<c path="xmpp.Message"/>
					<c path="Xml"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add listener for the given type.</haxe_doc>
		</add>
		<remove public="1" set="method" line="76">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove listener for the given type.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clear all listeners.</haxe_doc>
		</clear>
		<getListener public="1" set="method" line="93">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<t path="jabber._PersonalEventListener.Listener"/>
			</f>
			<haxe_doc>Returns the listeners for the given type.</haxe_doc>
		</getListener>
		<handlePersonalEvent set="method" line="100"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePersonalEvent>
		<new public="1" set="method" line="44"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listener for incoming personal events from other entities.
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<class path="jabber.Pong" params="" file="../../jabber/Pong.hx">
		<onPong public="1" set="dynamic" line="31">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Informational callback on ping-pong</haxe_doc>
		</onPong>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<handlePing set="method" line="52"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<new public="1" set="method" line="37"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming ping messages and automaticly responds with a pong.
	XEP 199 - XMPP Ping: http://www.xmpp.org/extensions/xep-0199.html</haxe_doc>
	</class>
	<class path="jabber.PrivacyLists" params="" file="../../jabber/PrivacyLists.hx">
		<onLists public="1" set="dynamic" line="32"><f a="l">
	<c path="xmpp.PrivacyLists"/>
	<x path="Void"/>
</f></onLists>
		<onInfo public="1" set="dynamic" line="33"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onInfo>
		<onUpdate public="1" set="dynamic" line="34"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onUpdate>
		<onRemoved public="1" set="dynamic" line="35"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onRemoved>
		<onActivate public="1" set="dynamic" line="36"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onActivate>
		<onDeactivate public="1" set="dynamic" line="37"><f a=""><x path="Void"/></f></onDeactivate>
		<onDefaultChange public="1" set="dynamic" line="38"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onDefaultChange>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<loadLists public="1" set="method" line="53"><f a=""><x path="Void"/></f></loadLists>
		<load public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></load>
		<activate public="1" set="method" line="69"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></activate>
		<deactivate public="1" set="method" line="77"><f a=""><x path="Void"/></f></deactivate>
		<changeDefault public="1" set="method" line="84"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></changeDefault>
		<update public="1" set="method" line="101"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></update>
		<add public="1" set="method" line="105"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="109"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<_update set="method" line="118"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></_update>
		<sendRequest set="method" line="126"><f a="iqType:resultHandler:?active:?_default:?list">
	<e path="xmpp.IQType"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></sendRequest>
		<handleListPush set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleListPush>
		<new public="1" set="method" line="43"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for blocking communication with unknown or undesirable entities.
	Depricated! Use jabber.ComBlock instead.

	XEP-0016: Privacy Lists: http://xmpp.org/extensions/xep-0016.html</haxe_doc>
	</class>
	<class path="jabber.PrivateStorage" params="" file="../../jabber/PrivateStorage.hx">
		<onLoad public="1" set="dynamic" line="30"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onLoad>
		<onStored public="1" set="dynamic" line="31"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onStored>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="43">
			<f a="name:namespace">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Load private data.</haxe_doc>
		</load>
		<store public="1" set="method" line="59">
			<f a="name:namespace:data">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store private data.</haxe_doc>
		</store>
		<new public="1" set="method" line="36"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension to store any arbitrary XML on the server side.
	XEP-0049: Private XML Storage: http://xmpp.org/extensions/xep-0049.html</haxe_doc>
	</class>
	<class path="jabber.PubSub" params="" file="../../jabber/PubSub.hx">
		<onError public="1" set="dynamic" line="34"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onNodeCreate public="1" set="dynamic" line="35"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeCreate>
		<onNodeDelete public="1" set="dynamic" line="37"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeDelete>
		<onSubscriptions public="1" set="dynamic" line="38"><f a="subs">
	<c path="xmpp.pubsub.Subscriptions"/>
	<x path="Void"/>
</f></onSubscriptions>
		<onSubscribe public="1" set="dynamic" line="39"><f a="sub">
	<c path="xmpp.pubsub.Subscription"/>
	<x path="Void"/>
</f></onSubscribe>
		<onUnsubscribe public="1" set="dynamic" line="40"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onUnsubscribe>
		<onPublish public="1" set="dynamic" line="41"><f a="node:item">
	<c path="String"/>
	<c path="xmpp.pubsub.Item"/>
	<x path="Void"/>
</f></onPublish>
		<onItems public="1" set="dynamic" line="42"><f a="items">
	<c path="xmpp.pubsub.Items"/>
	<x path="Void"/>
</f></onItems>
		<onAffiliations public="1" set="dynamic" line="43"><f a="a">
	<c path="xmpp.pubsub.Affiliations"/>
	<x path="Void"/>
</f></onAffiliations>
		<onRetract public="1" set="dynamic" line="44"><f a="r">
	<c path="xmpp.pubsub.Retract"/>
	<x path="Void"/>
</f></onRetract>
		<onPurge public="1" set="dynamic" line="45"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onPurge>
		<service public="1" set="null">
			<c path="String"/>
			<haxe_doc>Name of the pubsub service</haxe_doc>
		</service>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<createNode public="1" set="method" line="59">
			<f a="name:?config">
				<c path="String"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Create a pubsub node with the given name (http://xmpp.org/extensions/xep-0060.html#owner-create).</haxe_doc>
		</createNode>
		<deleteNode public="1" set="method" line="73">
			<f a="name">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Delete pubsub node with given name (http://xmpp.org/extensions/xep-0060.html#owner-delete")</haxe_doc>
		</deleteNode>
		<loadSubscriptions public="1" set="method" line="104">
			<f a="?node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load list of current subscriptions.</haxe_doc>
		</loadSubscriptions>
		<subscribe public="1" set="method" line="123">
			<f a="node:?jid">
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc><![CDATA[Subscribe to given pubsub node.
		The 'jid' attribute specifying the exact XMPP address to be used as the subscribed JID.
		Often a bare JID (<localpart@domain.tld> or <domain.tld>)
		or full JID <localpart@domain.tld/resource>
		or <domain.tld/resource>.]]></haxe_doc>
		</subscribe>
		<unsubscribe public="1" set="method" line="141">
			<f a="node:?jid:?subid">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Unsubscribe from given pubsub node.</haxe_doc>
		</unsubscribe>
		<loadAffiliations public="1" set="method" line="170">
			<f a=""><c path="xmpp.IQ"/></f>
			<haxe_doc>Load list of affiliations for all nodes at the service.</haxe_doc>
		</loadAffiliations>
		<loadItems public="1" set="method" line="186">
			<f a="node:?subid:?maxItems:?ids">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load (all) items from the given node.</haxe_doc>
		</loadItems>
		<retract public="1" set="method" line="210">
			<f a="retract">
				<c path="xmpp.pubsub.Retract"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publisher deletes an item once it has been published to a node that supports persistent items.</haxe_doc>
		</retract>
		<purge public="1" set="method" line="226">
			<f a="node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Remove all items from the persistent store, with the exception of the last published item, which MAY be cached.
		(This is a optional feature for a pubsub service).</haxe_doc>
		</purge>
		<publish public="1" set="method" line="241">
			<f a="node:item:?options">
				<c path="String"/>
				<c path="xmpp.pubsub.Item"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publish an item to a node.</haxe_doc>
		</publish>
		<sendIQ set="method" line="264"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="xmpp.IQ"/>
</f></sendIQ>
		<new public="1" set="method" line="51"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[PubSub client extension.

	http://xmpp.org/extensions/xep-0060.html">XEP-0060: Publish-Subscribe]]></haxe_doc>
	</class>
	<class path="jabber.PubSubListener" params="" file="../../jabber/PubSubListener.hx">
		<onMessage public="1" set="dynamic" line="31">
			<f a="m">
				<c path="xmpp.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Every(!) full pubsub event message</haxe_doc>
		</onMessage>
		<onItems public="1" set="dynamic" line="36">
			<f a="service:items">
				<c path="String"/>
				<c path="xmpp.pubsub.Items"/>
				<x path="Void"/>
			</f>
			<haxe_doc>New pubsub item(s) recieved</haxe_doc>
		</onItems>
		<onConfig public="1" set="dynamic" line="38">
			<f a="service:config">
				<c path="String"/>
				<a>
					<node><c path="String"/></node>
					<form><c path="xmpp.DataForm"/></form>
				</a>
				<x path="Void"/>
			</f>
			<haxe_doc>Configuration got changed</haxe_doc>
		</onConfig>
		<onDelete public="1" set="dynamic" line="40">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got deleted</haxe_doc>
		</onDelete>
		<onPurge public="1" set="dynamic" line="42">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got purged</haxe_doc>
		</onPurge>
		<onSubscription public="1" set="dynamic" line="44">
			<f a="service:subscription">
				<c path="String"/>
				<c path="xmpp.pubsub.Subscription"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscription action notification</haxe_doc>
		</onSubscription>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="58"><f a=""><x path="Void"/></f></dispose>
		<handlePubSubEvent set="method" line="62"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePubSubEvent>
		<new public="1" set="method" line="50"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming pubsub events from a given service.
	XEP-0060: Publish-Subscribe: http://xmpp.org/extensions/xep-0060.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscovery" params="" file="../../jabber/ServiceDiscovery.hx">
		<onInfo public="1" set="dynamic" line="39"><f a="jid:info">
	<c path="String"/>
	<c path="xmpp.disco.Info"/>
	<x path="Void"/>
</f></onInfo>
		<onItems public="1" set="dynamic" line="40"><f a="jid:items">
	<c path="String"/>
	<c path="xmpp.disco.Items"/>
	<x path="Void"/>
</f></onItems>
		<onError public="1" set="dynamic" line="41"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<info public="1" set="method" line="52">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for information.</haxe_doc>
		</info>
		<items public="1" set="method" line="65">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for items.</haxe_doc>
		</items>
		<handleInfo set="method" line="75"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfo>
		<handleItems set="method" line="99"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItems>
		<new public="1" set="method" line="45"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages discovery of services from XMPP entities.
	Two kinds of information can be discovered:
		The identity and capabilities of an entity, including the protocols and features it supports.
		The items associated with an entity, such as the list of rooms hosted at a multi-user chat service.

	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscoveryListener" params="" file="../../jabber/ServiceDiscoveryListener.hx">
		<defaultIdentity public="1" line="33" static="1"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></defaultIdentity>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<onInfoQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom info request handler relay</haxe_doc>
		</onInfoQuery>
		<onItemsQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom items request handler relay</haxe_doc>
		</onItemsQuery>
		<c_info><c path="jabber.PacketCollector"/></c_info>
		<c_items><c path="jabber.PacketCollector"/></c_items>
		<dispose public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<handleInfoQuery set="method" line="68"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoQuery>
		<handleItemsQuery set="method" line="90"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItemsQuery>
		<new public="1" set="method" line="49"><f a="stream:?identities">
	<c path="jabber.Stream"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers incoming service discovery requests.
	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<typedef path="jabber.SocketConnection" params="" file="../../jabber/SocketConnection.hx"><c path="jabber.net.SocketConnection_sys"/></typedef>
	<class path="jabber.SoftwareVersion" params="" file="../../jabber/SoftwareVersion.hx">
		<onLoad public="1" set="dynamic" line="29"><f a="jid:sv">
	<c path="String"/>
	<c path="xmpp.SoftwareVersion"/>
	<x path="Void"/>
</f></onLoad>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<load public="1" set="method" line="41">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests the software version of the given entity.</haxe_doc>
		</load>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="jabber.SoftwareVersionListener" params="" file="../../jabber/SoftwareVersionListener.hx">
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity (optional)</haxe_doc>
		</os>
		<c><c path="jabber.PacketCollector"/></c>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<handleQuery set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleQuery>
		<new public="1" set="method" line="45"><f a="stream:name:version:?os">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for retrieving information about the software application associated with an XMPP entity
	XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<typedef path="jabber._Stream.Server" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream"><a><features><x path="Map">
	<c path="String"/>
	<c path="Xml"/>
</x></features></a></typedef>
	<class path="jabber._Stream.StreamFeatures" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream">
		<l><c path="Array"><c path="String"/></c></l>
		<iterator public="1" get="inline" set="null" line="47"><f a=""><t path="Iterator"><c path="String"/></t></f></iterator>
		<add public="1" set="method" line="51"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></add>
		<has public="1" get="inline" set="null" line="57"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" get="inline" set="null" line="61"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="65"><f a="f">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<toString public="1" get="inline" set="null" line="70"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="jabber.Stream" params="" file="../../jabber/Stream.hx">
		<defaultPacketIdLength public="1" line="81" static="1"><x path="Int"/></defaultPacketIdLength>
		<defaultMaxBufSize public="1" line="82" static="1"><x path="Int"/></defaultMaxBufSize>
		<onOpen public="1" set="dynamic" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the XMPP stream is opened and ready to exchange XMPP data</haxe_doc>
		</onOpen>
		<onClose public="1" set="dynamic" line="92">
			<f a="?e">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when the XMPP stream closes, optionally reporting stream errors if occured</haxe_doc>
		</onClose>
		<status public="1">
			<e path="jabber.StreamStatus"/>
			<haxe_doc>Current status of the XMPP stream</haxe_doc>
		</status>
		<cnx public="1" set="accessor">
			<c path="jabber.StreamConnection"/>
			<haxe_doc>The connection used to transport xmpp data</haxe_doc>
		</cnx>
		<features public="1" set="null">
			<c path="jabber._Stream.StreamFeatures"/>
			<haxe_doc>Clients stream features</haxe_doc>
		</features>
		<server public="1" set="null">
			<t path="jabber._Stream.Server"/>
			<haxe_doc></haxe_doc>
		</server>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>Stream-id</haxe_doc>
		</id>
		<lang public="1" set="null">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</lang>
		<jid public="1" set="accessor">
			<c path="jabber.JID"/>
			<haxe_doc>Jabber-id of this entity</haxe_doc>
		</jid>
		<dataFilters public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataFilter"/></c>
			<haxe_doc></haxe_doc>
		</dataFilters>
		<dataInterceptors public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataInterceptor"/></c>
			<haxe_doc></haxe_doc>
		</dataInterceptors>
		<bufSize public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Incoming data buffer size</haxe_doc>
		</bufSize>
		<maxBufSize public="1">
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</maxBufSize>
		<buf><c path="StringBuf"/></buf>
		<collectors_id><c path="Array"><c path="jabber.PacketCollector"/></c></collectors_id>
		<collectors><c path="Array"><c path="jabber.PacketCollector"/></c></collectors>
		<interceptors><c path="Array"><t path="jabber.PacketInterceptor"/></c></interceptors>
		<numPacketsSent><x path="Int"/></numPacketsSent>
		<set_jid set="method" line="140"><f a="j">
	<c path="jabber.JID"/>
	<c path="jabber.JID"/>
</f></set_jid>
		<set_cnx set="method" line="146"><f a="c">
	<c path="jabber.StreamConnection"/>
	<c path="jabber.StreamConnection"/>
</f></set_cnx>
		<nextID public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>Create/Returns the next unique id for this XMPP stream</haxe_doc>
		</nextID>
		<open public="1" set="method" line="185">
			<f a="jid">
				<c path="jabber.JID"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Open the XMPP stream.</haxe_doc>
		</open>
		<close public="1" set="method" line="201">
			<f a="?disconnect">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Closes the XMPP stream.<br/>
		Passed argument indicates if the data connection to the server should also get disconnected.]]></haxe_doc>
		</close>
		<sendMessage public="1" set="method" line="216">
			<f a="to:body:?subject:?type:?thread:?from">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="xmpp.MessageType"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Send a message packet (default type is 'chat').</haxe_doc>
		</sendMessage>
		<sendPresence public="1" set="method" line="223">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send a presence packet.</haxe_doc>
		</sendPresence>
		<sendPresenceTo public="1" get="inline" set="null" line="230">
			<f a="jid:?show:?status:?priority:?type">
				<c path="String"/>
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send directed presence</haxe_doc>
		</sendPresenceTo>
		<sendIQ public="1" set="method" line="239">
			<f a="iq:?handler">
				<c path="xmpp.IQ"/>
				<f a="">
					<c path="xmpp.IQ"/>
					<x path="Void"/>
				</f>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Send an IQ packet and forwards the response to the given handler function.</haxe_doc>
		</sendIQ>
		<sendIQResult public="1" get="inline" set="null" line="257">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create and send the resulting iq for given request</haxe_doc>
		</sendIQResult>
		<sendPacket public="1" params="T" set="method" line="264">
			<f a="p:?intercept">
				<c path="sendPacket.T"/>
				<x path="Bool"/>
				<c path="sendPacket.T"/>
			</f>
			<haxe_doc>Intercept/Send/Return XMPP packet.</haxe_doc>
		</sendPacket>
		<sendData public="1" set="method" line="275">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Send raw string.</haxe_doc>
		</sendData>
		<sendBytes public="1" set="method" line="296"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></sendBytes>
		<interceptPacket public="1" set="method" line="307">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Runs the XMPP packet interceptor on the given packet.</haxe_doc>
		</interceptPacket>
		<collect public="1" set="method" line="315">
			<f a="filters:handler:?permanent">
				<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Creates, adds and returns a XMPP packet collector.</haxe_doc>
		</collect>
		<addIDCollector public="1" set="method" line="324">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Adds an packet collector which filters XMPP packets by ids.
		These collectors get processed before any other.</haxe_doc>
		</addIDCollector>
		<addCollector public="1" set="method" line="333">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Adds a XMPP packet collector to this stream and starts the timeout if not null.</haxe_doc>
		</addCollector>
		<removeCollector public="1" set="method" line="342">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeCollector>
		<addInterceptor public="1" set="method" line="351">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</addInterceptor>
		<removeInterceptor public="1" set="method" line="360">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeInterceptor>
		<handleData public="1" set="method" line="366">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleData>
		<handleString public="1" set="method" line="377">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleString>
		<handleXml public="1" set="method" line="465">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="xmpp.Packet"/></c>
			</f>
			<haxe_doc>Inject incoming XML data.
		Returns array of handled XMPP packets.</haxe_doc>
		</handleXml>
		<handlePacket public="1" set="method" line="479">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Handles incoming XMPP packets.
		Returns true if the packet got handled.</haxe_doc>
		</handlePacket>
		<buffer set="method" line="543"><f a="t">
	<c path="String"/>
	<x path="Void"/>
</f></buffer>
		<resetBuffer set="method" line="548"><f a=""><x path="Void"/></f></resetBuffer>
		<processStreamInit set="method" line="571"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<handleConnect set="method" line="575"><f a=""><x path="Void"/></f></handleConnect>
		<handleDisconnect set="method" line="581"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleDisconnect>
		<handleStreamOpen set="method" line="586"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleStreamClose set="method" line="590"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleStreamClose>
		<cleanup set="method" line="596"><f a=""><x path="Void"/></f></cleanup>
		<new set="method" line="133"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for handling a XMPP data stream to and from another entity.
	
	See: http://xmpp.org/rfcs/rfc6120.html#streams</haxe_doc>
	</class>
	<class path="jabber.StreamConnection" params="" file="../../jabber/StreamConnection.hx">
		<__onConnect public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Succesfully connected callback</haxe_doc>
		</__onConnect>
		<__onDisconnect public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Disconnected callback. Parameter is an optional error message</haxe_doc>
		</__onDisconnect>
		<__onData public="1">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Bytes recieved callback</haxe_doc>
		</__onData>
		<__onString public="1">
			<f a="">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>String recieved callback</haxe_doc>
		</__onString>
		<__onSecured public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>TLS negotiation complete callback</haxe_doc>
		</__onSecured>
		<host public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>Hostname or IP address of the XMPP server.</haxe_doc>
		</host>
		<connected public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if connected and ready to read and write.</haxe_doc>
		</connected>
		<secure public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this is a secure connection (TLS negotiation complete)</haxe_doc>
		</secure>
		<secured public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if TLS is negotiation is complete and data transfered is encrypted</haxe_doc>
		</secured>
		<http public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this data connection is a HTTP (BOSH) connection (default is false)</haxe_doc>
		</http>
		<set_host set="method" line="68"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_host>
		<connect public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</connect>
		<disconnect public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</disconnect>
		<setSecure public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</setSecure>
		<read public="1" set="method" line="95">
			<f a="?yes">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Starts/Stops reading data input, returns true if successfully started</haxe_doc>
		</read>
		<write public="1" set="method" line="103">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send a string, returns true on succeess</haxe_doc>
		</write>
		<writeBytes public="1" set="method" line="111">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send raw bytes, returns true on succeess</haxe_doc>
		</writeBytes>
		<new set="method" line="61"><f a="host:secure:?http">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for XMPP stream connections.</haxe_doc>
	</class>
	<typedef path="jabber.StreamDataFilter" params="" file="../../jabber/StreamDataFilter.hx"><a><filterData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Filter raw incoming data before processing</haxe_doc>
</filterData></a></typedef>
	<typedef path="jabber.StreamDataInterceptor" params="" file="../../jabber/StreamDataInterceptor.hx"><a><interceptData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Modify raw outgoing XMPP data before sending</haxe_doc>
</interceptData></a></typedef>
	<enum path="jabber.StreamStatus" params="" file="../../jabber/StreamStatus.hx">
		<closed><haxe_doc>XMPP stream is inactive.</haxe_doc></closed>
		<pending><haxe_doc>Request to open XMPP stream sent but no response so far.</haxe_doc></pending>
		<starttls><haxe_doc>TLS negotiation in progress.</haxe_doc></starttls>
		<open><haxe_doc>XMPP stream is open and ready to exchange data.</haxe_doc></open>
	</enum>
	<class path="jabber.UserSearch" params="" file="../../jabber/UserSearch.hx">
		<onFields public="1" set="dynamic" line="29"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onFields>
		<onResult public="1" set="dynamic" line="30"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onResult>
		<onError public="1" set="dynamic" line="31"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<requestFields public="1" set="method" line="39"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></requestFields>
		<search public="1" set="method" line="46"><f a="jid:item">
	<c path="String"/>
	<t path="xmpp.UserSearchItem"/>
	<x path="Void"/>
</f></search>
		<sendIQ set="method" line="56"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a=":">
		<c path="String"/>
		<c path="xmpp.UserSearch"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<new public="1" set="method" line="35"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0055: Search: http://xmpp.org/extensions/xep-0055.html</haxe_doc>
	</class>
	<class path="jabber.XMPPDebug" params="" file="../../jabber/XMPPDebug.hx">
		<active public="1" line="80" static="1">
			<x path="Bool"/>
			<haxe_doc>Activate/Deactivate output.
		Default is true.</haxe_doc>
		</active>
		<lastPrintWasOutgoing public="1" set="null" line="83" static="1">
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</lastPrintWasOutgoing>
		<beautify public="1" line="91" static="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the XMPP debug output should get formatted/beautified.
		Mind: If active, it is not ensured that the formatted string matches exactly the sent/recieved ones!
		Default value is false.
		Currently only supported in terminal targets.</haxe_doc>
		</beautify>
		<showDate public="1" line="96" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current date in meta information</haxe_doc>
		</showDate>
		<showTime public="1" line="101" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current time in meta information</haxe_doc>
		</showTime>
		<i public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print incoming XMPP data</haxe_doc>
		</i>
		<o public="1" get="inline" set="null" line="113" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print outgoing XMPP data</haxe_doc>
		</o>
		<print public="1" set="method" line="124" static="1">
			<f a="t:out:?level">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print manually to console</haxe_doc>
		</print>
		<color_out public="1" line="142" static="1"><x path="Int"/></color_out>
		<color_inc public="1" line="143" static="1"><x path="Int"/></color_inc>
		<__print public="1" set="method" line="147" static="1">
			<f a="t:?color">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</__print>
		<haxe_doc>Utility for debugging XMPP transfer.
	Set the compiler flag: -D xmpp_debug to activate it.
	
	* Terminal targets: Color highlighted
	* Browser targets: Printed to the default debug console
	* Adobe air: Printed to fdb 'trace'</haxe_doc>
		<meta><m n=":require"><e>xmpp_debug</e></m></meta>
	</class>
	<class path="xmpp.ErrorPacket" params="" file="../../xmpp/ErrorPacket.hx">
		<parseInto set="method" line="72" static="1"><f a="p:x:xmlns">
	<c path="xmpp.ErrorPacket"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Bool"/>
</f></parseInto>
		<condition public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</condition>
		<text public="1">
			<c path="String"/>
			<haxe_doc>Describes the error in more detail</haxe_doc>
		</text>
		<lang public="1">
			<c path="String"/>
			<haxe_doc>Language of the text content XML character data</haxe_doc>
		</lang>
		<app public="1">
			<t path="xmpp.ApplicationErrorCondition"/>
			<haxe_doc>Application-specific error condition</haxe_doc>
		</app>
		<_toXml set="method" line="53"><f a="p:ns">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
</f></_toXml>
		<new set="method" line="45"><f a="condition:?text:?lang:?app">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for xmpp.Error and xmpp.StreamError</haxe_doc>
	</class>
	<class path="xmpp.Error" params="" file="../../xmpp/Error.hx">
		<extends path="xmpp.ErrorPacket"/>
		<XMLNS public="1" set="null" line="30" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Error"/>
</f></parse>
		<type public="1"><e path="xmpp.ErrorType"/></type>
		<code public="1"><t path="Null"><x path="Int"/></t></code>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="35"><f a="type:condition:?code:?text:?lang:?app">
	<e path="xmpp.ErrorType"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.XMPPError" params="" file="../../jabber/XMPPError.hx">
		<extends path="xmpp.Error"/>
		<from public="1" set="null"><c path="String"/></from>
		<toString public="1" set="method" line="37"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Used to dispatch and track XMPP protocol errors.</haxe_doc>
	</class>
	<class path="jabber.client.Account" params="" file="../../jabber/client/Account.hx">
		<onFields public="1" set="dynamic" line="32">
			<f a="fields">
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for recieved registration fields</haxe_doc>
		</onFields>
		<onRegister public="1" set="dynamic" line="35">
			<f a="node">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for account registering success</haxe_doc>
		</onRegister>
		<onRemove public="1" set="dynamic" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback for account remove success</haxe_doc>
		</onRemove>
		<onPasswordChange public="1" set="dynamic" line="41">
			<f a="pass">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for password change success</haxe_doc>
		</onPasswordChange>
		<onError public="1" set="dynamic" line="44">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<requestRegistrationFields public="1" set="method" line="55">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request required registration fields from server</haxe_doc>
		</requestRegistrationFields>
		<register public="1" set="method" line="87">
			<f a="reg">
				<c path="xmpp.Register"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Register new account.</haxe_doc>
		</register>
		<remove public="1" set="method" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Delete account from server.</haxe_doc>
		</remove>
		<changePassword public="1" set="method" line="145">
			<f a="node:pass">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change account password.</haxe_doc>
		</changePassword>
		<new public="1" set="method" line="48"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration: http://www.xmpp.org/extensions/xep-0077.html</haxe_doc>
	</class>
	<class path="jabber.client.AuthenticationBase" params="" file="../../jabber/client/AuthenticationBase.hx">
		<onSuccess public="1" set="dynamic" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Authenication was success full callback</haxe_doc>
		</onSuccess>
		<onFail public="1" set="dynamic" line="33">
			<f a="info">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Authenication failed callback</haxe_doc>
		</onFail>
		<resource public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid resource to authenticate</haxe_doc>
		</resource>
		<stream public="1" set="null">
			<c path="jabber.client.Stream"/>
			<haxe_doc></haxe_doc>
		</stream>
		<start public="1" set="method" line="48">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Start the authentication process.</haxe_doc>
		</start>
		<new set="method" line="41"><f a="s">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract client account authentication class.</haxe_doc>
	</class>
	<class path="jabber.client.Authentication" params="" file="../../jabber/client/Authentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<onNegotiated public="1" set="dynamic" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback on SASL negotiation completed</haxe_doc>
		</onNegotiated>
		<mechanisms public="1" set="null">
			<c path="Array"><t path="jabber.sasl.Mechanism"/></c>
			<haxe_doc>Clients SASL mechanisms (in prefered order)</haxe_doc>
		</mechanisms>
		<serverMechanisms public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>Available SASL mechanisms offered by server</haxe_doc>
		</serverMechanisms>
		<mechanism public="1" set="null">
			<t path="jabber.sasl.Mechanism"/>
			<haxe_doc>Used SASL method</haxe_doc>
		</mechanism>
		<onStreamOpenHandler><f a=""><x path="Void"/></f></onStreamOpenHandler>
		<c_challenge><c path="jabber.PacketCollector"/></c_challenge>
		<c_fail><c path="jabber.PacketCollector"/></c_fail>
		<c_success><c path="jabber.PacketCollector"/></c_success>
		<start public="1" set="method" line="76" override="1">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Inits SASL authentication.
		Returns false if no supported SASL mechanism got offered by the server.</haxe_doc>
		</start>
		<handleSASLFailed set="method" line="105"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLFailed>
		<handleSASLChallenge set="method" line="113"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLChallenge>
		<handleSASLSuccess set="method" line="119"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLSuccess>
		<handleStreamOpen set="method" line="130"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleBind set="method" line="141"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleBind>
		<handleSession set="method" line="165"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSession>
		<removeSASLCollectors set="method" line="176"><f a=""><x path="Void"/></f></removeSASLCollectors>
		<new public="1" set="method" line="59"><f a="stream:mechanisms">
	<c path="jabber.client.Stream"/>
	<t path="Iterable"><t path="jabber.sasl.Mechanism"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>SASL client authentication.

	Responsible for:
		* Authenticating a client account using SASL
		* Binding the resource to the connection
		* Establishing a session with the server

	RFC3920-SASL http://xmpp.org/rfcs/rfc3920.html#sasl
	RFC3920-BIND http://xmpp.org/rfcs/rfc3920.html#bind</haxe_doc>
	</class>
	<class path="jabber.client.GMailNotify" params="" file="../../jabber/client/GMailNotify.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<onMail public="1" set="dynamic" line="34"><f a="m">
	<c path="Xml"/>
	<x path="Void"/>
</f></onMail>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<request public="1" set="method" line="57">
			<f a="?newerThanTime:?newerThanTid:?q">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param newerThanTime The time of the oldest unread email to retrieve, in milliseconds
		
		@param newerThanTid The highest thread number of messages to return, where higher numbers are more recent email threads.
		The server will return only threads newer than that specified by this attribute.
		If using this attribute, you should also use newer-than-time for best results.
		When querying for the first time, you should omit this value.
		
		@param q Specifies an optional search query string.
		This string uses the same syntax as the search box in Gmail, including supported operators.
		
		The server will also subscribe the client to receive notifications when new mail is received.</haxe_doc>
		</request>
		<dispose public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops collecting/reporting mail notifications.
		This does NOT unsubscribe from getting mail notifications (currently not provided by the service).</haxe_doc>
		</dispose>
		<handleNotification set="method" line="77"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleNotification>
		<new public="1" set="method" line="40"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A custom google extension to XMPP to enable users to query their Gmail account for emails,
	and receive notifications when a new message arrives.

	https://developers.google.com/talk/jep_extensions/gmail</haxe_doc>
	</class>
	<class path="jabber.client.MUCOccupant" params="" file="../../jabber/client/MUChat.hx" module="jabber.client.MUChat">
		<nick public="1"><c path="String"/></nick>
		<jid public="1"><c path="String"/></jid>
		<presence public="1"><c path="xmpp.Presence"/></presence>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.client.MUChat" params="" file="../../jabber/client/MUChat.hx">
		<onJoin public="1" set="dynamic" line="55"><f a=""><x path="Void"/></f></onJoin>
		<onLeave public="1" set="dynamic" line="56"><f a=""><x path="Void"/></f></onLeave>
		<onUnlock public="1" set="dynamic" line="57"><f a=""><x path="Void"/></f></onUnlock>
		<onMessage public="1" set="dynamic" line="58"><f a="o:m">
	<c path="jabber.client.MUCOccupant"/>
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></onMessage>
		<onPresence public="1" set="dynamic" line="60"><f a="o">
	<c path="jabber.client.MUCOccupant"/>
	<x path="Void"/>
</f></onPresence>
		<onSubject public="1" set="dynamic" line="61"><f a="o:t">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></onSubject>
		<onKick public="1" set="dynamic" line="62"><f a="nick">
	<c path="String"/>
	<x path="Void"/>
</f></onKick>
		<onError public="1" set="dynamic" line="63"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<jid public="1" set="null"><c path="String"/></jid>
		<room public="1" set="null"><c path="String"/></room>
		<joined public="1" set="null"><x path="Bool"/></joined>
		<myjid public="1" set="null"><c path="String"/></myjid>
		<nick public="1" set="null"><c path="String"/></nick>
		<password public="1" set="null"><c path="String"/></password>
		<role public="1" set="null"><e path="xmpp.muc.Role"/></role>
		<affiliation public="1" set="null"><e path="xmpp.muc.Affiliation"/></affiliation>
		<occupants public="1" set="null"><c path="Array"><c path="jabber.client.MUCOccupant"/></c></occupants>
		<subject public="1" set="null"><c path="String"/></subject>
		<me public="1" get="accessor" set="null"><c path="jabber.client.MUCOccupant"/></me>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<presence><c path="xmpp.Presence"/></presence>
		<message><c path="xmpp.Message"/></message>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<get_me set="method" line="104"><f a=""><c path="jabber.client.MUCOccupant"/></f></get_me>
		<getOccupant public="1" set="method" line="121"><f a="nick">
	<c path="String"/>
	<c path="jabber.client.MUCOccupant"/>
</f></getOccupant>
		<join public="1" set="method" line="130">
			<f a="nick:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Sends initial presence to room.</haxe_doc>
		</join>
		<leave public="1" set="method" line="145">
			<f a="?message">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Sends unavailable presence to the room, exits room.</haxe_doc>
		</leave>
		<sendPresence public="1" set="method" line="159">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</sendPresence>
		<speak public="1" set="method" line="169">
			<f a="t:?properties">
				<c path="String"/>
				<c path="Array"><c path="Xml"/></c>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Sends message to all room occupants.</haxe_doc>
		</speak>
		<changeSubject public="1" set="method" line="179">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeSubject>
		<changeNick public="1" set="method" line="190">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeNick>
		<kick public="1" set="method" line="201">
			<f a="nick:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</kick>
		<invite public="1" set="method" line="231">
			<f a="jid:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends an (mediated) invitation message to the given entity .</haxe_doc>
		</invite>
		<handleMessage set="method" line="251"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handleMessage>
		<handlePresence set="method" line="275"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<sendMyPresence set="method" line="436"><f a="?priority">
	<x path="Int"/>
	<c path="xmpp.Presence"/>
</f></sendMyPresence>
		<getOccupantName get="inline" set="null" line="449"><f a="j">
	<c path="String"/>
	<c path="String"/>
</f></getOccupantName>
		<destroy set="method" line="453"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="84"><f a="stream:host:roomName">
	<c path="jabber.client.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Multiuser chatroom.

	http://www.xmpp.org/extensions/xep-0045.html
	http://www.xmpp.org/extensions/xep-0249.html</haxe_doc>
	</class>
	<class path="jabber.client.NonSASLAuthentication" params="" file="../../jabber/client/NonSASLAuthentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<active public="1" set="null"><x path="Bool"/></active>
		<usePlainText public="1" set="null"><x path="Bool"/></usePlainText>
		<username public="1" set="null"><c path="String"/></username>
		<password public="1" set="null"><c path="String"/></password>
		<start public="1" set="method" line="48" override="1"><f a="password:?resource">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></start>
		<handleResponse set="method" line="64"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResponse>
		<handleResult set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResult>
		<new public="1" set="method" line="37"><f a="stream:?usePlainText">
	<c path="jabber.client.Stream"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Obsolete, superseded in favor of SASL authentication (jabber.client.Authentication)!
	<a href="http://xmpp.org/extensions/xep-0078.html">XEP-0078: Non-SASL Authentication</a>]]></haxe_doc>
	</class>
	<enum path="jabber.client.RosterSubscriptionMode" params="" file="../../jabber/client/RosterSubscriptionMode.hx">
		<rejectAll><haxe_doc>Reject all subscription requests.</haxe_doc></rejectAll>
		<manual><haxe_doc>Ask how to proceed.</haxe_doc></manual>
		<acceptAll a="subscribe">
			<x path="Bool"/>
			<haxe_doc>Accept all subscription and unsubscription requests.</haxe_doc>
		</acceptAll>
		<haxe_doc>Configuration how to handle recieved presence subscriptions</haxe_doc>
	</enum>
	<class path="jabber.client.Roster" params="" file="../../jabber/client/Roster.hx">
		<defaultSubscriptionMode public="1" line="39" static="1"><e path="jabber.client.RosterSubscriptionMode"/></defaultSubscriptionMode>
		<onLoad public="1" set="dynamic" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Roster got loaded</haxe_doc>
		</onLoad>
		<onAdd public="1" set="dynamic" line="45">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got added to the roster</haxe_doc>
		</onAdd>
		<onRemove public="1" set="dynamic" line="48">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got removed from your roster</haxe_doc>
		</onRemove>
		<onUpdate public="1" set="dynamic" line="51">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got updated</haxe_doc>
		</onUpdate>
		<onSubscribed public="1" set="dynamic" line="54">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscribed to the presence of the contact</haxe_doc>
		</onSubscribed>
		<onUnsubscribed public="1" set="dynamic" line="57">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Unsubscribed presence of the contact</haxe_doc>
		</onUnsubscribed>
		<onAsk public="1" set="dynamic" line="60">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Incoming presence subscription request</haxe_doc>
		</onAsk>
		<onSubscription public="1" set="dynamic" line="63">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact subscribed to your presence</haxe_doc>
		</onSubscription>
		<onUnsubscription public="1" set="dynamic" line="66">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact unsubscribed from your presence</haxe_doc>
		</onUnsubscription>
		<onError public="1" set="dynamic" line="69">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc>A roster manipulation error occured</haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<subscriptionMode public="1"><e path="jabber.client.RosterSubscriptionMode"/></subscriptionMode>
		<available public="1" set="null"><x path="Bool"/></available>
		<items public="1" set="null"><c path="Array"><c path="xmpp.roster.Item"/></c></items>
		<groups public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></groups>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<get_groups set="method" line="91"><f a=""><c path="Array"><c path="String"/></c></f></get_groups>
		<dispose public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<getItem public="1" set="method" line="119">
			<f a="jid">
				<c path="String"/>
				<c path="xmpp.roster.Item"/>
			</f>
			<haxe_doc></haxe_doc>
		</getItem>
		<hasItem public="1" get="inline" set="null" line="126">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</hasItem>
		<load public="1" set="method" line="132">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</load>
		<addItem public="1" set="method" line="146">
			<f a="jid:?groups">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add entry to your roster</haxe_doc>
		</addItem>
		<removeItem public="1" set="method" line="156">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove entry from remote roster</haxe_doc>
		</removeItem>
		<subscribe public="1" set="method" line="180">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Subscribe to the presence of the entity.
		You will get presence updates from this entity (if confirmed).</haxe_doc>
		</subscribe>
		<unsubscribe public="1" set="method" line="207">
			<f a="jid:?cancelSubscription">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Unsubscribe from entities presence.
		The entity will no longer recieve presence updates.</haxe_doc>
		</unsubscribe>
		<cancelSubscription public="1" set="method" line="223">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Cancel the subscription from entity.
		You will no longer recieve presence updates.</haxe_doc>
		</cancelSubscription>
		<confirmSubscription public="1" set="method" line="231">
			<f a="jid:?allow:?subscribe">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the requesting entity to recieve presence updates from you.</haxe_doc>
		</confirmSubscription>
		<sendPresence set="method" line="241"><f a="jid:type">
	<c path="String"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></sendPresence>
		<sendAddItemRequest set="method" line="247"><f a="jid:?groups">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></sendAddItemRequest>
		<handleIQ set="method" line="270"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<handlePresence set="method" line="316"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<new public="1" set="method" line="80"><f a="stream:?subscriptionMode">
	<c path="jabber.client.Stream"/>
	<e path="jabber.client.RosterSubscriptionMode"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client roster (serverside saved contact list)</haxe_doc>
	</class>
	<class path="jabber.client.Stream" params="" file="../../jabber/client/Stream.hx">
		<extends path="jabber.Stream"/>
		<PORT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></PORT>
		<PORT_SECURE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></PORT_SECURE>
		<defaultPort public="1" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for socket connections</haxe_doc>
		</defaultPort>
		<defaultPortSecure public="1" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for secure socket connections</haxe_doc>
		</defaultPortSecure>
		<version><x path="Bool"/></version>
		<handleConnect set="method" line="56" override="1"><f a=""><x path="Void"/></f></handleConnect>
		<processStreamInit set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<parseServerStreamFeatures set="method" line="136"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></parseServerStreamFeatures>
		<new public="1" set="method" line="48"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client-Server XMPP stream.

	See: http://xmpp.org/rfcs/rfc6120.html#examples-c2s</haxe_doc>
	</class>
	<class path="jabber.client.VCardBase" params="T" file="../../jabber/client/VCardBase.hx">
		<onLoad public="1" set="dynamic" line="33">
			<f a="jid:data">
				<c path="String"/>
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>VCard loaded callback</haxe_doc>
		</onLoad>
		<onUpdate public="1" set="dynamic" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Own vcard updated callback</haxe_doc>
		</onUpdate>
		<onError public="1" set="dynamic" line="37">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<load public="1" set="method" line="48">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or own no jid is given.</haxe_doc>
		</load>
		<update public="1" set="method" line="55">
			<f a="vc">
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Update own vcard.</haxe_doc>
		</update>
		<_load set="method" line="61"><f a="x:jid">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></_load>
		<handleLoad set="method" line="67"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<_handleLoad set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<handleUpdate set="method" line="84"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleUpdate>
		<new set="method" line="41"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for vcard classes (jabber.client.VCard and jabber.client.VCardTemp)</haxe_doc>
	</class>
	<class path="jabber.client.VCardTemp" params="" file="../../jabber/client/VCardTemp.hx">
		<extends path="jabber.client.VCardBase"><c path="xmpp.VCardTemp"/></extends>
		<load public="1" set="method" line="38" override="1">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or from its own if jid is null.</haxe_doc>
		</load>
		<_handleLoad set="method" line="42" override="1"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<new public="1" set="method" line="31"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html

	Depricated but still widely implementd by servers (use jabber.client.VCard)</haxe_doc>
	</class>
	<class path="jabber.lop.Farm" params="" file="../../jabber/lop/Farm.hx">
		<createFormField set="method" line="199" static="1"><f a="name:value:type">
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.dataform.FieldType"/>
	<c path="xmpp.dataform.Field"/>
</f></createFormField>
		<createFormFieldMulti set="method" line="206" static="1"><f a="name:values">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<c path="xmpp.dataform.Field"/>
</f></createFormFieldMulti>
		<onJob public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<c path="String"/>
</f></onJob>
		<onVMKill public="1" set="dynamic" line="39"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></onVMKill>
		<onPing public="1" set="dynamic" line="40"><f a="ping">
	<c path="xmpp.lop.Ping"/>
	<c path="String"/>
</f></onPing>
		<onSetBindings public="1" set="dynamic" line="41"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onSetBindings>
		<onGetBindings public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<c path="xmpp.lop.Bindings"/>
</f></onGetBindings>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<species public="1" set="null"><x path="Map">
	<c path="String"/>
	<f a=":">
		<c path="jabber.JID"/>
		<c path="xmpp.lop.SpawnVM"/>
		<c path="String"/>
	</f>
</x></species>
		<password public="1" set="null"><c path="String"/></password>
		<ip public="1"><c path="String"/></ip>
		<vm_species public="1"><c path="String"/></vm_species>
		<vm_time_to_live public="1"><x path="Float"/></vm_time_to_live>
		<job_timeout public="1"><x path="Float"/></job_timeout>
		<job_queue_capacity public="1"><t path="Null"><x path="Int"/></t></job_queue_capacity>
		<max_concurrent_vms public="1"><t path="Null"><x path="Int"/></t></max_concurrent_vms>
		<farm_start_time public="1"><c path="String"/></farm_start_time>
		<read_file public="1"><c path="Array"><c path="String"/></c></read_file>
		<write_file public="1"><c path="Array"><c path="String"/></c></write_file>
		<delete_file public="1"><c path="Array"><c path="String"/></c></delete_file>
		<open_connection public="1"><t path="Null"><x path="Bool"/></t></open_connection>
		<listen_for_connection public="1"><t path="Null"><x path="Bool"/></t></listen_for_connection>
		<accept_connection public="1"><t path="Null"><x path="Bool"/></t></accept_connection>
		<perform_multicast public="1"><t path="Null"><x path="Bool"/></t></perform_multicast>
		<handleIQ public="1" set="method" line="87">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleIQ>
		<getDataForm public="1" set="method" line="179">
			<f a=""><c path="xmpp.DataForm"/></f>
			<haxe_doc>Generate a dataform of this farms settings.</haxe_doc>
		</getDataForm>
		<new public="1" set="method" line="63"><f a="stream:?password:?vm_species:?vm_time_to_live:?job_timeout">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages the spawning of virtual machines.
	The disco 'identity' of a farm MUST be of category="client" and type="bot" (name is up to the implementation).
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html</haxe_doc>
	</class>
	<class path="jabber.lop.Villein" params="" file="../../jabber/lop/Villein.hx">
		<onSpawn public="1" set="dynamic" line="37"><f a="s">
	<c path="xmpp.lop.SpawnVM"/>
	<x path="Void"/>
</f></onSpawn>
		<onResult public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<x path="Void"/>
</f></onResult>
		<onFail public="1" set="dynamic" line="39"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onFail>
		<onTerminate public="1" set="dynamic" line="40"><f a="vm">
	<c path="String"/>
	<x path="Void"/>
</f></onTerminate>
		<onTerminateFail public="1" set="dynamic" line="41"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onTerminateFail>
		<onBind public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onBind>
		<onBindFail public="1" set="dynamic" line="43"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onBindFail>
		<onVariables public="1" set="dynamic" line="44"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onVariables>
		<onVariablesFail public="1" set="dynamic" line="45"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onVariablesFail>
		<farm public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid of the farm</haxe_doc>
		</farm>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<spawnVM public="1" set="method" line="58">
			<f a="species:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</spawnVM>
		<submitJob public="1" set="method" line="66">
			<f a="id:job">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</submitJob>
		<pingJob public="1" set="method" line="75">
			<f a="vm_id:job_id">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</pingJob>
		<abortJob public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</abortJob>
		<getBindings public="1" set="method" line="91">
			<f a="id:names">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</getBindings>
		<setBindings public="1" set="method" line="102">
			<f a="id:list">
				<c path="String"/>
				<t path="Iterable"><t path="xmpp.lop.Binding"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</setBindings>
		<terminateVM public="1" set="method" line="115">
			<f a="vm_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</terminateVM>
		<handleVMSpawn set="method" line="121"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleVMSpawn>
		<handleJob set="method" line="131"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleJob>
		<handlePing set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<handleTerminate set="method" line="155"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleTerminate>
		<handleGetBindings set="method" line="167"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleGetBindings>
		<handleSetBindings set="method" line="179"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSetBindings>
		<new public="1" set="method" line="51"><f a="stream:farm">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Communicates with a resource provider's farm in order to spawn and compute with virtual machines that leverage provided resources.<br/>
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html]]></haxe_doc>
	</class>
	<typedef path="jabber.net._SocketConnectionBase_sys.AbstractSocket" params="" file="../../jabber/net/SocketConnectionBase_sys.hx" private="1" module="jabber.net.SocketConnectionBase_sys"><a>
	<write set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
	<shutdown set="method"><f a="read:write">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></shutdown>
	<setTimeout set="method"><f a="t">
	<x path="Float"/>
	<x path="Void"/>
</f></setTimeout>
	<output set="null"><c path="haxe.io.Output"/></output>
	<input set="null"><c path="haxe.io.Input"/></input>
	<connect set="method"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
	<close set="method"><f a=""><x path="Void"/></f></close>
</a></typedef>
	<class path="jabber.net.SocketConnectionBase_sys" params="" file="../../jabber/net/SocketConnectionBase_sys.hx">
		<extends path="jabber.StreamConnection"/>
		<defaultBufSize public="1" line="42" static="1"><x path="Int"/></defaultBufSize>
		<defaultMaxBufSize public="1" line="43" static="1"><x path="Int"/></defaultMaxBufSize>
		<defaultTimeout public="1" line="44" static="1"><x path="Int"/></defaultTimeout>
		<port public="1" set="null"><x path="Int"/></port>
		<maxbufsize public="1" set="null"><x path="Int"/></maxbufsize>
		<timeout public="1" set="null"><x path="Int"/></timeout>
		<socket public="1" set="null"><t path="jabber.net._SocketConnectionBase_sys.AbstractSocket"/></socket>
		<reading public="1" set="null"><x path="Bool"/></reading>
		<buf><c path="haxe.io.Bytes"/></buf>
		<bufpos><x path="Int"/></bufpos>
		<bufsize><x path="Int"/></bufsize>
		<disconnect public="1" set="method" line="69" override="1"><f a=""><x path="Void"/></f></disconnect>
		<read public="1" set="method" line="79" override="1"><f a="?yes">
	<x path="Bool"/>
	<x path="Bool"/>
</f></read>
		<readData set="method" line="91"><f a=""><x path="Void"/></f></readData>
		<error set="method" line="116"><f a="info">
	<c path="String"/>
	<x path="Void"/>
</f></error>
		<new set="method" line="56"><f a="host:port:secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.net.SocketConnection_sys" params="" file="../../jabber/net/SocketConnection_sys.hx">
		<extends path="jabber.net.SocketConnectionBase_sys"/>
		<connect public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></connect>
		<setSecure public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></setSecure>
		<write public="1" set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></write>
		<writeBytes public="1" set="method" line="86" override="1"><f a="t">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></writeBytes>
		<new public="1" set="method" line="30"><f a="?host:?port:?secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.remoting.Connection" params="" file="../../jabber/remoting/Connection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" get="inline" set="null" line="103" static="1"><f a="stream:target">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="jabber.remoting.Connection"/>
</f></create>
		<target public="1">
			<c path="String"/>
			<haxe_doc>Jid of opposite</haxe_doc>
		</target>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<__error><f a="">
	<d/>
	<x path="Void"/>
</f></__error>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="49"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" get="inline" set="null" line="62"><f a="h">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method" line="66"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<new set="method" line="42"><f a="stream:target:path:error">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>Haxe remoting connection to another XMPP entity.
	User ServiceDiscovery to determine if an entity supports haxe-remoting (hxr).

	http://haxe.org/doc/remoting</haxe_doc>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="jabber.remoting.Host" params="" file="../../jabber/remoting/Host.hx">
		<numActive public="1" set="null" static="1"><x path="Int"/></numActive>
		<processRequest public="1" set="method" line="75" static="1"><f a="data:ctx">
	<c path="String"/>
	<c path="haxe.remoting.Context"/>
	<c path="String"/>
</f></processRequest>
		<client public="1" set="null">
			<c path="String"/>
			<haxe_doc>JID of current/last processed entity</haxe_doc>
		</client>
		<ctx public="1"><c path="haxe.remoting.Context"/></ctx>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<c><c path="jabber.PacketCollector"/></c>
		<close public="1" set="method" line="53"><f a=""><x path="Void"/></f></close>
		<handleIQ set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<new public="1" set="method" line="45"><f a="stream:ctx">
	<c path="jabber.Stream"/>
	<c path="haxe.remoting.Context"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[HaXe remoting host.<br/>
	<a href="http://haxe.org/doc/remoting">http://haxe.org/doc/remoting</a>]]></haxe_doc>
	</class>
	<class path="jabber.sasl.LOGINMechanism" params="" file="../../jabber/sasl/LOGINMechanism.hx">
		<NAME public="1" get="inline" set="null" line="35" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<password><c path="String"/></password>
		<username><c path="String"/></username>
		<nChallenges><x path="Int"/></nChallenges>
		<createAuthenticationText public="1" set="method" line="48">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" set="method" line="56">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" get="inline" set="null" line="43"><f a=""><x path="Void"/></f></new>
		<haxe_doc>LOGIN SASL Mechanism.
	
	Obsolete clear-text user/password Simple Authentication and Security Layer (SASL) mechanism called the LOGIN mechanism.
	The LOGIN mechanism was intended to be used, in combination with data confidentiality services provided by a lower layer,
	in protocols which lack a simple password authentication command.

	http://tools.ietf.org/id/draft-murchison-sasl-login-00.txt</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Calculator" params="" file="../../jabber/sasl/MD5Calculator.hx">
		<parseChallenge public="1" set="method" line="35" static="1">
			<f a="challenge">
				<c path="String"/>
				<a>
					<realm><c path="String"/></realm>
					<nonce><c path="String"/></nonce>
				</a>
			</f>
			<haxe_doc>* Parses the initial challenge and returns calculated realm and nonce</haxe_doc>
		</parseChallenge>
		<run public="1" set="method" line="56" static="1">
			<f a="host:serverType:username:realm:pass:nonce">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Caluclate/Create the MD5 challenge response</haxe_doc>
		</run>
		<h get="inline" set="null" line="89" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></h>
		<hh get="inline" set="null" line="90" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></hh>
		<quote get="inline" set="null" line="91" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<unquote get="inline" set="null" line="92" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></unquote>
		<haxe_doc>Static methods for computing SASL-MD5 credentials.</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Mechanism" params="" file="../../jabber/sasl/MD5Mechanism.hx">
		<NAME public="1" get="inline" set="null" line="30" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<serverType public="1"><c path="String"/></serverType>
		<username><c path="String"/></username>
		<host><c path="String"/></host>
		<pass><c path="String"/></pass>
		<resource><c path="String"/></resource>
		<createAuthenticationText public="1" set="method" line="46">
			<f a="username:host:pass:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" set="method" line="55">
			<f a="challenge">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" set="method" line="40"><f a="?serverType">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Using Digest Authentication as a SASL Mechanism: ftp://ietf.org//rfc/rfc2831.txt
	SASL and DIGEST-MD5 for XMPP: http://web.archive.org/web/20050224191820/http://cataclysm.cx/wip/digest-md5-crash.html</haxe_doc>
	</class>
	<typedef path="jabber.sasl.Mechanism" params="" file="../../jabber/sasl/Mechanism.hx">
		<a>
			<id set="null">
				<c path="String"/>
				<haxe_doc>The id of this mechanism, for example PLAIN, DIGEST-MD5, ...</haxe_doc>
			</id>
			<createChallengeResponse set="method">
				<f a="challenge">
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createChallengeResponse>
			<createAuthenticationText set="method">
				<f a="user:host:password:resource">
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createAuthenticationText>
		</a>
		<haxe_doc>SASL mechanism type.</haxe_doc>
	</typedef>
	<class path="jabber.sasl.PlainMechanism" params="" file="../../jabber/sasl/PlainMechanism.hx">
		<NAME public="1" get="inline" set="null" line="32" static="1"><c path="String"/></NAME>
		<id public="1" set="null"><c path="String"/></id>
		<createAuthenticationText public="1" get="inline" set="null" line="41">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<createChallengeResponse public="1" get="inline" set="null" line="51">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The PLAIN mechanism should not be used without adequate data security protection
	as this mechanism affords no integrity or confidentiality protections itself.
	
	The PLAIN Simple Authentication and Security Layer (SASL) Mechanism: http://www.ietf.org/rfc/rfc4616.txt</haxe_doc>
	</class>
	<class path="jabber.util.Base64" params="" file="../../jabber/util/Base64.hx">
		<CHARS public="1" line="39" static="1"><c path="String"/></CHARS>
		<encode public="1" set="method" line="45" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<decode public="1" set="method" line="74" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</decode>
		<encodeBytes public="1" set="method" line="101" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</encodeBytes>
		<decodeBytes public="1" set="method" line="120" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</decodeBytes>
		<random public="1" set="method" line="138" static="1">
			<f a="?len:?chars">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Create a random (base64 compatible) string of given length.</haxe_doc>
		</random>
		<haxe_doc>Base64 encoding/decoding utility.</haxe_doc>
	</class>
	<class path="jabber.util.DateUtil" params="" file="../../jabber/util/DateUtil.hx"><formatTimePartValue public="1" set="method" line="30" static="1"><f a="v">
	<x path="Int"/>
	<c path="String"/>
</f></formatTimePartValue></class>
	<class path="jabber.util.MD5" params="" file="../../jabber/util/MD5.hx">
		<encode public="1" get="inline" set="null" line="36" static="1">
			<f a="s:?raw">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<inst line="74" static="1"><c path="jabber.util.MD5"/></inst>
		<rhex set="method" line="78"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></rhex>
		<bitOR set="method" line="88"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="94"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="100"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="106"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<str2blks set="method" line="112"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<rol set="method" line="131"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="135"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="139"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="143"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="147"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="151"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<str2bin set="method" line="155"><f a="inp">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2bin>
		<bin2str set="method" line="167"><f a="inp">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></bin2str>
		<doEncodeRaw set="method" line="177"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncodeRaw>
		<doEncode set="method" line="185"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncode>
		<__encode set="method" line="190"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></__encode>
		<new set="method" line="76"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.
	Modified version from the haxe std lib to provide raw encoding as well as support for non official compiler targets.</haxe_doc>
	</class>
	<class path="jabber.util.SHA1" params="" file="../../jabber/util/SHA1.hx"><encode public="1" get="inline" set="null" line="38" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode></class>
	<class path="jabber.util.SystemUtil" params="" file="../../jabber/util/SystemUtil.hx"><systemName public="1" get="inline" set="null" line="31" static="1">
	<f a=""><c path="String"/></f>
	<haxe_doc>Returns the name of the operating system used (crossplatform).</haxe_doc>
</systemName></class>
	<class path="jabber.util.XMLBeautify" params="" file="../../jabber/util/XMLBeautify.hx">
		<it public="1" set="method" line="35" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format given string to something readable.
		Only for debugging, do NOT use in production.</haxe_doc>
		</it>
		<createNode set="method" line="43" static="1"><f a="x:b:depth">
	<c path="Xml"/>
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createNode>
		<indent get="inline" set="null" line="77" static="1"><f a="b:n">
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></indent>
		<haxe_doc>Utility to 'beautify' XML strings (for debugging).</haxe_doc>
	</class>
	<class path="java.Boot" params="" file="/usr/lib/haxe/std/java/Boot.hx" extern="1"/>
	<class path="java.Lib" params="" file="/usr/lib/haxe/std/java/Lib.hx">
		<nativeArray public="1" params="T" set="method" line="38" static="1">
			<f a="arr:equalLengthRequired">
				<c path="Array"><c path="nativeArray.T"/></c>
				<x path="Bool"/>
				<c path="java.NativeArray"><c path="nativeArray.T"/></c>
			</f>
			<haxe_doc>Returns a native array from the supplied Array. This native array is unsafe to be written on,
		as it may or may not be linked to the actual Array implementation.

		If equalLengthRequired is true, the result might be a copy of an array with the correct size.</haxe_doc>
		</nativeArray>
		<nativeType public="1" params="T" set="method" line="55" static="1">
			<f a="obj">
				<c path="nativeType.T"/>
				<c path="java.lang.Class"><c path="nativeType.T"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn (java.lang.Class<T>) obj.getClass();\n\t"]]></e></m></meta>
			<haxe_doc>Gets the native System.Type from the supplied object. Will throw an exception in case of null being passed.</haxe_doc>
		</nativeType>
		<array public="1" params="T" set="method" line="65" static="1">
			<f a="native">
				<c path="java.NativeArray"><c path="array.T"/></c>
				<c path="Array"><c path="array.T"/></c>
			</f>
			<haxe_doc>Returns a Haxe Array of a native Array.
		It won't copy the contents of the native array, so unless any operation triggers an array resize,
		all changes made to the Haxe array will affect the native array argument.</haxe_doc>
		</array>
		<arrayAlloc public="1" params="T" set="method" line="73" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="Array"><c path="arrayAlloc.T"/></c>
			</f>
			<haxe_doc>Allocates a new Haxe Array with a predetermined size</haxe_doc>
		</arrayAlloc>
		<lock public="1" get="inline" set="null" line="86" static="1">
			<f a="obj:block">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Ensures that one thread does not enter a critical section of code while another thread
		is in the critical section. If another thread attempts to enter a locked code, it
		will wait, block, until the object is released.
		This is the equivalent to "synchronized" in java code.

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</lock>
		<haxe_doc>Platform-specific Java Library. Provides some platform-specific functions for the Java target,
	such as conversion from haxe types to native types and vice-versa.</haxe_doc>
		<meta><m n=":native"><e>"haxe.java.Lib"</e></m></meta>
	</class>
	<class path="java.NativeArray" params="T" file="/usr/lib/haxe/std/java/NativeArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<new public="1" set="method"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<abstract path="java.Int8" params="" file="/usr/lib/haxe/std/java/StdTypes.hx" module="java.StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
		<meta>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="java.Int16" params="" file="/usr/lib/haxe/std/java/StdTypes.hx" module="java.StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<meta>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="java.Char16" params="" file="/usr/lib/haxe/std/java/StdTypes.hx" module="java.StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<meta>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<class path="java.lang.Throwable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getMessage public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getMessage>
		<getLocalizedMessage public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalizedMessage>
		<getCause public="1" set="method">
			<f a=""><c path="java.lang.Throwable"/></f>
			<meta><m n=":overload"/></meta>
		</getCause>
		<initCause public="1" set="method">
			<f a="param1">
				<c path="java.lang.Throwable"/>
				<c path="java.lang.Throwable"/>
			</f>
			<meta><m n=":overload"/></meta>
		</initCause>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<printStackTrace public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<printStackTrace public="1" set="method">
					<f a="param1">
						<c path="java.io.PrintWriter"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</printStackTrace>
				<printStackTrace public="1" set="method">
					<f a="param1">
						<c path="java.io.PrintStream"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</printStackTrace>
			</overloads>
		</printStackTrace>
		<fillInStackTrace public="1" set="method">
			<f a=""><c path="java.lang.Throwable"/></f>
			<meta><m n=":overload"/></meta>
		</fillInStackTrace>
		<getStackTrace public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.StackTraceElement"/></c></f>
			<meta><m n=":overload"/></meta>
		</getStackTrace>
		<setStackTrace public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><c path="java.lang.StackTraceElement"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setStackTrace>
		<addSuppressed public="1" set="method">
			<f a="param1">
				<c path="java.lang.Throwable"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</addSuppressed>
		<getSuppressed public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Throwable"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getSuppressed>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new set="method">
					<f a="param1:param2:param3:param4">
						<c path="String"/>
						<c path="java.lang.Throwable"/>
						<x path="Bool"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Throwable"</e></m>
		</meta>
	</class>
	<class path="java.lang.Exception" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Exception.class" extern="1">
		<extends path="java.lang.Throwable"/>
		<new set="method">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="java.lang.Throwable"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Exception"</e></m>
		</meta>
	</class>
	<class path="java.lang.RuntimeException" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/RuntimeException.class" extern="1">
		<extends path="java.lang.Exception"/>
		<new set="method">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="java.lang.Throwable"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.RuntimeException"</e></m>
		</meta>
	</class>
	<class path="java.internal._Exceptions.HaxeException" params="" file="/usr/lib/haxe/std/java/internal/Exceptions.hx" private="1" module="java.internal.Exceptions">
		<extends path="java.lang.RuntimeException"/>
		<wrap public="1" set="method" line="54" static="1"><f a="obj">
	<d/>
	<c path="java.lang.RuntimeException"/>
</f></wrap>
		<obj><d/></obj>
		<getObject public="1" set="method" line="44"><f a=""><d/></f></getObject>
		<toString public="1" set="method" line="49" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method" line="31"><f a="obj:msg:cause">
	<d/>
	<c path="String"/>
	<c path="java.lang.Throwable"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.HaxeException"</e></m>
		</meta>
	</class>
	<class path="java.internal._FieldLookup.FieldLookup" params="" file="/usr/lib/haxe/std/java/internal/FieldLookup.hx" private="1" module="java.internal.FieldLookup">
		<hash public="1" set="method" line="32" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn s.hashCode();\n\t"</e></m></meta>
		</hash>
		<findHash public="1" set="method" line="37" static="1"><f a="hash:hashs">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Int"/>
</f></findHash>
		<meta>
			<m n=":native"><e>"haxe.lang.FieldLookup"</e></m>
			<m n=":keep"/>
			<m n=":static"/>
		</meta>
	</class>
	<class path="java.internal._Function.Function" params="" file="/usr/lib/haxe/std/java/internal/Function.hx" private="1" module="java.internal.Function">
		<new set="method" line="34"><f a="arity:type">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* These classes are automatically generated by the compiler. They are only
 * here so there is an option for e.g. defining them as externs if you are compiling
 * in modules (untested)
 *
 * @author waneck</haxe_doc>
		<meta>
			<m n=":abstract"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Function"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal._Function.VarArgsBase" params="" file="/usr/lib/haxe/std/java/internal/Function.hx" private="1" module="java.internal.Function">
		<extends path="java.internal._Function.Function"/>
		<__hx_invokeDynamic public="1" set="method" line="42"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsBase"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.VarArgsFunction" params="" file="/usr/lib/haxe/std/java/internal/Function.hx" module="java.internal.Function">
		<extends path="java.internal._Function.VarArgsBase"/>
		<fun><f a="">
	<c path="Array"><d/></c>
	<d/>
</f></fun>
		<__hx_invokeDynamic public="1" set="method" line="59" override="1"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<new public="1" set="method" line="53"><f a="fun">
	<f a="">
		<c path="Array"><d/></c>
		<d/>
	</f>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsFunction"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.Closure" params="" file="/usr/lib/haxe/std/java/internal/Function.hx" module="java.internal.Function">
		<extends path="java.internal._Function.VarArgsBase"/>
		<obj><d/></obj>
		<field><c path="String"/></field>
		<__hx_invokeDynamic public="1" set="method" line="77" override="1"><f a="dynArgs">
	<c path="Array"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<new public="1" set="method" line="70"><f a="obj:field">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Closure"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<typedef path="java.internal._HxObject.StdType" params="" file="/usr/lib/haxe/std/java/internal/HxObject.hx" private="1" module="java.internal.HxObject"><c path="Type"/></typedef>
	<class path="java.internal._HxObject.IHxObject" params="" file="/usr/lib/haxe/std/java/internal/HxObject.hx" private="1" module="java.internal.HxObject" interface="1"><meta>
	<m n=":native"><e>"haxe.lang.IHxObject"</e></m>
	<m n=":keep"/>
</meta></class>
	<class path="java.internal._HxObject.HxObject" params="" file="/usr/lib/haxe/std/java/internal/HxObject.hx" private="1" module="java.internal.HxObject">
		<implements path="java.internal._HxObject.IHxObject"/>
		<meta>
			<m n=":native"><e>"haxe.lang.HxObject"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal._HxObject.DynamicObject" params="" file="/usr/lib/haxe/std/java/internal/HxObject.hx" private="1" module="java.internal.HxObject">
		<extends path="java.internal._HxObject.HxObject"/>
		<toString public="1" set="method" line="43">
			<f a=""><c path="String"/></f>
			<meta><m n=":skipReflection"/></meta>
		</toString>
		<meta>
			<m n=":native"><e>"haxe.lang.DynamicObject"</e></m>
			<m n=":replaceReflection"/>
			<m n=":keep"/>
		</meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="java.internal._HxObject.Enum" params="" file="/usr/lib/haxe/std/java/internal/HxObject.hx" private="1" module="java.internal.HxObject">
		<index>
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</index>
		<params>
			<c path="Array"><a/></c>
			<meta><m n=":readOnly"/></meta>
		</params>
		<getTag public="1" set="method" line="81">
			<f a=""><c path="String"/></f>
			<meta><m n=":final"/></meta>
		</getTag>
		<toString public="1" set="method" line="86"><f a=""><c path="String"/></f></toString>
		<equals public="1" set="method" line="103"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></equals>
		<hashCode public="1" set="method" line="124"><f a=""><x path="Int"/></f></hashCode>
		<new public="1" set="method" line="76"><f a="index:params">
	<x path="Int"/>
	<c path="Array"><a/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":native"><e>"haxe.lang.Enum"</e></m>
			<m n=":nativeGen"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.IEquatable" params="" file="/usr/lib/haxe/std/java/internal/IEquatable.hx" interface="1">
		<equals public="1" set="method"><f a="to">
	<d/>
	<x path="Bool"/>
</f></equals>
		<meta>
			<m n=":native"><e>"haxe.lang.IEquatable"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.Iterator" params="T" file="/usr/lib/haxe/std/java/internal/Iterator.hx" interface="1">
		<hasNext public="1" set="method"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><c path="java.internal.Iterator.T"/></f></next>
		<meta>
			<m n=":native"><e>"haxe.lang.Iterator"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.Iterable" params="T" file="/usr/lib/haxe/std/java/internal/Iterator.hx" module="java.internal.Iterator" interface="1">
		<iterator public="1" set="method"><f a=""><c path="java.internal.Iterator"><c path="java.internal.Iterable.T"/></c></f></iterator>
		<meta>
			<m n=":native"><e>"haxe.lang.Iterable"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="java.internal.Runtime" params="" file="/usr/lib/haxe/std/java/internal/Runtime.hx">
		<undefined public="1" line="61" static="1"><d/></undefined>
		<closure public="1" set="method" line="66" static="1">
			<f a="obj:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\treturn new haxe.lang.Closure(obj, field);\n\t"</e></m></meta>
		</closure>
		<eq public="1" set="method" line="93" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (v1 == v2)\n\t\t\t\treturn true;\n\t\t\tif (v1 == null || v2 == null)\n\t\t\t\treturn false;\n\n\t\t\tif (v1 instanceof java.lang.Number)\n\t\t\t{\n\t\t\t\tif (!(v2 instanceof java.lang.Number))\n\t\t\t\t\treturn false;\n\n\t\t\t\tjava.lang.Number v1c = (java.lang.Number) v1;\n\t\t\t\tjava.lang.Number v2c = (java.lang.Number) v2;\n\t\t\t\tif (v1 instanceof java.lang.Long || v2 instanceof java.lang.Long)\n\t\t\t\t\treturn v1c.longValue() == v2c.longValue();\n\t\t\t\treturn v1c.doubleValue() == v2c.doubleValue();\n\t\t\t} else if (v1 instanceof java.lang.String || v1 instanceof haxe.lang.IEquatable) { //TODO see what happens with Boolean cases\n\t\t\t\treturn v1.equals(v2);\n\t\t\t}\n\n\t\t\treturn false;\n\t"</e></m></meta>
		</eq>
		<refEq public="1" set="method" line="109" static="1">
			<f a="v1:v2">
				<a/>
				<a/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (v1 == v2)\n\t\t\treturn true;\n\n\t\tif (v1 instanceof java.lang.String || v1 instanceof haxe.lang.IEquatable)\n\t\t{\n\t\t\treturn v1 != null && v1.equals(v2);\n\t\t} else {\n\t\t\treturn v1 == v2;\n\t\t}\n\t"]]></e></m></meta>
		</refEq>
		<valEq public="1" set="method" line="117" static="1">
			<f a="v1:v2">
				<a/>
				<a/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\treturn v1 == v2 || (v1 != null && v1.equals(v2));\n\t"]]></e></m></meta>
		</valEq>
		<toDouble public="1" set="method" line="125" static="1">
			<f a="obj">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (obj == null) ? 0.0 : ((java.lang.Number) obj).doubleValue();\n\t"</e></m></meta>
		</toDouble>
		<toBool public="1" set="method" line="133" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (obj == null) ? false : ((java.lang.Boolean) obj).booleanValue();\n\t"</e></m></meta>
		</toBool>
		<toInt public="1" set="method" line="141" static="1">
			<f a="obj">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (obj == null) ? 0 : ((java.lang.Number) obj).intValue();\n\t"</e></m></meta>
		</toInt>
		<isDouble public="1" set="method" line="154" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (obj != null && obj instanceof java.lang.Number)\n\t\t{\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t"]]></e></m></meta>
		</isDouble>
		<isInt public="1" set="method" line="168" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (obj != null && obj instanceof java.lang.Number)\n\t\t{\n\t\t\tjava.lang.Number n = (java.lang.Number) obj;\n\t\t\treturn n.doubleValue() == n.intValue();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t"]]></e></m></meta>
		</isInt>
		<slowHasField public="1" set="method" line="206" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tjava.lang.Class cl = null;\n\t\tif (o instanceof java.lang.Class)\n\t\t{\n\t\t\tif (o == java.lang.String.class)\n\t\t\t\treturn field.equals(\"fromCharCode\");\n\n\t\t\tcl = (java.lang.Class) o;\n\t\t} else if (o instanceof java.lang.String) {\n\t\t\treturn haxe.lang.StringRefl.handleGetField( (java.lang.String) o, field, false) != null;\n\t\t} else {\n\t\t\tcl = o.getClass();\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tjava.lang.reflect.Field f = cl.getField(field);\n\t\t\treturn true;\n\t\t}\n\t\tcatch(Throwable t)\n\t\t{\n\t\t\tjava.lang.reflect.Method[] ms = cl.getMethods();\n\t\t\tfor (int i = 0; i < ms.length; i++)\n\t\t\t{\n\t\t\t\tif (ms[i].getName().equals(field))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t"]]></e></m></meta>
		</slowHasField>
		<compare public="1" set="method" line="237" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (v1 == v2)\n\t\t\t\treturn 0;\n\t\t\tif (v1 == null) return -1;\n\t\t\tif (v2 == null) return 1;\n\n\t\t\tif (v1 instanceof java.lang.Number || v2 instanceof java.lang.Number)\n\t\t\t{\n\t\t\t\tjava.lang.Number v1c = (java.lang.Number) v1;\n\t\t\t\tjava.lang.Number v2c = (java.lang.Number) v2;\n\n\t\t\t\tif (v1 instanceof java.lang.Long || v2 instanceof java.lang.Long)\n\t\t\t\t{\n\t\t\t\t\tlong l1 = (v1 == null) ? 0L : v1c.longValue();\n\t\t\t\t\tlong l2 = (v2 == null) ? 0L : v2c.longValue();\n\t\t\t\t\treturn (int) (l1 - l2);\n\t\t\t\t} else {\n\t\t\t\t\tdouble d1 = (v1 == null) ? 0.0 : v1c.doubleValue();\n\t\t\t\t\tdouble d2 = (v2 == null) ? 0.0 : v2c.doubleValue();\n\n\t\t\t\t\treturn (int) (d1 - d2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if it's not a number it must be a String\n\t\t\treturn ((java.lang.String) v1).compareTo((java.lang.String) v2);\n\t"</e></m></meta>
		</compare>
		<plus public="1" set="method" line="259" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\tif (v1 instanceof java.lang.String || v2 instanceof java.lang.String)\n\t\t\t\treturn toString(v1) + toString(v2);\n\n\t\t\tif (v1 instanceof java.lang.Number || v2 instanceof java.lang.Number)\n\t\t\t{\n\t\t\t\tjava.lang.Number v1c = (java.lang.Number) v1;\n\t\t\t\tjava.lang.Number v2c = (java.lang.Number) v2;\n\n\t\t\t\tdouble d1 = (v1 == null) ? 0.0 : v1c.doubleValue();\n\t\t\t\tdouble d2 = (v2 == null) ? 0.0 : v2c.doubleValue();\n\n\t\t\t\treturn d1 + d2;\n\t\t\t}\n\n\t\t\tthrow new java.lang.IllegalArgumentException(\"Cannot dynamically add \" + v1 + \" and \" + v2);\n\t"</e></m></meta>
		</plus>
		<slowGetField public="1" set="method" line="315" static="1">
			<f a="obj:field:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\n\tif (obj == null)\n\t\tif (throwErrors)\n\t\t\tthrow new java.lang.NullPointerException(\"Cannot access field '\" + field + \"' of null.\");\n\t\telse\n\t\t\treturn null;\n\n\tjava.lang.Class cl = null;\n\ttry\n\t{\n\t\tif (obj instanceof java.lang.Class)\n\t\t{\n\t\t\tif (obj == java.lang.String.class && field.equals(\"fromCharCode\"))\n\t\t\t\treturn new haxe.lang.Closure(haxe.lang.StringExt.class, field);\n\n\t\t\tcl = (java.lang.Class) obj;\n\t\t\tobj = null;\n\t\t} else if (obj instanceof java.lang.String) {\n\t\t\treturn haxe.lang.StringRefl.handleGetField((java.lang.String) obj, field, throwErrors);\n\t\t} else {\n\t\t\tcl = obj.getClass();\n\t\t}\n\n\t\tjava.lang.reflect.Field f = cl.getField(field);\n\t\tf.setAccessible(true);\n\t\treturn f.get(obj);\n\t} catch (Throwable t)\n\t{\n\t\ttry\n\t\t{\n\t\t\tjava.lang.reflect.Method[] ms = cl.getMethods();\n\t\t\tfor (int i = 0; i < ms.length; i++)\n\t\t\t{\n\t\t\t\tif (ms[i].getName().equals(field))\n\t\t\t\t{\n\t\t\t\t\treturn new haxe.lang.Closure(obj != null ? obj : cl, field);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Throwable t2)\n\t\t{\n\n\t\t}\n\n\t\tif (throwErrors)\n\t\t\tthrow HaxeException.wrap(t);\n\n\t\treturn null;\n\t}\n\n\t"]]></e></m></meta>
		</slowGetField>
		<slowSetField public="1" set="method" line="350" static="1">
			<f a="obj:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tjava.lang.Class cl = null;\n\t\tif (obj instanceof java.lang.Class)\n\t\t{\n\t\t\tcl = (java.lang.Class) obj;\n\t\t\tobj = null;\n\t\t} else {\n\t\t\tcl = obj.getClass();\n\t\t}\n\n\t\ttry {\n\t\t\tjava.lang.reflect.Field f = cl.getField(field);\n\t\t\tf.setAccessible(true);\n\n\t\t\t//FIXME we must evaluate if field to be set receives either int or double\n\t\t\tif (isInt(value))\n\t\t\t{\n\t\t\t\tf.setInt(obj, toInt(value));\n\t\t\t} else if (isDouble(value)) {\n\t\t\t\tf.setDouble(obj, toDouble(value));\n\t\t\t} else {\n\t\t\t\tf.set(obj, value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tcatch (Throwable t)\n\t\t{\n\t\t\tthrow HaxeException.wrap(t);\n\t\t}\n\t"</e></m></meta>
		</slowSetField>
		<slowCallField public="1" set="method" line="486" static="1">
			<f a="obj:field:args">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tjava.lang.Class cl = null;\n\t\tif (obj instanceof java.lang.Class)\n\t\t{\n\t\t\tif (obj == java.lang.String.class && field.equals(\"fromCharCode\"))\n\t\t\t\treturn haxe.lang.StringExt.fromCharCode(toInt(args.__get(0)));\n\n\t\t\tcl = (java.lang.Class) obj;\n\t\t\tobj = null;\n\t\t} else if (obj instanceof java.lang.String) {\n\t\t\treturn haxe.lang.StringRefl.handleCallField((java.lang.String) obj, field, args);\n\t\t} else {\n\t\t\tcl = obj.getClass();\n\t\t}\n\n\t\tif (args == null) args = new Array();\n\n\t\tint len = args.length;\n\t\tjava.lang.Class[] cls = new java.lang.Class[len];\n\t\tjava.lang.Object[] objs = new java.lang.Object[len];\n\n\t\tjava.lang.reflect.Method[] ms = cl.getDeclaredMethods();\n\t\tint msl = ms.length;\n\t\tint realMsl = 0;\n\t\tfor(int i =0; i < msl; i++)\n\t\t{\n\t\t\tif (!ms[i].getName().equals(field) || (!ms[i].isVarArgs() && ms[i].getParameterTypes().length != len))\n\t\t\t{\n\t\t\t\tms[i] = null;\n\t\t\t} else {\n\t\t\t\tms[realMsl] = ms[i];\n\t\t\t\tif (realMsl != i)\n\t\t\t\t\tms[i] = null;\n\t\t\t\trealMsl++;\n\t\t\t}\n\t\t}\n\n\t\tboolean hasNumber = false;\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\tObject o = args.__get(i);\n\t\t\tobjs[i]= o;\n\t\t\tcls[i] = o.getClass();\n\t\t\tboolean isNum = false;\n\n\t\t\tif (o instanceof java.lang.Number)\n\t\t\t{\n\t\t\t\tcls[i] = java.lang.Number.class;\n\t\t\t\tisNum = hasNumber = true;\n\t\t\t}\n\n\t\t\tmsl = realMsl;\n\t\t\trealMsl = 0;\n\n\t\t\tfor (int j = 0; j < msl; j++)\n\t\t\t{\n\t\t\t\tjava.lang.Class[] allcls = ms[j].getParameterTypes();\n\t\t\t\tif (i < allcls.length)\n\t\t\t\t{\n\t\t\t\t\tif (!  ((isNum && allcls[i].isPrimitive()) || allcls[i].isAssignableFrom(cls[i])) )\n\t\t\t\t\t{\n\t\t\t\t\t\tms[j] = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tms[realMsl] = ms[j];\n\t\t\t\t\t\tif (realMsl != j)\n\t\t\t\t\t\t\tms[j] = null;\n\t\t\t\t\t\trealMsl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tjava.lang.reflect.Method found;\n\t\tif (ms.length == 0 || (found = ms[0]) == null)\n\t\t\tthrow haxe.lang.HaxeException.wrap(\"No compatible method found for: \" + field);\n\n\t\tif (hasNumber)\n\t\t{\n\t\t\tjava.lang.Class[] allcls = found.getParameterTypes();\n\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tjava.lang.Object o = objs[i];\n\t\t\t\tif (o instanceof java.lang.Number)\n\t\t\t\t{\n\t\t\t\t\tjava.lang.Class curCls = null;\n\t\t\t\t\tif (i < allcls.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurCls = allcls[i];\n\t\t\t\t\t\tif (!curCls.isAssignableFrom(o.getClass()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString name = curCls.getName();\n\t\t\t\t\t\t\tif (name.equals(\"double\") || name.equals(\"java.lang.Double\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).doubleValue();\n\t\t\t\t\t\t\t} else if (name.equals(\"int\") || name.equals(\"java.lang.Integer\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).intValue();\n\t\t\t\t\t\t\t} else if (name.equals(\"float\") || name.equals(\"java.lang.Float\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).floatValue();\n\t\t\t\t\t\t\t} else if (name.equals(\"byte\") || name.equals(\"java.lang.Byte\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).byteValue();\n\t\t\t\t\t\t\t} else if (name.equals(\"short\") || name.equals(\"java.lang.Short\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjs[i] = ((java.lang.Number)o).shortValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} //else varargs not handled TODO\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfound.setAccessible(true);\n\t\t\treturn found.invoke(obj, objs);\n\t\t}\n\n\t\tcatch (java.lang.reflect.InvocationTargetException e)\n\t\t{\n\t\t\tthrow haxe.lang.HaxeException.wrap(e.getCause());\n\t\t}\n\n\t\tcatch (Throwable t)\n\t\t{\n\t\t\tthrow haxe.lang.HaxeException.wrap(t);\n\t\t}\n\t"]]></e></m></meta>
		</slowCallField>
		<callField public="1" set="method" line="499" static="1">
			<f a="obj:field:args">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (obj instanceof haxe.lang.IHxObject)\n\t\t{\n\t\t\treturn ((haxe.lang.IHxObject) obj).__hx_invokeField(field, args);\n\t\t}\n\n\t\treturn slowCallField(obj, field, args);\n\t"</e></m></meta>
		</callField>
		<getField public="1" set="method" line="512" static="1">
			<f a="obj:field:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\tif (obj instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) obj).__hx_getField(field, throwErrors, false, false);\n\n\t\treturn slowGetField(obj, field, throwErrors);\n\n\t"</e></m></meta>
		</getField>
		<getField_f public="1" set="method" line="525" static="1">
			<f a="obj:field:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\tif (obj instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) obj).__hx_getField_f(field, throwErrors, false);\n\n\t\treturn toDouble(slowGetField(obj, field, throwErrors));\n\n\t"</e></m></meta>
		</getField_f>
		<setField public="1" set="method" line="538" static="1">
			<f a="obj:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\tif (obj instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) obj).__hx_setField(field, value, false);\n\n\t\treturn slowSetField(obj, field, value);\n\n\t"</e></m></meta>
		</setField>
		<setField_f public="1" set="method" line="551" static="1">
			<f a="obj:field:value">
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\n\t\tif (obj instanceof haxe.lang.IHxObject)\n\t\t\treturn ((haxe.lang.IHxObject) obj).__hx_setField_f(field, value, false);\n\n\t\treturn toDouble(slowSetField(obj, field, value));\n\n\t"</e></m></meta>
		</setField_f>
		<toString public="1" set="method" line="556" static="1"><f a="obj">
	<d/>
	<c path="String"/>
</f></toString>
		<isFinite public="1" set="method" line="566" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<haxe_doc>This class is meant for internal compiler use only. It provides the Haxe runtime
 compatibility to the host language. Do not access it directly.</haxe_doc>
		<meta>
			<m n=":native"><e>"haxe.lang.Runtime"</e></m>
			<m n=":nativeGen"/>
			<m n=":classCode"><e><![CDATA["\n\tpublic static java.lang.Object getField(haxe.lang.IHxObject obj, java.lang.String field, boolean throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return null;\n\t\treturn obj.__hx_getField(field, throwErrors, false, false);\n\t}\n\n\tpublic static double getField_f(haxe.lang.IHxObject obj, java.lang.String field, boolean throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return 0.0;\n\t\treturn obj.__hx_getField_f(field, throwErrors, false);\n\t}\n\n\tpublic static java.lang.Object setField(haxe.lang.IHxObject obj, java.lang.String field, java.lang.Object value)\n\t{\n\t\treturn obj.__hx_setField(field, value, false);\n\t}\n\n\tpublic static double setField_f(haxe.lang.IHxObject obj, java.lang.String field, double value)\n\t{\n\t\treturn obj.__hx_setField_f(field, value, false);\n\t}\n\n\tpublic static java.lang.Object callField(haxe.lang.IHxObject obj, java.lang.String field, Array<?> args)\n\t{\n\t\treturn obj.__hx_invokeField(field, args);\n\t}\n"]]></e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="java.internal._Runtime.EmptyObject" params="" file="/usr/lib/haxe/std/java/internal/Runtime.hx" private="1" module="java.internal.Runtime">
		<EMPTY/>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.EmptyObject"</e></m>
		</meta>
	</enum>
	<typedef path="java.internal._StringExt.NativeString" params="" file="/usr/lib/haxe/std/java/internal/StringExt.hx" private="1" module="java.internal.StringExt"><c path="String"/></typedef>
	<class path="java.internal._StringExt.StringExt" params="" file="/usr/lib/haxe/std/java/internal/StringExt.hx" private="1" module="java.internal.StringExt">
		<charAt public="1" set="method" line="36" static="1">
			<f a="me:index">
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif ( index >= me.length() || index < 0 )\n\t\t\t\treturn \"\";\n\t\t\telse\n\t\t\t\treturn java.lang.Character.toString(me.charAt(index));\n\t"]]></e></m></meta>
		</charAt>
		<charCodeAt public="1" set="method" line="47" static="1">
			<f a="me:index">
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tif ( index >= me.length() || index < 0 )\n\t\t\t\treturn null;\n\t\t\telse\n\t\t\t\treturn me.codePointAt(index);\n\t"]]></e></m></meta>
		</charCodeAt>
		<indexOf public="1" set="method" line="58" static="1">
			<f a="me:str:?startIndex">
				<t path="java.internal._StringExt.NativeString"/>
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint sIndex = (startIndex != null ) ? (haxe.lang.Runtime.toInt(startIndex)) : 0;\n\t\t\tif (sIndex >= me.length() || sIndex < 0)\n\t\t\t\treturn -1;\n\t\t\treturn me.indexOf(str, sIndex);\n\t"]]></e></m></meta>
		</indexOf>
		<lastIndexOf public="1" set="method" line="71" static="1">
			<f a="me:str:?startIndex">
				<t path="java.internal._StringExt.NativeString"/>
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint sIndex = (startIndex != null ) ? (haxe.lang.Runtime.toInt(startIndex)) : (me.length() - 1);\n\t\t\tif (sIndex > me.length() || sIndex < 0)\n\t\t\t\tsIndex = me.length() - 1;\n\t\t\telse if (sIndex < 0)\n\t\t\t\treturn -1;\n\t\t\treturn me.lastIndexOf(str, sIndex);\n\t"]]></e></m></meta>
		</lastIndexOf>
		<split public="1" set="method" line="103" static="1">
			<f a="me:delimiter">
				<t path="java.internal._StringExt.NativeString"/>
				<t path="java.internal._StringExt.NativeString"/>
				<c path="Array"><t path="java.internal._StringExt.NativeString"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tArray<java.lang.String> ret = new Array<java.lang.String>();\n\n\t\t\tint slen = delimiter.length();\n\t\t\tif (slen == 0)\n\t\t\t{\n\t\t\t\tint len = me.length();\n\t\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tret.push(me.substring(i, i + 1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint start = 0;\n\t\t\t\tint pos = me.indexOf(delimiter, start);\n\n\t\t\t\twhile (pos >= 0)\n\t\t\t\t{\n\t\t\t\t\tret.push(me.substring(start, pos));\n\n\t\t\t\t\tstart = pos + slen;\n\t\t\t\t\tpos = me.indexOf(delimiter, start);\n\t\t\t\t}\n\n\t\t\t\tret.push(me.substring(start));\n\t\t\t}\n\t\t\treturn ret;\n\t"]]></e></m></meta>
		</split>
		<substr public="1" set="method" line="136" static="1">
			<f a="me:pos:?len">
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\t\tint meLen = me.length();\n\t\t\tint targetLen = meLen;\n\t\t\tif (len != null)\n\t\t\t{\n\t\t\t\ttargetLen = haxe.lang.Runtime.toInt(len);\n\t\t\t\tif (targetLen == 0)\n\t\t\t\t\treturn \"\";\n\t\t\t\tif( pos != 0 && targetLen < 0 ){\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( pos < 0 ){\n\t\t\t\tpos = meLen + pos;\n\t\t\t\tif( pos < 0 ) pos = 0;\n\t\t\t} else if( targetLen < 0 ){\n\t\t\t\ttargetLen = meLen + targetLen - pos;\n\t\t\t}\n\n\t\t\tif( pos + targetLen > meLen ){\n\t\t\t\ttargetLen = meLen - pos;\n\t\t\t}\n\n\t\t\tif ( pos < 0 || targetLen <= 0 ) return \"\";\n\n\t\t\treturn me.substring(pos, pos + targetLen);\n\t"]]></e></m></meta>
		</substr>
		<substring public="1" set="method" line="167" static="1">
			<f a="me:startIndex:?endIndex">
				<t path="java.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tint endIdx;\n\t\tint len = me.length();\n\t\tif ( endIndex == null) {\n\t\t\tendIdx = len;\n\t\t} else if ( (endIdx = haxe.lang.Runtime.toInt(endIndex)) < 0 ) {\n\t\t\tendIdx = 0;\n\t\t} else if ( endIdx > len ) {\n\t\t\tendIdx = len;\n\t\t}\n\n\t\tif ( startIndex < 0 ) {\n\t\t\tstartIndex = 0;\n\t\t} else if ( startIndex > len ) {\n\t\t\tstartIndex = len;\n\t\t}\n\n\t\tif ( startIndex > endIdx ) {\n\t\t\tint tmp = startIndex;\n\t\t\tstartIndex = endIdx;\n\t\t\tendIdx = tmp;\n\t\t}\n\n\t\treturn me.substring(startIndex, endIdx);\n\n\t"]]></e></m></meta>
		</substring>
		<toLowerCase public="1" set="method" line="175" static="1">
			<f a="me">
				<t path="java.internal._StringExt.NativeString"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\treturn me.toLowerCase();\n\t"</e></m></meta>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="183" static="1">
			<f a="me">
				<t path="java.internal._StringExt.NativeString"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\t\treturn me.toUpperCase();\n\t"</e></m></meta>
		</toUpperCase>
		<toNativeString public="1" set="method" line="188" static="1"><f a="me">
	<t path="java.internal._StringExt.NativeString"/>
	<t path="java.internal._StringExt.NativeString"/>
</f></toNativeString>
		<fromCharCode public="1" set="method" line="196" static="1">
			<f a="code">
				<x path="Int"/>
				<t path="java.internal._StringExt.NativeString"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn java.lang.Character.toString( (char) code );\n\t"</e></m></meta>
		</fromCharCode>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringExt"</e></m>
		</meta>
	</class>
	<class path="java.internal._StringExt.StringRefl" params="" file="/usr/lib/haxe/std/java/internal/StringExt.hx" private="1" module="java.internal.StringExt">
		<fields public="1" line="204" static="1"><c path="Array"><c path="String"/></c></fields>
		<handleGetField public="1" set="method" line="206" static="1"><f a="str:f:throwErrors">
	<t path="java.internal._StringExt.NativeString"/>
	<t path="java.internal._StringExt.NativeString"/>
	<x path="Bool"/>
	<d/>
</f></handleGetField>
		<handleCallField public="1" set="method" line="221" static="1"><f a="str:f:args">
	<t path="java.internal._StringExt.NativeString"/>
	<t path="java.internal._StringExt.NativeString"/>
	<c path="Array"><d/></c>
	<d/>
</f></handleCallField>
		<meta>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringRefl"</e></m>
		</meta>
	</class>
	<class path="java.internal._StringExt.JavaString" params="" file="/usr/lib/haxe/std/java/internal/StringExt.hx" private="1" module="java.internal.StringExt" extern="1">
		<_charAt public="1" set="method"><f a="idx">
	<x path="Int"/>
	<x path="java.Char16"/>
</f></_charAt>
		<codePointAt public="1" set="method"><f a="idx">
	<x path="Int"/>
	<x path="Int"/>
</f></codePointAt>
		<codePointBefore public="1" set="method"><f a="idx">
	<x path="Int"/>
	<x path="Int"/>
</f></codePointBefore>
		<codePointCount public="1" set="method"><f a="begin:end">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></codePointCount>
		<offsetByCodePoints public="1" set="method"><f a="index:codePointOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></offsetByCodePoints>
		<getChars public="1" set="method"><f a="srcBegin:srcEnd:dst:dstBegin">
	<x path="Int"/>
	<x path="Int"/>
	<c path="java.NativeArray"><x path="java.Char16"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></getChars>
		<startsWith public="1" set="method"><f a="prefix">
	<c path="String"/>
	<x path="Bool"/>
</f></startsWith>
		<endsWith public="1" set="method"><f a="suffix">
	<c path="String"/>
	<x path="Bool"/>
</f></endsWith>
		<_indexOf public="1" set="method"><f a="str:fromIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_indexOf>
		<_lastIndexOf public="1" set="method"><f a="str:fromIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_lastIndexOf>
		<_substring public="1" set="method"><f a="begin:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></_substring>
		<replace public="1" set="method"><f a="old:nw">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></replace>
		<_split public="1" set="method"><f a="regex">
	<c path="String"/>
	<c path="java.NativeArray"><c path="String"/></c>
</f></_split>
		<trim public="1" set="method"><f a=""><c path="String"/></f></trim>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.NativeString"</e></m>
		</meta>
	</class>
	<class path="java.lang.AutoCloseable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/AutoCloseable.class" extern="1" interface="1">
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.AutoCloseable"</e></m>
		</meta>
	</class>
	<class path="java.io.Closeable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Closeable.class" extern="1" interface="1">
		<extends path="java.lang.AutoCloseable"/>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Closeable"</e></m>
		</meta>
	</class>
	<class path="java.io.Flushable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Flushable.class" extern="1" interface="1">
		<flush public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Flushable"</e></m>
		</meta>
	</class>
	<class path="java.io.OutputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/OutputStream.class" extern="1">
		<implements path="java.io.Closeable"/>
		<implements path="java.io.Flushable"/>
		<write public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<flush public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.OutputStream"</e></m>
		</meta>
	</class>
	<class path="java.io.ByteArrayOutputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/ByteArrayOutputStream.class" extern="1">
		<extends path="java.io.OutputStream"/>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<write public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><write public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</write></overloads>
		</write>
		<writeTo public="1" set="method">
			<f a="param1">
				<c path="java.io.OutputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</writeTo>
		<reset public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</reset>
		<toByteArray public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</toByteArray>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<toString public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</toString>
				<toString public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="String"/>
					</f>
					<meta><m n=":overload"/></meta>
				</toString>
			</overloads>
		</toString>
		<count><x path="Int"/></count>
		<buf><c path="java.NativeArray"><t path="java.types.Int8"/></c></buf>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.ByteArrayOutputStream"</e></m>
		</meta>
	</class>
	<class path="java.io.Console" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Console.class" extern="1">
		<implements path="java.io.Flushable"/>
		<writer public="1" set="method">
			<f a=""><c path="java.io.PrintWriter"/></f>
			<meta><m n=":overload"/></meta>
		</writer>
		<reader public="1" set="method">
			<f a=""><c path="java.io.Reader"/></f>
			<meta><m n=":overload"/></meta>
		</reader>
		<format public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.Console"/>
			</f>
			<meta><m n=":overload"/></meta>
		</format>
		<printf public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.Console"/>
			</f>
			<meta><m n=":overload"/></meta>
		</printf>
		<readLine public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><readLine public="1" set="method">
	<f a=""><c path="String"/></f>
	<meta><m n=":overload"/></meta>
</readLine></overloads>
		</readLine>
		<readPassword public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><readPassword public="1" set="method">
	<f a=""><c path="java.NativeArray"><t path="java.types.Char16"/></c></f>
	<meta><m n=":overload"/></meta>
</readPassword></overloads>
		</readPassword>
		<flush public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Console"</e></m>
		</meta>
	</class>
	<class path="java.lang.Readable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Readable.class" extern="1" interface="1">
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.CharBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Readable"</e></m>
		</meta>
	</class>
	<class path="java.io.Reader" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Reader.class" extern="1">
		<implements path="java.lang.Readable"/>
		<implements path="java.io.Closeable"/>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.CharBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a=""><x path="Int"/></f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<skip public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</skip>
		<ready public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</ready>
		<markSupported public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</markSupported>
		<mark public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</mark>
		<reset public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</reset>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<lock><d/></lock>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new set="method">
	<f a="param1">
		<d/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Reader"</e></m>
		</meta>
	</class>
	<class path="java.io.Console_LineReader" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Console$LineReader.class" module="java.io.Console" extern="1">
		<extends path="java.io.Reader"/>
		<read public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<ready public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</ready>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Console$LineReader"</e></m>
		</meta>
	</class>
	<class path="java.io.IOException" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/IOException.class" extern="1">
		<extends path="java.lang.Exception"/>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.lang.Throwable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.lang.Throwable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.IOException"</e></m>
		</meta>
	</class>
	<class path="java.io.EOFException" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/EOFException.class" extern="1">
		<extends path="java.io.IOException"/>
		<new public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.EOFException"</e></m>
		</meta>
	</class>
	<class path="java.lang.Comparable" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Comparable.class" extern="1" interface="1">
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.lang.Comparable.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compareTo>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Comparable"</e></m>
		</meta>
	</class>
	<class path="java.io.File" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/File.class" extern="1">
		<implements path="java.lang.Comparable"><c path="java.io.File"/></implements>
		<implements path="java.io.Serializable"/>
		<listRoots public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="java.io.File"/></c></f>
			<meta><m n=":overload"/></meta>
		</listRoots>
		<createTempFile public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="String"/>
				<c path="String"/>
				<c path="java.io.File"/>
				<c path="java.io.File"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><createTempFile public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<c path="String"/>
		<c path="java.io.File"/>
	</f>
	<meta><m n=":overload"/></meta>
</createTempFile></overloads>
		</createTempFile>
		<pathSeparator public="1" static="1">
			<c path="String"/>
			<meta><m n=":final"/></meta>
		</pathSeparator>
		<pathSeparatorChar public="1" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</pathSeparatorChar>
		<separator public="1" static="1">
			<c path="String"/>
			<meta><m n=":final"/></meta>
		</separator>
		<separatorChar public="1" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</separatorChar>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getParent public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getParent>
		<getParentFile public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
		</getParentFile>
		<getPath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getPath>
		<isAbsolute public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAbsolute>
		<getAbsolutePath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getAbsolutePath>
		<getAbsoluteFile public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
		</getAbsoluteFile>
		<getCanonicalPath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getCanonicalPath>
		<getCanonicalFile public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
		</getCanonicalFile>
		<toURL public="1" set="method">
			<f a=""><c path="java.net.URL"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</toURL>
		<toURI public="1" set="method">
			<f a=""><c path="java.net.URI"/></f>
			<meta><m n=":overload"/></meta>
		</toURI>
		<canRead public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</canRead>
		<canWrite public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</canWrite>
		<exists public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</exists>
		<isDirectory public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirectory>
		<isFile public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isFile>
		<isHidden public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isHidden>
		<lastModified public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</lastModified>
		<length public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</length>
		<createNewFile public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</createNewFile>
		<delete public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</delete>
		<deleteOnExit public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</deleteOnExit>
		<list public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><list public="1" set="method">
	<f a="param1">
		<c path="java.io.FilenameFilter"/>
		<c path="java.NativeArray"><c path="String"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</list></overloads>
		</list>
		<listFiles public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.io.File"/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<listFiles public="1" set="method">
					<f a="param1">
						<c path="java.io.FileFilter"/>
						<c path="java.NativeArray"><c path="java.io.File"/></c>
					</f>
					<meta><m n=":overload"/></meta>
				</listFiles>
				<listFiles public="1" set="method">
					<f a="param1">
						<c path="java.io.FilenameFilter"/>
						<c path="java.NativeArray"><c path="java.io.File"/></c>
					</f>
					<meta><m n=":overload"/></meta>
				</listFiles>
			</overloads>
		</listFiles>
		<mkdir public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</mkdir>
		<mkdirs public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</mkdirs>
		<renameTo public="1" set="method">
			<f a="param1">
				<c path="java.io.File"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</renameTo>
		<setLastModified public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLastModified>
		<setReadOnly public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</setReadOnly>
		<setWritable public="1" set="method">
			<f a="param1:param2">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setWritable public="1" set="method">
	<f a="param1">
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</setWritable></overloads>
		</setWritable>
		<setReadable public="1" set="method">
			<f a="param1:param2">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setReadable public="1" set="method">
	<f a="param1">
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</setReadable></overloads>
		</setReadable>
		<setExecutable public="1" set="method">
			<f a="param1:param2">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setExecutable public="1" set="method">
	<f a="param1">
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</setExecutable></overloads>
		</setExecutable>
		<canExecute public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</canExecute>
		<getTotalSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getTotalSpace>
		<getFreeSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getFreeSpace>
		<getUsableSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getUsableSpace>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.io.File"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toPath public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</toPath>
		<new public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.net.URI"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.File"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.File"</e></m>
		</meta>
	</class>
	<class path="java.io.File_TempDirectory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/File$TempDirectory.class" module="java.io.File" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.io.File$TempDirectory"</e></m>
</meta></class>
	<class path="java.io.FileDescriptor" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/FileDescriptor.class" extern="1">
		<err public="1" static="1">
			<c path="java.io.FileDescriptor"/>
			<meta><m n=":final"/></meta>
		</err>
		<out public="1" static="1">
			<c path="java.io.FileDescriptor"/>
			<meta><m n=":final"/></meta>
		</out>
		<_in public="1" static="1">
			<c path="java.io.FileDescriptor"/>
			<meta>
				<m n=":native"><e>"in"</e></m>
				<m n=":final"/>
			</meta>
		</_in>
		<valid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</valid>
		<sync public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</sync>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.FileDescriptor"</e></m>
		</meta>
	</class>
	<class path="java.io.FileFilter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/FileFilter.class" extern="1" interface="1">
		<accept public="1" set="method">
			<f a="param1">
				<c path="java.io.File"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</accept>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.FileFilter"</e></m>
		</meta>
	</class>
	<class path="java.io.FilenameFilter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/FilenameFilter.class" extern="1" interface="1">
		<accept public="1" set="method">
			<f a="param1:param2">
				<c path="java.io.File"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</accept>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.FilenameFilter"</e></m>
		</meta>
	</class>
	<class path="java.io.FilterOutputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/FilterOutputStream.class" extern="1">
		<extends path="java.io.OutputStream"/>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<flush public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<write public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<out><c path="java.io.OutputStream"/></out>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.io.OutputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.FilterOutputStream"</e></m>
		</meta>
	</class>
	<class path="java.io.InputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/InputStream.class" extern="1">
		<implements path="java.io.Closeable"/>
		<read public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<skip public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</skip>
		<available public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</available>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<mark public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</mark>
		<reset public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</reset>
		<markSupported public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</markSupported>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.InputStream"</e></m>
		</meta>
	</class>
	<class path="java.io.NativeInput" params="" file="/usr/lib/haxe/std/java/io/NativeInput.hx">
		<extends path="haxe.io.Input"/>
		<stream><c path="java.io.InputStream"/></stream>
		<readByte public="1" set="method" line="38" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="53" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="74" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="33"><f a="stream">
	<c path="java.io.InputStream"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"haxe.java.io.NativeInput"</e></m></meta>
	</class>
	<class path="java.io.NativeOutput" params="" file="/usr/lib/haxe/std/java/io/NativeOutput.hx">
		<extends path="haxe.io.Output"/>
		<stream><c path="java.io.OutputStream"/></stream>
		<writeByte public="1" set="method" line="38" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<close public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></flush>
		<new public="1" set="method" line="33"><f a="stream">
	<c path="java.io.OutputStream"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"haxe.java.io.NativeOutput"</e></m></meta>
	</class>
	<class path="java.lang.Appendable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Appendable.class" extern="1" interface="1">
		<append public="1" set="method">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.lang.Appendable"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.lang.Appendable"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.Appendable"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Appendable"</e></m>
		</meta>
	</class>
	<class path="java.io.PrintStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/PrintStream.class" extern="1">
		<extends path="java.io.FilterOutputStream"/>
		<implements path="java.lang.Appendable"/>
		<implements path="java.io.Closeable"/>
		<write public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><write public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</write></overloads>
		</write>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<flush public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<checkError public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</checkError>
		<setError set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</setError>
		<clearError set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clearError>
		<print public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<print public="1" set="method">
					<f a="param1">
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
			</overloads>
		</print>
		<println public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<println public="1" set="method">
					<f a="param1">
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
			</overloads>
		</println>
		<printf public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.PrintStream"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><printf public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Locale"/>
		<c path="String"/>
		<c path="java.NativeArray"><d/></c>
		<c path="java.io.PrintStream"/>
	</f>
	<meta><m n=":overload"/></meta>
</printf></overloads>
		</printf>
		<format public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.PrintStream"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><format public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Locale"/>
		<c path="String"/>
		<c path="java.NativeArray"><d/></c>
		<c path="java.io.PrintStream"/>
	</f>
	<meta><m n=":overload"/></meta>
</format></overloads>
		</format>
		<append public="1" set="method">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.io.PrintStream"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.io.PrintStream"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.io.PrintStream"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.io.OutputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.File"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.io.File"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.io.OutputStream"/>
						<x path="Bool"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.OutputStream"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.PrintStream"</e></m>
		</meta>
	</class>
	<class path="java.io.Writer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/Writer.class" extern="1">
		<implements path="java.lang.Appendable"/>
		<implements path="java.io.Closeable"/>
		<implements path="java.io.Flushable"/>
		<write public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<append public="1" set="method">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.io.Writer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.io.Writer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.io.Writer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<flush public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<lock><d/></lock>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new set="method">
	<f a="param1">
		<d/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.Writer"</e></m>
		</meta>
	</class>
	<class path="java.io.PrintWriter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/io/PrintWriter.class" extern="1">
		<extends path="java.io.Writer"/>
		<append public="1" set="method" override="1">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.io.PrintWriter"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.io.PrintWriter"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.io.PrintWriter"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<write public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<flush public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</flush>
		<checkError public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</checkError>
		<setError set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</setError>
		<clearError set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clearError>
		<print public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<print public="1" set="method">
					<f a="param1">
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
				<print public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</print>
			</overloads>
		</print>
		<println public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<println public="1" set="method">
					<f a="param1">
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
				<println public="1" set="method">
					<f a="param1">
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</println>
			</overloads>
		</println>
		<printf public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.PrintWriter"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><printf public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Locale"/>
		<c path="String"/>
		<c path="java.NativeArray"><d/></c>
		<c path="java.io.PrintWriter"/>
	</f>
	<meta><m n=":overload"/></meta>
</printf></overloads>
		</printf>
		<format public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.io.PrintWriter"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><format public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Locale"/>
		<c path="String"/>
		<c path="java.NativeArray"><d/></c>
		<c path="java.io.PrintWriter"/>
	</f>
	<meta><m n=":overload"/></meta>
</format></overloads>
		</format>
		<out><c path="java.io.Writer"/></out>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.io.Writer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.File"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.io.File"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.OutputStream"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.io.OutputStream"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.io.Writer"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.io.PrintWriter"</e></m>
		</meta>
	</class>
	<class path="java.lang.AbstractStringBuilder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/AbstractStringBuilder.class" extern="1">
		<implements path="java.lang.Appendable"/>
		<implements path="java.lang.CharSequence"/>
		<length public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</length>
		<capacity public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</capacity>
		<ensureCapacity public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</ensureCapacity>
		<trimToSize public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</trimToSize>
		<setLength public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLength>
		<charAt public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</charAt>
		<codePointAt public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointAt>
		<codePointBefore public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointBefore>
		<codePointCount public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointCount>
		<offsetByCodePoints public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</offsetByCodePoints>
		<getChars public="1" set="method">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getChars>
		<setCharAt public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<t path="java.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setCharAt>
		<append public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Bool"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.lang.CharSequence"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.lang.StringBuffer"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<delete public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</delete>
		<appendCodePoint public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendCodePoint>
		<deleteCharAt public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</deleteCharAt>
		<replace public="1" set="method">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</replace>
		<substring public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><substring public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</substring></overloads>
		</substring>
		<subSequence public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.CharSequence"/>
			</f>
			<meta><m n=":overload"/></meta>
		</subSequence>
		<insert public="1" set="method">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.AbstractStringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Float"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Single"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="haxe.Int64"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Char16"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Bool"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2:param3:param4">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="String"/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<d/>
						<c path="java.lang.AbstractStringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
			</overloads>
		</insert>
		<indexOf public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><indexOf public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</indexOf></overloads>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><lastIndexOf public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</lastIndexOf></overloads>
		</lastIndexOf>
		<reverse public="1" set="method">
			<f a=""><c path="java.lang.AbstractStringBuilder"/></f>
			<meta><m n=":overload"/></meta>
		</reverse>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.AbstractStringBuilder"</e></m>
		</meta>
	</class>
	<class path="java.lang.Boolean" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Boolean.class" extern="1">
		<implements path="java.lang.Comparable"><t path="Null"><x path="Bool"/></t></implements>
		<implements path="java.io.Serializable"/>
		<parseBoolean public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</parseBoolean>
		<valueOf public="1" set="method" static="1">
			<f a="param1">
				<x path="Bool"/>
				<t path="Null"><x path="Bool"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><valueOf public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<t path="Null"><x path="Bool"/></t>
	</f>
	<meta><m n=":overload"/></meta>
</valueOf></overloads>
		</valueOf>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<getBoolean public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getBoolean>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><x path="Bool"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<FALSE public="1" static="1">
			<t path="Null"><x path="Bool"/></t>
			<meta><m n=":final"/></meta>
		</FALSE>
		<TRUE public="1" static="1">
			<t path="Null"><x path="Bool"/></t>
			<meta><m n=":final"/></meta>
		</TRUE>
		<booleanValue public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</booleanValue>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><x path="Bool"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Boolean"</e></m>
		</meta>
	</class>
	<class path="java.lang.Number" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Number.class" extern="1">
		<implements path="java.io.Serializable"/>
		<intValue public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<longValue public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<floatValue public="1" set="method">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<doubleValue public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<byteValue public="1" set="method">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<shortValue public="1" set="method">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Number"</e></m>
		</meta>
	</class>
	<class path="java.lang.Byte" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Byte.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><t path="Null"><t path="java.types.Int8"/></t></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Int8"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<valueOf public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Int8"/>
				<t path="Null"><t path="java.types.Int8"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<valueOf public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<t path="Null"><t path="java.types.Int8"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
				<valueOf public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<x path="Int"/>
						<t path="Null"><t path="java.types.Int8"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
			</overloads>
		</valueOf>
		<parseByte public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<t path="java.types.Int8"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><parseByte public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<t path="java.types.Int8"/>
	</f>
	<meta><m n=":overload"/></meta>
</parseByte></overloads>
		</parseByte>
		<decode public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><t path="java.types.Int8"/></t>
			</f>
			<meta><m n=":overload"/></meta>
		</decode>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Int8"/>
				<t path="java.types.Int8"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><t path="java.types.Int8"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<MAX_VALUE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<MIN_VALUE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<doubleValue public="1" set="method" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><t path="java.types.Int8"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<t path="java.types.Int8"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Byte"</e></m>
		</meta>
	</class>
	<class path="java.lang.Byte_ByteCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Byte$ByteCache.class" module="java.lang.Byte" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Byte$ByteCache"</e></m>
</meta></class>
	<class path="java.lang.Character" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Character.class" extern="1">
		<implements path="java.lang.Comparable"><t path="Null"><t path="java.types.Char16"/></t></implements>
		<implements path="java.io.Serializable"/>
		<valueOf public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="Null"><t path="java.types.Char16"/></t>
			</f>
			<meta><m n=":overload"/></meta>
		</valueOf>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<isValidCodePoint public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isValidCodePoint>
		<isBmpCodePoint public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isBmpCodePoint>
		<isSupplementaryCodePoint public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isSupplementaryCodePoint>
		<isHighSurrogate public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isHighSurrogate>
		<isLowSurrogate public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isLowSurrogate>
		<isSurrogate public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isSurrogate>
		<isSurrogatePair public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isSurrogatePair>
		<charCount public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</charCount>
		<toCodePoint public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toCodePoint>
		<codePointAt public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="java.lang.CharSequence"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<codePointAt public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</codePointAt>
				<codePointAt public="1" set="method">
					<f a="param1:param2">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</codePointAt>
			</overloads>
		</codePointAt>
		<codePointBefore public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="java.lang.CharSequence"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<codePointBefore public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</codePointBefore>
				<codePointBefore public="1" set="method">
					<f a="param1:param2">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</codePointBefore>
			</overloads>
		</codePointBefore>
		<highSurrogate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</highSurrogate>
		<lowSurrogate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lowSurrogate>
		<toChars public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><toChars public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.NativeArray"><t path="java.types.Char16"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</toChars></overloads>
		</toChars>
		<codePointCount public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.lang.CharSequence"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><codePointCount public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.NativeArray"><t path="java.types.Char16"/></c>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</codePointCount></overloads>
		</codePointCount>
		<offsetByCodePoints public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.lang.CharSequence"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><offsetByCodePoints public="1" set="method">
	<f a="param1:param2:param3:param4:param5">
		<c path="java.NativeArray"><t path="java.types.Char16"/></c>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</offsetByCodePoints></overloads>
		</offsetByCodePoints>
		<isLowerCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isLowerCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isLowerCase></overloads>
		</isLowerCase>
		<isUpperCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isUpperCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isUpperCase></overloads>
		</isUpperCase>
		<isTitleCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isTitleCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isTitleCase></overloads>
		</isTitleCase>
		<isDigit public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isDigit public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isDigit></overloads>
		</isDigit>
		<isDefined public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isDefined public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isDefined></overloads>
		</isDefined>
		<isLetter public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isLetter public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isLetter></overloads>
		</isLetter>
		<isLetterOrDigit public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isLetterOrDigit public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isLetterOrDigit></overloads>
		</isLetterOrDigit>
		<isJavaLetter public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</isJavaLetter>
		<isJavaLetterOrDigit public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</isJavaLetterOrDigit>
		<isAlphabetic public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAlphabetic>
		<isIdeographic public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isIdeographic>
		<isJavaIdentifierStart public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isJavaIdentifierStart public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isJavaIdentifierStart></overloads>
		</isJavaIdentifierStart>
		<isJavaIdentifierPart public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isJavaIdentifierPart public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isJavaIdentifierPart></overloads>
		</isJavaIdentifierPart>
		<isUnicodeIdentifierStart public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isUnicodeIdentifierStart public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isUnicodeIdentifierStart></overloads>
		</isUnicodeIdentifierStart>
		<isUnicodeIdentifierPart public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isUnicodeIdentifierPart public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isUnicodeIdentifierPart></overloads>
		</isUnicodeIdentifierPart>
		<isIdentifierIgnorable public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isIdentifierIgnorable public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isIdentifierIgnorable></overloads>
		</isIdentifierIgnorable>
		<toLowerCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><toLowerCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</toLowerCase></overloads>
		</toLowerCase>
		<toUpperCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><toUpperCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</toUpperCase></overloads>
		</toUpperCase>
		<toTitleCase public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><toTitleCase public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</toTitleCase></overloads>
		</toTitleCase>
		<digit public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Char16"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><digit public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</digit></overloads>
		</digit>
		<getNumericValue public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getNumericValue public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</getNumericValue></overloads>
		</getNumericValue>
		<isSpace public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</isSpace>
		<isSpaceChar public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isSpaceChar public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isSpaceChar></overloads>
		</isSpaceChar>
		<isWhitespace public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isWhitespace public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isWhitespace></overloads>
		</isWhitespace>
		<isISOControl public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isISOControl public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isISOControl></overloads>
		</isISOControl>
		<getType public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getType public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</getType></overloads>
		</getType>
		<forDigit public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</forDigit>
		<getDirectionality public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="java.types.Int8"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getDirectionality public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<t path="java.types.Int8"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDirectionality></overloads>
		</getDirectionality>
		<isMirrored public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isMirrored public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isMirrored></overloads>
		</isMirrored>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<reverseBytes public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverseBytes>
		<getName public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getName>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<MAX_CODE_POINT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_CODE_POINT>
		<MIN_CODE_POINT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_CODE_POINT>
		<MIN_SUPPLEMENTARY_CODE_POINT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_SUPPLEMENTARY_CODE_POINT>
		<MAX_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MAX_SURROGATE>
		<MIN_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MIN_SURROGATE>
		<MAX_LOW_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MAX_LOW_SURROGATE>
		<MIN_LOW_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MIN_LOW_SURROGATE>
		<MAX_HIGH_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MAX_HIGH_SURROGATE>
		<MIN_HIGH_SURROGATE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MIN_HIGH_SURROGATE>
		<DIRECTIONALITY_POP_DIRECTIONAL_FORMAT public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_POP_DIRECTIONAL_FORMAT>
		<DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE>
		<DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING>
		<DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE>
		<DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING>
		<DIRECTIONALITY_OTHER_NEUTRALS public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_OTHER_NEUTRALS>
		<DIRECTIONALITY_WHITESPACE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_WHITESPACE>
		<DIRECTIONALITY_SEGMENT_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_SEGMENT_SEPARATOR>
		<DIRECTIONALITY_PARAGRAPH_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_PARAGRAPH_SEPARATOR>
		<DIRECTIONALITY_BOUNDARY_NEUTRAL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_BOUNDARY_NEUTRAL>
		<DIRECTIONALITY_NONSPACING_MARK public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_NONSPACING_MARK>
		<DIRECTIONALITY_COMMON_NUMBER_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_COMMON_NUMBER_SEPARATOR>
		<DIRECTIONALITY_ARABIC_NUMBER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_ARABIC_NUMBER>
		<DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR>
		<DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR>
		<DIRECTIONALITY_EUROPEAN_NUMBER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_EUROPEAN_NUMBER>
		<DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC>
		<DIRECTIONALITY_RIGHT_TO_LEFT public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_RIGHT_TO_LEFT>
		<DIRECTIONALITY_LEFT_TO_RIGHT public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_LEFT_TO_RIGHT>
		<DIRECTIONALITY_UNDEFINED public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DIRECTIONALITY_UNDEFINED>
		<FINAL_QUOTE_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</FINAL_QUOTE_PUNCTUATION>
		<INITIAL_QUOTE_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</INITIAL_QUOTE_PUNCTUATION>
		<OTHER_SYMBOL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</OTHER_SYMBOL>
		<MODIFIER_SYMBOL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</MODIFIER_SYMBOL>
		<CURRENCY_SYMBOL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</CURRENCY_SYMBOL>
		<MATH_SYMBOL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</MATH_SYMBOL>
		<OTHER_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</OTHER_PUNCTUATION>
		<CONNECTOR_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</CONNECTOR_PUNCTUATION>
		<END_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</END_PUNCTUATION>
		<START_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</START_PUNCTUATION>
		<DASH_PUNCTUATION public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DASH_PUNCTUATION>
		<SURROGATE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</SURROGATE>
		<PRIVATE_USE public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</PRIVATE_USE>
		<FORMAT public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</FORMAT>
		<CONTROL public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</CONTROL>
		<PARAGRAPH_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</PARAGRAPH_SEPARATOR>
		<LINE_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</LINE_SEPARATOR>
		<SPACE_SEPARATOR public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</SPACE_SEPARATOR>
		<OTHER_NUMBER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</OTHER_NUMBER>
		<LETTER_NUMBER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</LETTER_NUMBER>
		<DECIMAL_DIGIT_NUMBER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</DECIMAL_DIGIT_NUMBER>
		<COMBINING_SPACING_MARK public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</COMBINING_SPACING_MARK>
		<ENCLOSING_MARK public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</ENCLOSING_MARK>
		<NON_SPACING_MARK public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</NON_SPACING_MARK>
		<OTHER_LETTER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</OTHER_LETTER>
		<MODIFIER_LETTER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</MODIFIER_LETTER>
		<TITLECASE_LETTER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</TITLECASE_LETTER>
		<LOWERCASE_LETTER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</LOWERCASE_LETTER>
		<UPPERCASE_LETTER public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</UPPERCASE_LETTER>
		<UNASSIGNED public="1" set="null" static="1">
			<t path="java.types.Int8"/>
			<meta><m n=":final"/></meta>
		</UNASSIGNED>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><t path="java.types.Char16"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<MAX_VALUE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<MIN_VALUE public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<MAX_RADIX public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_RADIX>
		<MIN_RADIX public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_RADIX>
		<charValue public="1" set="method">
			<f a=""><t path="java.types.Char16"/></f>
			<meta><m n=":overload"/></meta>
		</charValue>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><t path="java.types.Char16"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<t path="java.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Character"</e></m>
		</meta>
	</class>
	<class path="java.lang.Character_Subset" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Character$Subset.class" module="java.lang.Character" extern="1">
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</toString>
		<new set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Character$Subset"</e></m>
		</meta>
	</class>
	<class path="java.lang.Character_UnicodeBlock" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Character$UnicodeBlock.class" module="java.lang.Character" extern="1">
		<extends path="java.lang.Character_Subset"/>
		<of public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Char16"/>
				<c path="java.lang.Character_UnicodeBlock"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><of public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.lang.Character_UnicodeBlock"/>
	</f>
	<meta><m n=":overload"/></meta>
</of></overloads>
		</of>
		<forName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Character_UnicodeBlock"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</forName>
		<CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D>
		<CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C>
		<ALCHEMICAL_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ALCHEMICAL_SYMBOLS>
		<TRANSPORT_AND_MAP_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TRANSPORT_AND_MAP_SYMBOLS>
		<EMOTICONS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</EMOTICONS>
		<MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS>
		<ENCLOSED_IDEOGRAPHIC_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ENCLOSED_IDEOGRAPHIC_SUPPLEMENT>
		<ENCLOSED_ALPHANUMERIC_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ENCLOSED_ALPHANUMERIC_SUPPLEMENT>
		<PLAYING_CARDS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PLAYING_CARDS>
		<DOMINO_TILES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</DOMINO_TILES>
		<MAHJONG_TILES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MAHJONG_TILES>
		<COUNTING_ROD_NUMERALS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COUNTING_ROD_NUMERALS>
		<ANCIENT_GREEK_MUSICAL_NOTATION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ANCIENT_GREEK_MUSICAL_NOTATION>
		<KANA_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KANA_SUPPLEMENT>
		<BAMUM_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BAMUM_SUPPLEMENT>
		<EGYPTIAN_HIEROGLYPHS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</EGYPTIAN_HIEROGLYPHS>
		<CUNEIFORM_NUMBERS_AND_PUNCTUATION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CUNEIFORM_NUMBERS_AND_PUNCTUATION>
		<CUNEIFORM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CUNEIFORM>
		<KAITHI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KAITHI>
		<BRAHMI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BRAHMI>
		<RUMI_NUMERAL_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</RUMI_NUMERAL_SYMBOLS>
		<OLD_TURKIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OLD_TURKIC>
		<INSCRIPTIONAL_PAHLAVI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</INSCRIPTIONAL_PAHLAVI>
		<INSCRIPTIONAL_PARTHIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</INSCRIPTIONAL_PARTHIAN>
		<AVESTAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</AVESTAN>
		<OLD_SOUTH_ARABIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OLD_SOUTH_ARABIAN>
		<KHAROSHTHI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KHAROSHTHI>
		<LYDIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LYDIAN>
		<PHOENICIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PHOENICIAN>
		<IMPERIAL_ARAMAIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</IMPERIAL_ARAMAIC>
		<OLD_PERSIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OLD_PERSIAN>
		<CARIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CARIAN>
		<LYCIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LYCIAN>
		<PHAISTOS_DISC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PHAISTOS_DISC>
		<ANCIENT_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ANCIENT_SYMBOLS>
		<ANCIENT_GREEK_NUMBERS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ANCIENT_GREEK_NUMBERS>
		<VERTICAL_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</VERTICAL_FORMS>
		<HANGUL_JAMO_EXTENDED_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANGUL_JAMO_EXTENDED_B>
		<MEETEI_MAYEK public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MEETEI_MAYEK>
		<ETHIOPIC_EXTENDED_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ETHIOPIC_EXTENDED_A>
		<TAI_VIET public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAI_VIET>
		<MYANMAR_EXTENDED_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MYANMAR_EXTENDED_A>
		<CHAM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CHAM>
		<JAVANESE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</JAVANESE>
		<HANGUL_JAMO_EXTENDED_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANGUL_JAMO_EXTENDED_A>
		<REJANG public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</REJANG>
		<KAYAH_LI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KAYAH_LI>
		<DEVANAGARI_EXTENDED public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</DEVANAGARI_EXTENDED>
		<SAURASHTRA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SAURASHTRA>
		<PHAGS_PA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PHAGS_PA>
		<COMMON_INDIC_NUMBER_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COMMON_INDIC_NUMBER_FORMS>
		<SYLOTI_NAGRI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SYLOTI_NAGRI>
		<LATIN_EXTENDED_D public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_EXTENDED_D>
		<MODIFIER_TONE_LETTERS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MODIFIER_TONE_LETTERS>
		<BAMUM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BAMUM>
		<CYRILLIC_EXTENDED_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CYRILLIC_EXTENDED_B>
		<VAI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</VAI>
		<LISU public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LISU>
		<CJK_STROKES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_STROKES>
		<SUPPLEMENTAL_PUNCTUATION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTAL_PUNCTUATION>
		<CYRILLIC_EXTENDED_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CYRILLIC_EXTENDED_A>
		<ETHIOPIC_EXTENDED public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ETHIOPIC_EXTENDED>
		<TIFINAGH public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TIFINAGH>
		<GEORGIAN_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GEORGIAN_SUPPLEMENT>
		<COPTIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COPTIC>
		<LATIN_EXTENDED_C public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_EXTENDED_C>
		<GLAGOLITIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GLAGOLITIC>
		<COMBINING_DIACRITICAL_MARKS_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COMBINING_DIACRITICAL_MARKS_SUPPLEMENT>
		<PHONETIC_EXTENSIONS_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PHONETIC_EXTENSIONS_SUPPLEMENT>
		<VEDIC_EXTENSIONS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</VEDIC_EXTENSIONS>
		<OL_CHIKI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OL_CHIKI>
		<LEPCHA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LEPCHA>
		<BATAK public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BATAK>
		<SUNDANESE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUNDANESE>
		<BALINESE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BALINESE>
		<TAI_THAM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAI_THAM>
		<BUGINESE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BUGINESE>
		<NEW_TAI_LUE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</NEW_TAI_LUE>
		<UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED>
		<ETHIOPIC_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ETHIOPIC_SUPPLEMENT>
		<MANDAIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MANDAIC>
		<SAMARITAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SAMARITAN>
		<NKO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</NKO>
		<ARABIC_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARABIC_SUPPLEMENT>
		<LOW_SURROGATES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LOW_SURROGATES>
		<HIGH_PRIVATE_USE_SURROGATES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HIGH_PRIVATE_USE_SURROGATES>
		<HIGH_SURROGATES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HIGH_SURROGATES>
		<SUPPLEMENTARY_PRIVATE_USE_AREA_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTARY_PRIVATE_USE_AREA_B>
		<SUPPLEMENTARY_PRIVATE_USE_AREA_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTARY_PRIVATE_USE_AREA_A>
		<VARIATION_SELECTORS_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</VARIATION_SELECTORS_SUPPLEMENT>
		<TAGS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAGS>
		<CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT>
		<CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B>
		<MATHEMATICAL_ALPHANUMERIC_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MATHEMATICAL_ALPHANUMERIC_SYMBOLS>
		<TAI_XUAN_JING_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAI_XUAN_JING_SYMBOLS>
		<MUSICAL_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MUSICAL_SYMBOLS>
		<BYZANTINE_MUSICAL_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BYZANTINE_MUSICAL_SYMBOLS>
		<CYPRIOT_SYLLABARY public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CYPRIOT_SYLLABARY>
		<OSMANYA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OSMANYA>
		<SHAVIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SHAVIAN>
		<DESERET public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</DESERET>
		<UGARITIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</UGARITIC>
		<GOTHIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GOTHIC>
		<OLD_ITALIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OLD_ITALIC>
		<AEGEAN_NUMBERS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</AEGEAN_NUMBERS>
		<LINEAR_B_IDEOGRAMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LINEAR_B_IDEOGRAMS>
		<LINEAR_B_SYLLABARY public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LINEAR_B_SYLLABARY>
		<VARIATION_SELECTORS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</VARIATION_SELECTORS>
		<YIJING_HEXAGRAM_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</YIJING_HEXAGRAM_SYMBOLS>
		<KATAKANA_PHONETIC_EXTENSIONS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KATAKANA_PHONETIC_EXTENSIONS>
		<MISCELLANEOUS_SYMBOLS_AND_ARROWS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_SYMBOLS_AND_ARROWS>
		<SUPPLEMENTAL_MATHEMATICAL_OPERATORS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTAL_MATHEMATICAL_OPERATORS>
		<MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B>
		<SUPPLEMENTAL_ARROWS_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTAL_ARROWS_B>
		<SUPPLEMENTAL_ARROWS_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPPLEMENTAL_ARROWS_A>
		<MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A>
		<PHONETIC_EXTENSIONS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PHONETIC_EXTENSIONS>
		<KHMER_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KHMER_SYMBOLS>
		<TAI_LE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAI_LE>
		<LIMBU public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LIMBU>
		<TAGBANWA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAGBANWA>
		<BUHID public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BUHID>
		<HANUNOO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANUNOO>
		<TAGALOG public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAGALOG>
		<CYRILLIC_SUPPLEMENTARY public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CYRILLIC_SUPPLEMENTARY>
		<YI_RADICALS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</YI_RADICALS>
		<YI_SYLLABLES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</YI_SYLLABLES>
		<CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A>
		<BOPOMOFO_EXTENDED public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BOPOMOFO_EXTENDED>
		<IDEOGRAPHIC_DESCRIPTION_CHARACTERS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</IDEOGRAPHIC_DESCRIPTION_CHARACTERS>
		<KANGXI_RADICALS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KANGXI_RADICALS>
		<CJK_RADICALS_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_RADICALS_SUPPLEMENT>
		<BRAILLE_PATTERNS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BRAILLE_PATTERNS>
		<MONGOLIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MONGOLIAN>
		<KHMER public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KHMER>
		<RUNIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</RUNIC>
		<OGHAM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OGHAM>
		<UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS>
		<CHEROKEE public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CHEROKEE>
		<ETHIOPIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ETHIOPIC>
		<MYANMAR public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MYANMAR>
		<SINHALA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SINHALA>
		<THAANA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</THAANA>
		<SYRIAC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SYRIAC>
		<SURROGATES_AREA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</SURROGATES_AREA>
		<SPECIALS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SPECIALS>
		<HALFWIDTH_AND_FULLWIDTH_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HALFWIDTH_AND_FULLWIDTH_FORMS>
		<ARABIC_PRESENTATION_FORMS_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARABIC_PRESENTATION_FORMS_B>
		<SMALL_FORM_VARIANTS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SMALL_FORM_VARIANTS>
		<CJK_COMPATIBILITY_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_COMPATIBILITY_FORMS>
		<COMBINING_HALF_MARKS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COMBINING_HALF_MARKS>
		<ARABIC_PRESENTATION_FORMS_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARABIC_PRESENTATION_FORMS_A>
		<ALPHABETIC_PRESENTATION_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ALPHABETIC_PRESENTATION_FORMS>
		<CJK_COMPATIBILITY_IDEOGRAPHS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_COMPATIBILITY_IDEOGRAPHS>
		<PRIVATE_USE_AREA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</PRIVATE_USE_AREA>
		<HANGUL_SYLLABLES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANGUL_SYLLABLES>
		<CJK_UNIFIED_IDEOGRAPHS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_UNIFIED_IDEOGRAPHS>
		<CJK_COMPATIBILITY public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_COMPATIBILITY>
		<ENCLOSED_CJK_LETTERS_AND_MONTHS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ENCLOSED_CJK_LETTERS_AND_MONTHS>
		<KANBUN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KANBUN>
		<HANGUL_COMPATIBILITY_JAMO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANGUL_COMPATIBILITY_JAMO>
		<BOPOMOFO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BOPOMOFO>
		<KATAKANA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KATAKANA>
		<HIRAGANA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HIRAGANA>
		<CJK_SYMBOLS_AND_PUNCTUATION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CJK_SYMBOLS_AND_PUNCTUATION>
		<DINGBATS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</DINGBATS>
		<MISCELLANEOUS_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_SYMBOLS>
		<GEOMETRIC_SHAPES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GEOMETRIC_SHAPES>
		<BLOCK_ELEMENTS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BLOCK_ELEMENTS>
		<BOX_DRAWING public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BOX_DRAWING>
		<ENCLOSED_ALPHANUMERICS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ENCLOSED_ALPHANUMERICS>
		<OPTICAL_CHARACTER_RECOGNITION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</OPTICAL_CHARACTER_RECOGNITION>
		<CONTROL_PICTURES public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CONTROL_PICTURES>
		<MISCELLANEOUS_TECHNICAL public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MISCELLANEOUS_TECHNICAL>
		<MATHEMATICAL_OPERATORS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MATHEMATICAL_OPERATORS>
		<ARROWS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARROWS>
		<NUMBER_FORMS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</NUMBER_FORMS>
		<LETTERLIKE_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LETTERLIKE_SYMBOLS>
		<COMBINING_MARKS_FOR_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COMBINING_MARKS_FOR_SYMBOLS>
		<CURRENCY_SYMBOLS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CURRENCY_SYMBOLS>
		<SUPERSCRIPTS_AND_SUBSCRIPTS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SUPERSCRIPTS_AND_SUBSCRIPTS>
		<GENERAL_PUNCTUATION public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GENERAL_PUNCTUATION>
		<GREEK_EXTENDED public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GREEK_EXTENDED>
		<LATIN_EXTENDED_ADDITIONAL public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_EXTENDED_ADDITIONAL>
		<HANGUL_JAMO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HANGUL_JAMO>
		<GEORGIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GEORGIAN>
		<TIBETAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TIBETAN>
		<LAO public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LAO>
		<THAI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</THAI>
		<MALAYALAM public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</MALAYALAM>
		<KANNADA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</KANNADA>
		<TELUGU public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TELUGU>
		<TAMIL public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</TAMIL>
		<ORIYA public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ORIYA>
		<GUJARATI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GUJARATI>
		<GURMUKHI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GURMUKHI>
		<BENGALI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BENGALI>
		<DEVANAGARI public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</DEVANAGARI>
		<ARABIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARABIC>
		<HEBREW public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</HEBREW>
		<ARMENIAN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</ARMENIAN>
		<CYRILLIC public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</CYRILLIC>
		<GREEK public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</GREEK>
		<COMBINING_DIACRITICAL_MARKS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</COMBINING_DIACRITICAL_MARKS>
		<SPACING_MODIFIER_LETTERS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</SPACING_MODIFIER_LETTERS>
		<IPA_EXTENSIONS public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</IPA_EXTENSIONS>
		<LATIN_EXTENDED_B public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_EXTENDED_B>
		<LATIN_EXTENDED_A public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_EXTENDED_A>
		<LATIN_1_SUPPLEMENT public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</LATIN_1_SUPPLEMENT>
		<BASIC_LATIN public="1" static="1">
			<c path="java.lang.Character_UnicodeBlock"/>
			<meta><m n=":final"/></meta>
		</BASIC_LATIN>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Character$UnicodeBlock"</e></m>
		</meta>
	</class>
	<enum path="java.lang.Character_UnicodeScript" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Character$UnicodeScript.class" module="java.lang.Character"><meta><m n=":native"><e>"java.lang.Character$UnicodeScript"</e></m></meta></enum>
	<class path="java.lang.Character_CharacterCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Character$CharacterCache.class" module="java.lang.Character" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Character$CharacterCache"</e></m>
</meta></class>
	<class path="java.lang.reflect.AnnotatedElement" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/AnnotatedElement.class" extern="1" interface="1">
		<isAnnotationPresent public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.lang.annotation.Annotation"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAnnotationPresent>
		<getAnnotation public="1" params="T" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<getAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAnnotations>
		<getDeclaredAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.AnnotatedElement"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Type" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Type.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.reflect.Type"</e></m>
</meta></class>
	<class path="java.lang.reflect.GenericDeclaration" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/GenericDeclaration.class" extern="1" interface="1">
		<getTypeParameters public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.TypeVariable"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getTypeParameters>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.GenericDeclaration"</e></m>
		</meta>
	</class>
	<class path="java.lang.Class" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Class.class" extern="1">
		<implements path="java.lang.reflect.AnnotatedElement"/>
		<implements path="java.lang.reflect.Type"/>
		<implements path="java.lang.reflect.GenericDeclaration"/>
		<implements path="java.io.Serializable"/>
		<forName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><forName public="1" set="method">
	<f a="param1:param2:param3">
		<c path="String"/>
		<x path="Bool"/>
		<c path="java.lang.ClassLoader"/>
		<c path="java.lang.Class"><d/></c>
	</f>
	<meta><m n=":overload"/></meta>
</forName></overloads>
		</forName>
		<getTypeParameters public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.TypeVariable"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getTypeParameters>
		<getAnnotation public="1" params="T" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<newInstance public="1" set="method">
			<f a=""><c path="java.lang.Class.T"/></f>
			<meta><m n=":overload"/></meta>
		</newInstance>
		<isInstance public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isInstance>
		<isAssignableFrom public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAssignableFrom>
		<isInterface public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isInterface>
		<isArray public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isArray>
		<isPrimitive public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isPrimitive>
		<isAnnotation public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAnnotation>
		<isSynthetic public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSynthetic>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getClassLoader public="1" set="method">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta><m n=":overload"/></meta>
		</getClassLoader>
		<getSuperclass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getSuperclass>
		<getGenericSuperclass public="1" set="method">
			<f a=""><c path="java.lang.reflect.Type"/></f>
			<meta><m n=":overload"/></meta>
		</getGenericSuperclass>
		<getPackage public="1" set="method">
			<f a=""><c path="java.lang.Package"/></f>
			<meta><m n=":overload"/></meta>
		</getPackage>
		<getInterfaces public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getInterfaces>
		<getGenericInterfaces public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getGenericInterfaces>
		<getComponentType public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getComponentType>
		<getModifiers public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getModifiers>
		<getSigners public="1" set="method">
			<f a=""><c path="java.NativeArray"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getSigners>
		<getEnclosingMethod public="1" set="method">
			<f a=""><c path="java.lang.reflect.Method"/></f>
			<meta><m n=":overload"/></meta>
		</getEnclosingMethod>
		<getEnclosingConstructor public="1" set="method">
			<f a=""><c path="java.lang.reflect.Constructor"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getEnclosingConstructor>
		<getDeclaringClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaringClass>
		<getEnclosingClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getEnclosingClass>
		<getSimpleName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSimpleName>
		<getCanonicalName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getCanonicalName>
		<isAnonymousClass public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAnonymousClass>
		<isLocalClass public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isLocalClass>
		<isMemberClass public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMemberClass>
		<getClasses public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getClasses>
		<getFields public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Field"/></c></f>
			<meta><m n=":overload"/></meta>
		</getFields>
		<getMethods public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Method"/></c></f>
			<meta><m n=":overload"/></meta>
		</getMethods>
		<getConstructors public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Constructor"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getConstructors>
		<getField public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.reflect.Field"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getField>
		<getMethod public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
				<c path="java.lang.reflect.Method"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getMethod>
		<getConstructor public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
				<c path="java.lang.reflect.Constructor"><c path="java.lang.Class.T"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getConstructor>
		<getDeclaredClasses public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredClasses>
		<getDeclaredFields public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Field"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredFields>
		<getDeclaredMethods public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Method"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredMethods>
		<getDeclaredConstructors public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Constructor"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredConstructors>
		<getDeclaredField public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.reflect.Field"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDeclaredField>
		<getDeclaredMethod public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
				<c path="java.lang.reflect.Method"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDeclaredMethod>
		<getDeclaredConstructor public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
				<c path="java.lang.reflect.Constructor"><c path="java.lang.Class.T"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getDeclaredConstructor>
		<getResourceAsStream public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.io.InputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResourceAsStream>
		<getResource public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URL"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResource>
		<getProtectionDomain public="1" set="method">
			<f a=""><c path="java.security.ProtectionDomain"/></f>
			<meta><m n=":overload"/></meta>
		</getProtectionDomain>
		<desiredAssertionStatus public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</desiredAssertionStatus>
		<isEnum public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEnum>
		<getEnumConstants public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</getEnumConstants>
		<_cast public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.lang.Class.T"/>
			</f>
			<meta>
				<m n=":native"><e>"cast"</e></m>
				<m n=":overload"/>
			</meta>
		</_cast>
		<asSubclass public="1" params="U" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="asSubclass.U"/></c>
				<c path="java.lang.Class"><c path="asSubclass.U"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</asSubclass>
		<isAnnotationPresent public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.lang.annotation.Annotation"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAnnotationPresent>
		<getAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAnnotations>
		<getDeclaredAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Class"</e></m>
		</meta>
	</class>
	<class path="java.lang.Class_EnclosingMethodInfo" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Class$EnclosingMethodInfo.class" module="java.lang.Class" extern="1"><meta>
	<m n=":final"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Class$EnclosingMethodInfo"</e></m>
</meta></class>
	<class path="java.lang.Class_MethodArray" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Class$MethodArray.class" module="java.lang.Class" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Class$MethodArray"</e></m>
</meta></class>
	<class path="java.lang.ClassLoader" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ClassLoader.class" extern="1">
		<registerAsParallelCapable set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</registerAsParallelCapable>
		<getSystemResource public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URL"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getSystemResource>
		<getSystemResources public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Enumeration"><c path="java.net.URL"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getSystemResources>
		<getSystemResourceAsStream public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.io.InputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getSystemResourceAsStream>
		<getSystemClassLoader public="1" set="method" static="1">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta><m n=":overload"/></meta>
		</getSystemClassLoader>
		<loadClass public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><loadClass set="method">
	<f a="param1:param2">
		<c path="String"/>
		<x path="Bool"/>
		<c path="java.lang.Class"><d/></c>
	</f>
	<meta><m n=":overload"/></meta>
</loadClass></overloads>
		</loadClass>
		<getClassLoadingLock set="method">
			<f a="param1">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</getClassLoadingLock>
		<findClass set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</findClass>
		<defineClass set="method">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
			<overloads>
				<defineClass set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<c path="java.nio.ByteBuffer"/>
						<c path="java.security.ProtectionDomain"/>
						<c path="java.lang.Class"><d/></c>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</defineClass>
				<defineClass set="method">
					<f a="param1:param2:param3:param4:param5">
						<c path="String"/>
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.security.ProtectionDomain"/>
						<c path="java.lang.Class"><d/></c>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</defineClass>
				<defineClass set="method">
					<f a="param1:param2:param3:param4">
						<c path="String"/>
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.Class"><d/></c>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</defineClass>
			</overloads>
		</defineClass>
		<resolveClass set="method">
			<f a="param1">
				<c path="java.lang.Class"><d/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</resolveClass>
		<findSystemClass set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</findSystemClass>
		<findLoadedClass set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</findLoadedClass>
		<setSigners set="method">
			<f a="param1:param2">
				<c path="java.lang.Class"><d/></c>
				<c path="java.NativeArray"><d/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setSigners>
		<getResource public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URL"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResource>
		<getResources public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Enumeration"><c path="java.net.URL"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getResources>
		<findResource set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URL"/>
			</f>
			<meta><m n=":overload"/></meta>
		</findResource>
		<findResources set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Enumeration"><c path="java.net.URL"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</findResources>
		<getResourceAsStream public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.io.InputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResourceAsStream>
		<getParent public="1" set="method">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getParent>
		<definePackage set="method">
			<f a="param1:param2:param3:param4:param5:param6:param7:param8">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="java.net.URL"/>
				<c path="java.lang.Package"/>
			</f>
			<meta><m n=":overload"/></meta>
		</definePackage>
		<getPackage set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Package"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPackage>
		<getPackages set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Package"/></c></f>
			<meta><m n=":overload"/></meta>
		</getPackages>
		<findLibrary set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</findLibrary>
		<setDefaultAssertionStatus public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDefaultAssertionStatus>
		<setPackageAssertionStatus public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setPackageAssertionStatus>
		<setClassAssertionStatus public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setClassAssertionStatus>
		<clearAssertionStatus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clearAssertionStatus>
		<new set="method">
			<f a="param1">
				<c path="java.lang.ClassLoader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new set="method">
	<f a=""><x path="Void"/></f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ClassLoader"</e></m>
		</meta>
	</class>
	<class path="java.lang.ClassLoader_ParallelLoaders" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ClassLoader$ParallelLoaders.class" module="java.lang.ClassLoader" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ClassLoader$ParallelLoaders"</e></m>
</meta></class>
	<class path="java.lang.ClassLoader_NativeLibrary" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ClassLoader$NativeLibrary.class" module="java.lang.ClassLoader" extern="1">
		<finalize set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</finalize>
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.Class"><d/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ClassLoader$NativeLibrary"</e></m>
		</meta>
	</class>
	<class path="java.lang.Cloneable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Cloneable.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Cloneable"</e></m>
</meta></class>
	<class path="java.lang.Double" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Double.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><t path="Null"><x path="Float"/></t></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<toHexString public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toHexString>
		<valueOf public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><x path="Float"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><valueOf public="1" set="method">
	<f a="param1">
		<x path="Float"/>
		<t path="Null"><x path="Float"/></t>
	</f>
	<meta><m n=":overload"/></meta>
</valueOf></overloads>
		</valueOf>
		<parseDouble public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":overload"/></meta>
		</parseDouble>
		<_isNaN public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":native"><e>"isNaN"</e></m>
				<m n=":overload"/>
			</meta>
		</_isNaN>
		<_isInfinite public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":native"><e>"isInfinite"</e></m>
				<m n=":overload"/>
			</meta>
		</_isInfinite>
		<doubleToLongBits public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</doubleToLongBits>
		<doubleToRawLongBits public="1" set="method" static="1">
			<f a="param1">
				<x path="Float"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</doubleToRawLongBits>
		<longBitsToDouble public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Float"/>
			</f>
			<meta><m n=":overload"/></meta>
		</longBitsToDouble>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><x path="Float"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<MIN_EXPONENT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_EXPONENT>
		<MAX_EXPONENT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_EXPONENT>
		<MIN_VALUE public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<MIN_NORMAL public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</MIN_NORMAL>
		<MAX_VALUE public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":final"/></meta>
		</POSITIVE_INFINITY>
		<doubleValue public="1" set="method" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<isNaN public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isNaN>
		<isInfinite public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isInfinite>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><x path="Float"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Double"</e></m>
		</meta>
	</class>
	<class path="java.lang.Float" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Float.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><c path="java.lang.Float"/></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<toHexString public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toHexString>
		<valueOf public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Float"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><valueOf public="1" set="method">
	<f a="param1">
		<x path="Single"/>
		<c path="java.lang.Float"/>
	</f>
	<meta><m n=":overload"/></meta>
</valueOf></overloads>
		</valueOf>
		<parseFloat public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Single"/>
			</f>
			<meta><m n=":overload"/></meta>
		</parseFloat>
		<_isNaN public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":native"><e>"isNaN"</e></m>
				<m n=":overload"/>
			</meta>
		</_isNaN>
		<_isInfinite public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":native"><e>"isInfinite"</e></m>
				<m n=":overload"/>
			</meta>
		</_isInfinite>
		<floatToIntBits public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</floatToIntBits>
		<floatToRawIntBits public="1" set="method" static="1">
			<f a="param1">
				<x path="Single"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</floatToRawIntBits>
		<intBitsToFloat public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Single"/>
			</f>
			<meta><m n=":overload"/></meta>
		</intBitsToFloat>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Single"/>
				<x path="Single"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><c path="java.lang.Float"/></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<MIN_EXPONENT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_EXPONENT>
		<MAX_EXPONENT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_EXPONENT>
		<MIN_VALUE public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<MIN_NORMAL public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</MIN_NORMAL>
		<MAX_VALUE public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<NaN public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Single"/>
			<meta><m n=":final"/></meta>
		</POSITIVE_INFINITY>
		<doubleValue public="1" set="method" override="1">
			<f a=""><c path="java.lang.Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<isNaN public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isNaN>
		<isInfinite public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isInfinite>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.lang.Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<x path="Single"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.Float"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Float"</e></m>
		</meta>
	</class>
	<class path="java.lang.Integer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Integer.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><t path="Null"><x path="Int"/></t></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
			<overloads><_toString public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta>
		<m n=":native"><e>"toString"</e></m>
		<m n=":overload"/>
	</meta>
</_toString></overloads>
		</_toString>
		<toHexString public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toHexString>
		<toOctalString public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toOctalString>
		<toBinaryString public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toBinaryString>
		<parseInt public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><parseInt public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</parseInt></overloads>
		</parseInt>
		<valueOf public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<valueOf public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<t path="Null"><x path="Int"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
				<valueOf public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<t path="Null"><x path="Int"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
			</overloads>
		</valueOf>
		<getInteger public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<getInteger public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<t path="Null"><x path="Int"/></t>
						<t path="Null"><x path="Int"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</getInteger>
				<getInteger public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<x path="Int"/>
						<t path="Null"><x path="Int"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</getInteger>
			</overloads>
		</getInteger>
		<decode public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":overload"/></meta>
		</decode>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<highestOneBit public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</highestOneBit>
		<lowestOneBit public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lowestOneBit>
		<numberOfLeadingZeros public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</numberOfLeadingZeros>
		<numberOfTrailingZeros public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</numberOfTrailingZeros>
		<bitCount public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bitCount>
		<rotateLeft public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</rotateLeft>
		<rotateRight public="1" set="method" static="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</rotateRight>
		<reverse public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverse>
		<signum public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</signum>
		<reverseBytes public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverseBytes>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><x path="Int"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<MAX_VALUE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<MIN_VALUE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<doubleValue public="1" set="method" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><x path="Int"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Integer"</e></m>
		</meta>
	</class>
	<class path="java.lang.Integer_IntegerCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Integer$IntegerCache.class" module="java.lang.Integer" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Integer$IntegerCache"</e></m>
</meta></class>
	<class path="java.lang.Iterable" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Iterable.class" extern="1" interface="1">
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.lang.Iterable.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Iterable"</e></m>
		</meta>
	</class>
	<class path="java.lang.Long" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Long.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><t path="Null"><c path="haxe.Int64"/></t></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
			<overloads><_toString public="1" set="method">
	<f a="param1">
		<c path="haxe.Int64"/>
		<c path="String"/>
	</f>
	<meta>
		<m n=":native"><e>"toString"</e></m>
		<m n=":overload"/>
	</meta>
</_toString></overloads>
		</_toString>
		<toHexString public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toHexString>
		<toOctalString public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toOctalString>
		<toBinaryString public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toBinaryString>
		<parseLong public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><parseLong public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<c path="haxe.Int64"/>
	</f>
	<meta><m n=":overload"/></meta>
</parseLong></overloads>
		</parseLong>
		<valueOf public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<t path="Null"><c path="haxe.Int64"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<valueOf public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<t path="Null"><c path="haxe.Int64"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
				<valueOf public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<t path="Null"><c path="haxe.Int64"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
			</overloads>
		</valueOf>
		<decode public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><c path="haxe.Int64"/></t>
			</f>
			<meta><m n=":overload"/></meta>
		</decode>
		<getLong public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><c path="haxe.Int64"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<getLong public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<t path="Null"><c path="haxe.Int64"/></t>
						<t path="Null"><c path="haxe.Int64"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</getLong>
				<getLong public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="haxe.Int64"/>
						<t path="Null"><c path="haxe.Int64"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</getLong>
			</overloads>
		</getLong>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<highestOneBit public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</highestOneBit>
		<lowestOneBit public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lowestOneBit>
		<numberOfLeadingZeros public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</numberOfLeadingZeros>
		<numberOfTrailingZeros public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</numberOfTrailingZeros>
		<bitCount public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bitCount>
		<rotateLeft public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</rotateLeft>
		<rotateRight public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</rotateRight>
		<reverse public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverse>
		<signum public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</signum>
		<reverseBytes public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverseBytes>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><c path="haxe.Int64"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<MAX_VALUE public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<MIN_VALUE public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<doubleValue public="1" set="method" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><c path="haxe.Int64"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Long"</e></m>
		</meta>
	</class>
	<class path="java.lang.Long_LongCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Long$LongCache.class" module="java.lang.Long" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Long$LongCache"</e></m>
</meta></class>
	<class path="java.lang.Package" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Package.class" extern="1">
		<implements path="java.lang.reflect.AnnotatedElement"/>
		<getPackage public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Package"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPackage>
		<getPackages public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Package"/></c></f>
			<meta><m n=":overload"/></meta>
		</getPackages>
		<getAnnotation public="1" params="T" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getSpecificationTitle public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSpecificationTitle>
		<getSpecificationVersion public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSpecificationVersion>
		<getSpecificationVendor public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSpecificationVendor>
		<getImplementationTitle public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getImplementationTitle>
		<getImplementationVersion public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getImplementationVersion>
		<getImplementationVendor public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getImplementationVendor>
		<isSealed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><isSealed public="1" set="method">
	<f a="param1">
		<c path="java.net.URL"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isSealed></overloads>
		</isSealed>
		<isCompatibleWith public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isCompatibleWith>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<isAnnotationPresent public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.lang.annotation.Annotation"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAnnotationPresent>
		<getAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAnnotations>
		<getDeclaredAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Package"</e></m>
		</meta>
	</class>
	<class path="java.lang.Process" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Process.class" extern="1">
		<getOutputStream public="1" set="method">
			<f a=""><c path="java.io.OutputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getOutputStream>
		<getInputStream public="1" set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getInputStream>
		<getErrorStream public="1" set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getErrorStream>
		<waitFor public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</waitFor>
		<exitValue public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</exitValue>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</destroy>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Process"</e></m>
		</meta>
	</class>
	<class path="java.lang.ProcessBuilder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder.class" extern="1">
		<command public="1" set="method">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<c path="java.lang.ProcessBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<command public="1" set="method">
					<f a=""><c path="java.util.List"><c path="String"/></c></f>
					<meta><m n=":overload"/></meta>
				</command>
				<command public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="String"/></c>
						<c path="java.lang.ProcessBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</command>
			</overloads>
		</command>
		<environment public="1" set="method">
			<f a=""><c path="java.util.Map">
	<c path="String"/>
	<c path="String"/>
</c></f>
			<meta><m n=":overload"/></meta>
		</environment>
		<directory public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><directory public="1" set="method">
	<f a="param1">
		<c path="java.io.File"/>
		<c path="java.lang.ProcessBuilder"/>
	</f>
	<meta><m n=":overload"/></meta>
</directory></overloads>
		</directory>
		<redirectInput public="1" set="method">
			<f a="param1">
				<c path="java.lang.ProcessBuilder_Redirect"/>
				<c path="java.lang.ProcessBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<redirectInput public="1" set="method">
					<f a=""><c path="java.lang.ProcessBuilder_Redirect"/></f>
					<meta><m n=":overload"/></meta>
				</redirectInput>
				<redirectInput public="1" set="method">
					<f a="param1">
						<c path="java.io.File"/>
						<c path="java.lang.ProcessBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</redirectInput>
			</overloads>
		</redirectInput>
		<redirectOutput public="1" set="method">
			<f a="param1">
				<c path="java.lang.ProcessBuilder_Redirect"/>
				<c path="java.lang.ProcessBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<redirectOutput public="1" set="method">
					<f a=""><c path="java.lang.ProcessBuilder_Redirect"/></f>
					<meta><m n=":overload"/></meta>
				</redirectOutput>
				<redirectOutput public="1" set="method">
					<f a="param1">
						<c path="java.io.File"/>
						<c path="java.lang.ProcessBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</redirectOutput>
			</overloads>
		</redirectOutput>
		<redirectError public="1" set="method">
			<f a="param1">
				<c path="java.lang.ProcessBuilder_Redirect"/>
				<c path="java.lang.ProcessBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<redirectError public="1" set="method">
					<f a=""><c path="java.lang.ProcessBuilder_Redirect"/></f>
					<meta><m n=":overload"/></meta>
				</redirectError>
				<redirectError public="1" set="method">
					<f a="param1">
						<c path="java.io.File"/>
						<c path="java.lang.ProcessBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</redirectError>
			</overloads>
		</redirectError>
		<inheritIO public="1" set="method">
			<f a=""><c path="java.lang.ProcessBuilder"/></f>
			<meta><m n=":overload"/></meta>
		</inheritIO>
		<redirectErrorStream public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><redirectErrorStream public="1" set="method">
	<f a="param1">
		<x path="Bool"/>
		<c path="java.lang.ProcessBuilder"/>
	</f>
	<meta><m n=":overload"/></meta>
</redirectErrorStream></overloads>
		</redirectErrorStream>
		<start public="1" set="method">
			<f a=""><c path="java.lang.Process"/></f>
			<meta><m n=":overload"/></meta>
		</start>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="String"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ProcessBuilder"</e></m>
		</meta>
	</class>
	<class path="java.lang.ProcessBuilder_NullInputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder$NullInputStream.class" module="java.lang.ProcessBuilder" extern="1">
		<extends path="java.io.InputStream"/>
		<available public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</available>
		<read public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</read>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ProcessBuilder$NullInputStream"</e></m>
		</meta>
	</class>
	<class path="java.lang.ProcessBuilder_NullOutputStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder$NullOutputStream.class" module="java.lang.ProcessBuilder" extern="1">
		<extends path="java.io.OutputStream"/>
		<write public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</write>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ProcessBuilder$NullOutputStream"</e></m>
		</meta>
	</class>
	<class path="java.lang.ProcessBuilder_Redirect" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder$Redirect.class" module="java.lang.ProcessBuilder" extern="1">
		<from public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.File"/>
				<c path="java.lang.ProcessBuilder_Redirect"/>
			</f>
			<meta><m n=":overload"/></meta>
		</from>
		<to public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.File"/>
				<c path="java.lang.ProcessBuilder_Redirect"/>
			</f>
			<meta><m n=":overload"/></meta>
		</to>
		<appendTo public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.File"/>
				<c path="java.lang.ProcessBuilder_Redirect"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendTo>
		<INHERIT public="1" static="1">
			<c path="java.lang.ProcessBuilder_Redirect"/>
			<meta><m n=":final"/></meta>
		</INHERIT>
		<PIPE public="1" static="1">
			<c path="java.lang.ProcessBuilder_Redirect"/>
			<meta><m n=":final"/></meta>
		</PIPE>
		<type public="1" set="method">
			<f a=""><e path="java.lang.ProcessBuilder_Redirect_Type"/></f>
			<meta><m n=":overload"/></meta>
		</type>
		<file public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
		</file>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ProcessBuilder$Redirect"</e></m>
		</meta>
	</class>
	<enum path="java.lang.ProcessBuilder_Redirect_Type" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder$Redirect$Type.class" module="java.lang.ProcessBuilder"><meta><m n=":native"><e>"java.lang.ProcessBuilder$Redirect$Type"</e></m></meta></enum>
	<class path="java.lang.ProcessBuilder_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ProcessBuilder$1.class" module="java.lang.ProcessBuilder" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ProcessBuilder$1"</e></m>
</meta></class>
	<class path="java.lang.Runnable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Runnable.class" extern="1" interface="1">
		<run public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</run>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Runnable"</e></m>
		</meta>
	</class>
	<class path="java.lang.SecurityManager" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/SecurityManager.class" extern="1">
		<getInCheck public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getInCheck>
		<getClassContext set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getClassContext>
		<currentClassLoader set="method">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</currentClassLoader>
		<currentLoadedClass set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</currentLoadedClass>
		<classDepth set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</classDepth>
		<classLoaderDepth set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</classLoaderDepth>
		<inClass set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</inClass>
		<inClassLoader set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</inClassLoader>
		<getSecurityContext public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</getSecurityContext>
		<checkPermission public="1" set="method">
			<f a="param1">
				<c path="java.security.Permission"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><checkPermission public="1" set="method">
	<f a="param1:param2">
		<c path="java.security.Permission"/>
		<d/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</checkPermission></overloads>
		</checkPermission>
		<checkCreateClassLoader public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkCreateClassLoader>
		<checkAccess public="1" set="method">
			<f a="param1">
				<c path="java.lang.Thread"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><checkAccess public="1" set="method">
	<f a="param1">
		<c path="java.lang.ThreadGroup"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</checkAccess></overloads>
		</checkAccess>
		<checkExit public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkExit>
		<checkExec public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkExec>
		<checkLink public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkLink>
		<checkRead public="1" set="method">
			<f a="param1">
				<c path="java.io.FileDescriptor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<checkRead public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</checkRead>
				<checkRead public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</checkRead>
			</overloads>
		</checkRead>
		<checkWrite public="1" set="method">
			<f a="param1">
				<c path="java.io.FileDescriptor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><checkWrite public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</checkWrite></overloads>
		</checkWrite>
		<checkDelete public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkDelete>
		<checkConnect public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><checkConnect public="1" set="method">
	<f a="param1:param2:param3">
		<c path="String"/>
		<x path="Int"/>
		<d/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</checkConnect></overloads>
		</checkConnect>
		<checkListen public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkListen>
		<checkAccept public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkAccept>
		<checkMulticast public="1" set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><checkMulticast public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.InetAddress"/>
		<t path="java.types.Int8"/>
		<x path="Void"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":deprecated"/>
	</meta>
</checkMulticast></overloads>
		</checkMulticast>
		<checkPropertiesAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkPropertiesAccess>
		<checkPropertyAccess public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkPropertyAccess>
		<checkTopLevelWindow public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkTopLevelWindow>
		<checkPrintJobAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkPrintJobAccess>
		<checkSystemClipboardAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkSystemClipboardAccess>
		<checkAwtEventQueueAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkAwtEventQueueAccess>
		<checkPackageAccess public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkPackageAccess>
		<checkPackageDefinition public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkPackageDefinition>
		<checkSetFactory public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</checkSetFactory>
		<checkMemberAccess public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.Class"><d/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkMemberAccess>
		<checkSecurityAccess public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkSecurityAccess>
		<getThreadGroup public="1" set="method">
			<f a=""><c path="java.lang.ThreadGroup"/></f>
			<meta><m n=":overload"/></meta>
		</getThreadGroup>
		<inCheck>
			<x path="Bool"/>
			<meta><m n=":deprecated"/></meta>
		</inCheck>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.SecurityManager"</e></m>
		</meta>
	</class>
	<class path="java.lang.Short" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Short.class" extern="1">
		<extends path="java.lang.Number"/>
		<implements path="java.lang.Comparable"><t path="Null"><t path="java.types.Int16"/></t></implements>
		<_toString public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Int16"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":native"><e>"toString"</e></m>
				<m n=":overload"/>
			</meta>
		</_toString>
		<parseShort public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<t path="java.types.Int16"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><parseShort public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<t path="java.types.Int16"/>
	</f>
	<meta><m n=":overload"/></meta>
</parseShort></overloads>
		</parseShort>
		<valueOf public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<t path="Null"><t path="java.types.Int16"/></t>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<valueOf public="1" set="method">
					<f a="param1">
						<t path="java.types.Int16"/>
						<t path="Null"><t path="java.types.Int16"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
				<valueOf public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<t path="Null"><t path="java.types.Int16"/></t>
					</f>
					<meta><m n=":overload"/></meta>
				</valueOf>
			</overloads>
		</valueOf>
		<decode public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<t path="Null"><t path="java.types.Int16"/></t>
			</f>
			<meta><m n=":overload"/></meta>
		</decode>
		<compare public="1" set="method" static="1">
			<f a="param1:param2">
				<t path="java.types.Int16"/>
				<t path="java.types.Int16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compare>
		<reverseBytes public="1" set="method" static="1">
			<f a="param1">
				<t path="java.types.Int16"/>
				<t path="java.types.Int16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</reverseBytes>
		<SIZE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SIZE>
		<TYPE public="1" static="1">
			<c path="java.lang.Class"><t path="Null"><t path="java.types.Int16"/></t></c>
			<meta><m n=":final"/></meta>
		</TYPE>
		<MAX_VALUE public="1" set="null" static="1">
			<t path="java.types.Int16"/>
			<meta><m n=":final"/></meta>
		</MAX_VALUE>
		<MIN_VALUE public="1" set="null" static="1">
			<t path="java.types.Int16"/>
			<meta><m n=":final"/></meta>
		</MIN_VALUE>
		<doubleValue public="1" set="method" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
		</doubleValue>
		<floatValue public="1" set="method" override="1">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
		</floatValue>
		<longValue public="1" set="method" override="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</longValue>
		<intValue public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</intValue>
		<shortValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</shortValue>
		<byteValue public="1" set="method" override="1">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
		</byteValue>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<t path="Null"><t path="java.types.Int16"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<new public="1" set="method">
			<f a="param1">
				<t path="java.types.Int16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Short"</e></m>
		</meta>
	</class>
	<class path="java.lang.Short_ShortCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Short$ShortCache.class" module="java.lang.Short" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Short$ShortCache"</e></m>
</meta></class>
	<class path="java.lang.StackTraceElement" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/StackTraceElement.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getFileName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getFileName>
		<getLineNumber public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLineNumber>
		<getClassName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getClassName>
		<getMethodName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getMethodName>
		<isNativeMethod public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isNativeMethod>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<new public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.StackTraceElement"</e></m>
		</meta>
	</class>
	<class path="java.lang.StringBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/StringBuffer.class" extern="1">
		<extends path="java.lang.AbstractStringBuilder"/>
		<implements path="java.io.Serializable"/>
		<implements path="java.lang.CharSequence"/>
		<append public="1" set="method" override="1">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Bool"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.lang.StringBuffer"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<d/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<delete public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</delete>
		<appendCodePoint public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendCodePoint>
		<deleteCharAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</deleteCharAt>
		<replace public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</replace>
		<insert public="1" set="method" override="1">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Float"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Single"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="haxe.Int64"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Char16"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Bool"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2:param3:param4">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="String"/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<d/>
						<c path="java.lang.StringBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
			</overloads>
		</insert>
		<reverse public="1" set="method" override="1">
			<f a=""><c path="java.lang.StringBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</reverse>
		<toString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<lastIndexOf public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><lastIndexOf public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</lastIndexOf></overloads>
		</lastIndexOf>
		<indexOf public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><indexOf public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</indexOf></overloads>
		</indexOf>
		<substring public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><substring public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</substring></overloads>
		</substring>
		<subSequence public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.CharSequence"/>
			</f>
			<meta><m n=":overload"/></meta>
		</subSequence>
		<setCharAt public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<t path="java.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setCharAt>
		<getChars public="1" set="method" override="1">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getChars>
		<offsetByCodePoints public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</offsetByCodePoints>
		<codePointCount public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointCount>
		<codePointBefore public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointBefore>
		<codePointAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointAt>
		<charAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</charAt>
		<setLength public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLength>
		<trimToSize public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</trimToSize>
		<ensureCapacity public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</ensureCapacity>
		<capacity public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</capacity>
		<length public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.CharSequence"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.StringBuffer"</e></m>
		</meta>
	</class>
	<class path="java.lang.StringBuilder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/StringBuilder.class" extern="1">
		<extends path="java.lang.AbstractStringBuilder"/>
		<implements path="java.io.Serializable"/>
		<implements path="java.lang.CharSequence"/>
		<append public="1" set="method" override="1">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<x path="Float"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Single"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<x path="Bool"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="java.lang.StringBuffer"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<d/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<length public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</length>
		<capacity public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</capacity>
		<ensureCapacity public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</ensureCapacity>
		<trimToSize public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</trimToSize>
		<setLength public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLength>
		<charAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</charAt>
		<codePointAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointAt>
		<codePointBefore public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointBefore>
		<codePointCount public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</codePointCount>
		<offsetByCodePoints public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</offsetByCodePoints>
		<getChars public="1" set="method" override="1">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getChars>
		<setCharAt public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<t path="java.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setCharAt>
		<delete public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</delete>
		<appendCodePoint public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendCodePoint>
		<deleteCharAt public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</deleteCharAt>
		<replace public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</replace>
		<substring public="1" set="method" override="1">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><substring public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</substring></overloads>
		</substring>
		<subSequence public="1" set="method" override="1">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.CharSequence"/>
			</f>
			<meta><m n=":overload"/></meta>
		</subSequence>
		<insert public="1" set="method" override="1">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.lang.StringBuilder"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Float"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Single"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="haxe.Int64"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Char16"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Bool"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2:param3:param4">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.lang.CharSequence"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="String"/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
				<insert public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<d/>
						<c path="java.lang.StringBuilder"/>
					</f>
					<meta><m n=":overload"/></meta>
				</insert>
			</overloads>
		</insert>
		<reverse public="1" set="method" override="1">
			<f a=""><c path="java.lang.StringBuilder"/></f>
			<meta><m n=":overload"/></meta>
		</reverse>
		<toString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<lastIndexOf public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><lastIndexOf public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</lastIndexOf></overloads>
		</lastIndexOf>
		<indexOf public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><indexOf public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</indexOf></overloads>
		</indexOf>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.CharSequence"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.StringBuilder"</e></m>
		</meta>
	</class>
	<class path="java.lang.System" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/System.class" extern="1">
		<setIn public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.InputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setIn>
		<setOut public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.PrintStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOut>
		<setErr public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.PrintStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setErr>
		<console public="1" set="method" static="1">
			<f a=""><c path="java.io.Console"/></f>
			<meta><m n=":overload"/></meta>
		</console>
		<inheritedChannel public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.Channel"/></f>
			<meta><m n=":overload"/></meta>
		</inheritedChannel>
		<setSecurityManager public="1" set="method" static="1">
			<f a="param1">
				<c path="java.lang.SecurityManager"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSecurityManager>
		<getSecurityManager public="1" set="method" static="1">
			<f a=""><c path="java.lang.SecurityManager"/></f>
			<meta><m n=":overload"/></meta>
		</getSecurityManager>
		<currentTimeMillis public="1" set="method" static="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</currentTimeMillis>
		<nanoTime public="1" set="method" static="1">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</nanoTime>
		<arraycopy public="1" set="method" static="1">
			<f a="param1:param2:param3:param4:param5">
				<d/>
				<x path="Int"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</arraycopy>
		<identityHashCode public="1" set="method" static="1">
			<f a="param1">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</identityHashCode>
		<getProperties public="1" set="method" static="1">
			<f a=""><c path="java.util.Properties"/></f>
			<meta><m n=":overload"/></meta>
		</getProperties>
		<lineSeparator public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</lineSeparator>
		<setProperties public="1" set="method" static="1">
			<f a="param1">
				<c path="java.util.Properties"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setProperties>
		<getProperty public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getProperty public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getProperty></overloads>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setProperty>
		<clearProperty public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</clearProperty>
		<getenv public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getenv public="1" set="method">
	<f a=""><c path="java.util.Map">
	<c path="String"/>
	<c path="String"/>
</c></f>
	<meta><m n=":overload"/></meta>
</getenv></overloads>
		</getenv>
		<exit public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</exit>
		<gc public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</gc>
		<runFinalization public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</runFinalization>
		<runFinalizersOnExit public="1" set="method" static="1">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</runFinalizersOnExit>
		<load public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</load>
		<loadLibrary public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</loadLibrary>
		<mapLibraryName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</mapLibraryName>
		<err public="1" static="1">
			<c path="java.io.PrintStream"/>
			<meta><m n=":final"/></meta>
		</err>
		<out public="1" static="1">
			<c path="java.io.PrintStream"/>
			<meta><m n=":final"/></meta>
		</out>
		<_in public="1" static="1">
			<c path="java.io.InputStream"/>
			<meta>
				<m n=":native"><e>"in"</e></m>
				<m n=":final"/>
			</meta>
		</_in>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.System"</e></m>
		</meta>
	</class>
	<class path="java.lang.Thread" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Thread.class" extern="1">
		<implements path="java.lang.Runnable"/>
		<currentThread public="1" set="method" static="1">
			<f a=""><c path="java.lang.Thread"/></f>
			<meta><m n=":overload"/></meta>
		</currentThread>
		<yield public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</yield>
		<sleep public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><sleep public="1" set="method">
	<f a="param1:param2">
		<c path="haxe.Int64"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</sleep></overloads>
		</sleep>
		<interrupted public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</interrupted>
		<activeCount public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</activeCount>
		<enumerate public="1" set="method" static="1">
			<f a="param1">
				<c path="java.NativeArray"><c path="java.lang.Thread"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</enumerate>
		<dumpStack public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</dumpStack>
		<holdsLock public="1" set="method" static="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</holdsLock>
		<getAllStackTraces public="1" set="method" static="1">
			<f a=""><c path="java.util.Map">
	<c path="java.lang.Thread"/>
	<c path="java.NativeArray"><c path="java.lang.StackTraceElement"/></c>
</c></f>
			<meta><m n=":overload"/></meta>
		</getAllStackTraces>
		<setDefaultUncaughtExceptionHandler public="1" set="method" static="1">
			<f a="param1">
				<c path="java.lang.Thread_UncaughtExceptionHandler"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDefaultUncaughtExceptionHandler>
		<getDefaultUncaughtExceptionHandler public="1" set="method" static="1">
			<f a=""><c path="java.lang.Thread_UncaughtExceptionHandler"/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultUncaughtExceptionHandler>
		<MAX_PRIORITY public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MAX_PRIORITY>
		<NORM_PRIORITY public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</NORM_PRIORITY>
		<MIN_PRIORITY public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</MIN_PRIORITY>
		<clone set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<start public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</start>
		<run public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</run>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
			<overloads><stop public="1" set="method">
	<f a="param1">
		<c path="java.lang.Throwable"/>
		<x path="Void"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":deprecated"/>
		<m n=":final"/>
	</meta>
</stop></overloads>
		</stop>
		<interrupt public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</interrupt>
		<isInterrupted public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isInterrupted>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</destroy>
		<isAlive public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isAlive>
		<suspend public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</suspend>
		<resume public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</resume>
		<setPriority public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setPriority>
		<getPriority public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getPriority>
		<setName public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setName>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getName>
		<getThreadGroup public="1" set="method">
			<f a=""><c path="java.lang.ThreadGroup"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getThreadGroup>
		<countStackFrames public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</countStackFrames>
		<join public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads>
				<join public="1" set="method">
					<f a=""><x path="Void"/></f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</join>
				<join public="1" set="method">
					<f a="param1:param2">
						<c path="haxe.Int64"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</join>
			</overloads>
		</join>
		<setDaemon public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setDaemon>
		<isDaemon public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isDaemon>
		<checkAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</checkAccess>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<getContextClassLoader public="1" set="method">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta><m n=":overload"/></meta>
		</getContextClassLoader>
		<setContextClassLoader public="1" set="method">
			<f a="param1">
				<c path="java.lang.ClassLoader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setContextClassLoader>
		<getStackTrace public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.StackTraceElement"/></c></f>
			<meta><m n=":overload"/></meta>
		</getStackTrace>
		<getId public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getId>
		<getState public="1" set="method">
			<f a=""><e path="java.lang.Thread_State"/></f>
			<meta><m n=":overload"/></meta>
		</getState>
		<getUncaughtExceptionHandler public="1" set="method">
			<f a=""><c path="java.lang.Thread_UncaughtExceptionHandler"/></f>
			<meta><m n=":overload"/></meta>
		</getUncaughtExceptionHandler>
		<setUncaughtExceptionHandler public="1" set="method">
			<f a="param1">
				<c path="java.lang.Thread_UncaughtExceptionHandler"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setUncaughtExceptionHandler>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="java.lang.ThreadGroup"/>
						<c path="java.lang.Runnable"/>
						<c path="String"/>
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.ThreadGroup"/>
						<c path="java.lang.Runnable"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.lang.Runnable"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.lang.ThreadGroup"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.lang.ThreadGroup"/>
						<c path="java.lang.Runnable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.lang.Runnable"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Thread"</e></m>
		</meta>
	</class>
	<class path="java.lang.Thread_Caches" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Thread$Caches.class" module="java.lang.Thread" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Thread$Caches"</e></m>
</meta></class>
	<enum path="java.lang.Thread_State" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Thread$State.class" module="java.lang.Thread"><meta><m n=":native"><e>"java.lang.Thread$State"</e></m></meta></enum>
	<class path="java.lang.Thread_UncaughtExceptionHandler" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Thread$UncaughtExceptionHandler.class" module="java.lang.Thread" extern="1" interface="1">
		<uncaughtException public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.Thread"/>
				<c path="java.lang.Throwable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</uncaughtException>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Thread$UncaughtExceptionHandler"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.Reference" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/Reference.class" extern="1">
		<get public="1" set="method">
			<f a=""><c path="java.lang.ref.Reference.T"/></f>
			<meta><m n=":overload"/></meta>
		</get>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<isEnqueued public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEnqueued>
		<enqueue public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</enqueue>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.Reference"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.WeakReference" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/WeakReference.class" extern="1">
		<extends path="java.lang.ref.Reference"><c path="java.lang.ref.WeakReference.T"/></extends>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.lang.ref.WeakReference.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2">
		<c path="java.lang.ref.WeakReference.T"/>
		<c path="java.lang.ref.ReferenceQueue"><d/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.WeakReference"</e></m>
		</meta>
	</class>
	<class path="java.lang.Thread_WeakClassKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Thread$WeakClassKey.class" module="java.lang.Thread" extern="1">
		<extends path="java.lang.ref.WeakReference"><c path="java.lang.Class"><d/></c></extends>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Thread$WeakClassKey"</e></m>
		</meta>
	</class>
	<class path="java.lang.ThreadGroup" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ThreadGroup.class" extern="1">
		<implements path="java.lang.Thread_UncaughtExceptionHandler"/>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getName>
		<getParent public="1" set="method">
			<f a=""><c path="java.lang.ThreadGroup"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getParent>
		<getMaxPriority public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getMaxPriority>
		<isDaemon public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isDaemon>
		<isDestroyed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDestroyed>
		<setDaemon public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setDaemon>
		<setMaxPriority public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</setMaxPriority>
		<parentOf public="1" set="method">
			<f a="param1">
				<c path="java.lang.ThreadGroup"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</parentOf>
		<checkAccess public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</checkAccess>
		<activeCount public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</activeCount>
		<enumerate public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><c path="java.lang.Thread"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<enumerate public="1" set="method">
					<f a="param1:param2">
						<c path="java.NativeArray"><c path="java.lang.ThreadGroup"/></c>
						<x path="Bool"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</enumerate>
				<enumerate public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.lang.ThreadGroup"/></c>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</enumerate>
				<enumerate public="1" set="method">
					<f a="param1:param2">
						<c path="java.NativeArray"><c path="java.lang.Thread"/></c>
						<x path="Bool"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</enumerate>
			</overloads>
		</enumerate>
		<activeGroupCount public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</activeGroupCount>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</stop>
		<interrupt public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</interrupt>
		<suspend public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</suspend>
		<resume public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
				<m n=":final"/>
			</meta>
		</resume>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</destroy>
		<list public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</list>
		<uncaughtException public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.Thread"/>
				<c path="java.lang.Throwable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</uncaughtException>
		<allowThreadSuspension public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</allowThreadSuspension>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2">
		<c path="java.lang.ThreadGroup"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ThreadGroup"</e></m>
		</meta>
	</class>
	<class path="java.lang.Throwable_SentinelHolder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable$SentinelHolder.class" module="java.lang.Throwable" extern="1">
		<STACK_TRACE_SENTINEL public="1" static="1">
			<c path="java.NativeArray"><c path="java.lang.StackTraceElement"/></c>
			<meta><m n=":final"/></meta>
		</STACK_TRACE_SENTINEL>
		<STACK_TRACE_ELEMENT_SENTINEL public="1" static="1">
			<c path="java.lang.StackTraceElement"/>
			<meta><m n=":final"/></meta>
		</STACK_TRACE_ELEMENT_SENTINEL>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Throwable$SentinelHolder"</e></m>
		</meta>
	</class>
	<class path="java.lang.Throwable_PrintStreamOrWriter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable$PrintStreamOrWriter.class" module="java.lang.Throwable" extern="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Throwable$PrintStreamOrWriter"</e></m>
</meta></class>
	<class path="java.lang.Throwable_WrappedPrintStream" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable$WrappedPrintStream.class" module="java.lang.Throwable" extern="1">
		<extends path="java.lang.Throwable_PrintStreamOrWriter"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Throwable$WrappedPrintStream"</e></m>
		</meta>
	</class>
	<class path="java.lang.Throwable_WrappedPrintWriter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable$WrappedPrintWriter.class" module="java.lang.Throwable" extern="1">
		<extends path="java.lang.Throwable_PrintStreamOrWriter"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.Throwable$WrappedPrintWriter"</e></m>
		</meta>
	</class>
	<class path="java.lang.Throwable_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/Throwable$1.class" module="java.lang.Throwable" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.Throwable$1"</e></m>
</meta></class>
	<class path="java.lang.annotation.Annotation" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/annotation/Annotation.class" extern="1" interface="1">
		<annotationType public="1" set="method">
			<f a=""><c path="java.lang.Class"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</annotationType>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.annotation.Annotation"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.Reference_Lock" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/Reference$Lock.class" module="java.lang.ref.Reference" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ref.Reference$Lock"</e></m>
</meta></class>
	<class path="java.lang.ref.Reference_ReferenceHandler" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/Reference$ReferenceHandler.class" module="java.lang.ref.Reference" extern="1">
		<extends path="java.lang.Thread"/>
		<run public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</run>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.Reference$ReferenceHandler"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.Reference_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/Reference$1.class" module="java.lang.ref.Reference" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ref.Reference$1"</e></m>
</meta></class>
	<class path="java.lang.ref.ReferenceQueue" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/ReferenceQueue.class" extern="1">
		<poll public="1" set="method">
			<f a=""><c path="java.lang.ref.Reference"><c path="java.lang.ref.ReferenceQueue.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</poll>
		<remove public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.lang.ref.Reference"><c path="java.lang.ref.ReferenceQueue.T"/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><remove public="1" set="method">
	<f a=""><c path="java.lang.ref.Reference"><c path="java.lang.ref.ReferenceQueue.T"/></c></f>
	<meta><m n=":overload"/></meta>
</remove></overloads>
		</remove>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.ReferenceQueue"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.ReferenceQueue_Null" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/ReferenceQueue$Null.class" module="java.lang.ref.ReferenceQueue" extern="1">
		<extends path="java.lang.ref.ReferenceQueue"><d/></extends>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.ReferenceQueue$Null"</e></m>
		</meta>
	</class>
	<class path="java.lang.ref.ReferenceQueue_Lock" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/ReferenceQueue$Lock.class" module="java.lang.ref.ReferenceQueue" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ref.ReferenceQueue$Lock"</e></m>
</meta></class>
	<class path="java.lang.ref.ReferenceQueue_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/ReferenceQueue$1.class" module="java.lang.ref.ReferenceQueue" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.lang.ref.ReferenceQueue$1"</e></m>
</meta></class>
	<class path="java.lang.ref.SoftReference" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/ref/SoftReference.class" extern="1">
		<extends path="java.lang.ref.Reference"><c path="java.lang.ref.SoftReference.T"/></extends>
		<get public="1" set="method" override="1">
			<f a=""><c path="java.lang.ref.SoftReference.T"/></f>
			<meta><m n=":overload"/></meta>
		</get>
		<new public="1" set="method">
			<f a="param1">
				<c path="java.lang.ref.SoftReference.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2">
		<c path="java.lang.ref.SoftReference.T"/>
		<c path="java.lang.ref.ReferenceQueue"><d/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.ref.SoftReference"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.AccessibleObject" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/AccessibleObject.class" extern="1">
		<implements path="java.lang.reflect.AnnotatedElement"/>
		<_setAccessible public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="java.NativeArray"><c path="java.lang.reflect.AccessibleObject"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":native"><e>"setAccessible"</e></m>
				<m n=":overload"/>
			</meta>
		</_setAccessible>
		<setAccessible public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setAccessible>
		<isAccessible public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAccessible>
		<getAnnotation public="1" params="T" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<isAnnotationPresent public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.lang.annotation.Annotation"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isAnnotationPresent>
		<getAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAnnotations>
		<getDeclaredAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.AccessibleObject"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Member" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Member.class" extern="1" interface="1">
		<getDeclaringClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaringClass>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getModifiers public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getModifiers>
		<isSynthetic public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSynthetic>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.Member"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Constructor" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Constructor.class" extern="1">
		<extends path="java.lang.reflect.AccessibleObject"/>
		<implements path="java.lang.reflect.Member"/>
		<implements path="java.lang.reflect.GenericDeclaration"/>
		<getTypeParameters public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.TypeVariable"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getTypeParameters>
		<getDeclaringClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><c path="java.lang.reflect.Constructor.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaringClass>
		<getDeclaredAnnotations public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<getAnnotation public="1" params="T" set="method" override="1">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getModifiers public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getModifiers>
		<getParameterTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getParameterTypes>
		<getGenericParameterTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getGenericParameterTypes>
		<getExceptionTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getExceptionTypes>
		<getGenericExceptionTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getGenericExceptionTypes>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toGenericString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toGenericString>
		<newInstance public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><d/></c>
				<c path="java.lang.reflect.Constructor.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newInstance>
		<isVarArgs public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isVarArgs>
		<isSynthetic public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSynthetic>
		<getParameterAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getParameterAnnotations>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.Constructor"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Field" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Field.class" extern="1">
		<extends path="java.lang.reflect.AccessibleObject"/>
		<implements path="java.lang.reflect.Member"/>
		<getDeclaredAnnotations public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<getAnnotation public="1" params="T" set="method" override="1">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<getDeclaringClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaringClass>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getModifiers public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getModifiers>
		<isEnumConstant public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEnumConstant>
		<isSynthetic public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSynthetic>
		<getType public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getType>
		<getGenericType public="1" set="method">
			<f a=""><c path="java.lang.reflect.Type"/></f>
			<meta><m n=":overload"/></meta>
		</getGenericType>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toGenericString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toGenericString>
		<get public="1" set="method">
			<f a="param1">
				<d/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<getBoolean public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getBoolean>
		<getByte public="1" set="method">
			<f a="param1">
				<d/>
				<t path="java.types.Int8"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getByte>
		<getChar public="1" set="method">
			<f a="param1">
				<d/>
				<t path="java.types.Char16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getChar>
		<getShort public="1" set="method">
			<f a="param1">
				<d/>
				<t path="java.types.Int16"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getShort>
		<getInt public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getInt>
		<getLong public="1" set="method">
			<f a="param1">
				<d/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getLong>
		<getFloat public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Single"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFloat>
		<getDouble public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDouble>
		<set public="1" set="method">
			<f a="param1:param2">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</set>
		<setBoolean public="1" set="method">
			<f a="param1:param2">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setBoolean>
		<setByte public="1" set="method">
			<f a="param1:param2">
				<d/>
				<t path="java.types.Int8"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setByte>
		<setChar public="1" set="method">
			<f a="param1:param2">
				<d/>
				<t path="java.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setChar>
		<setShort public="1" set="method">
			<f a="param1:param2">
				<d/>
				<t path="java.types.Int16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setShort>
		<setInt public="1" set="method">
			<f a="param1:param2">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setInt>
		<setLong public="1" set="method">
			<f a="param1:param2">
				<d/>
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLong>
		<setFloat public="1" set="method">
			<f a="param1:param2">
				<d/>
				<x path="Single"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setFloat>
		<setDouble public="1" set="method">
			<f a="param1:param2">
				<d/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDouble>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.Field"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Member_Statics" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Member.class" module="java.lang.reflect.Member" extern="1">
		<DECLARED public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</DECLARED>
		<PUBLIC public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</PUBLIC>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.Member"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.Method" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/Method.class" extern="1">
		<extends path="java.lang.reflect.AccessibleObject"/>
		<implements path="java.lang.reflect.GenericDeclaration"/>
		<implements path="java.lang.reflect.Member"/>
		<getTypeParameters public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.TypeVariable"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getTypeParameters>
		<getDeclaredAnnotations public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaredAnnotations>
		<getAnnotation public="1" params="T" set="method" override="1">
			<f a="param1">
				<c path="java.lang.Class"><c path="getAnnotation.T"/></c>
				<c path="getAnnotation.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAnnotation>
		<getDeclaringClass public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getDeclaringClass>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getModifiers public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getModifiers>
		<getReturnType public="1" set="method">
			<f a=""><c path="java.lang.Class"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</getReturnType>
		<getGenericReturnType public="1" set="method">
			<f a=""><c path="java.lang.reflect.Type"/></f>
			<meta><m n=":overload"/></meta>
		</getGenericReturnType>
		<getParameterTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getParameterTypes>
		<getGenericParameterTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getGenericParameterTypes>
		<getExceptionTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getExceptionTypes>
		<getGenericExceptionTypes public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getGenericExceptionTypes>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toGenericString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toGenericString>
		<invoke public="1" set="method">
			<f a="param1:param2">
				<d/>
				<c path="java.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</invoke>
		<isBridge public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isBridge>
		<isVarArgs public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isVarArgs>
		<isSynthetic public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSynthetic>
		<getDefaultValue public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultValue>
		<getParameterAnnotations public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.NativeArray"><c path="java.lang.annotation.Annotation"/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getParameterAnnotations>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.Method"</e></m>
		</meta>
	</class>
	<class path="java.lang.reflect.TypeVariable" params="D" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/lang/reflect/TypeVariable.class" extern="1" interface="1">
		<extends path="java.lang.reflect.Type"/>
		<getBounds public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.lang.reflect.Type"/></c></f>
			<meta><m n=":overload"/></meta>
		</getBounds>
		<getGenericDeclaration public="1" set="method">
			<f a=""><c path="java.lang.reflect.TypeVariable.D"/></f>
			<meta><m n=":overload"/></meta>
		</getGenericDeclaration>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.lang.reflect.TypeVariable"</e></m>
		</meta>
	</class>
	<class path="java.net.ContentHandler" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/ContentHandler.class" extern="1">
		<getContent public="1" set="method">
			<f a="param1">
				<c path="java.net.URLConnection"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getContent public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.URLConnection"/>
		<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</getContent></overloads>
		</getContent>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.ContentHandler"</e></m>
		</meta>
	</class>
	<class path="java.net.ContentHandlerFactory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/ContentHandlerFactory.class" extern="1" interface="1">
		<createContentHandler public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.ContentHandler"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createContentHandler>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.ContentHandlerFactory"</e></m>
		</meta>
	</class>
	<class path="java.net.DatagramPacket" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/DatagramPacket.class" extern="1">
		<getAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getAddress>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<getData public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getData>
		<getOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getOffset>
		<getLength public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLength>
		<setData public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setData public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><t path="java.types.Int8"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</setData></overloads>
		</setData>
		<setAddress public="1" set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setAddress>
		<setPort public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setPort>
		<setSocketAddress public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSocketAddress>
		<getSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getSocketAddress>
		<setLength public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLength>
		<new public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<c path="java.net.SocketAddress"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.net.SocketAddress"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.DatagramPacket"</e></m>
		</meta>
	</class>
	<class path="java.net.DatagramSocket" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/DatagramSocket.class" extern="1">
		<implements path="java.io.Closeable"/>
		<setDatagramSocketImplFactory public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.DatagramSocketImplFactory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDatagramSocketImplFactory>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<connect public="1" set="method">
			<f a="param1:param2">
				<c path="java.net.InetAddress"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><connect public="1" set="method">
	<f a="param1">
		<c path="java.net.SocketAddress"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</connect></overloads>
		</connect>
		<disconnect public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</disconnect>
		<isBound public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isBound>
		<isConnected public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isConnected>
		<getInetAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getInetAddress>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<getRemoteSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getRemoteSocketAddress>
		<getLocalSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalSocketAddress>
		<send public="1" set="method">
			<f a="param1">
				<c path="java.net.DatagramPacket"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</send>
		<receive public="1" set="method">
			<f a="param1">
				<c path="java.net.DatagramPacket"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</receive>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<getLocalPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalPort>
		<setSoTimeout public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSoTimeout>
		<getSoTimeout public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSoTimeout>
		<setSendBufferSize public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSendBufferSize>
		<getSendBufferSize public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSendBufferSize>
		<setReceiveBufferSize public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReceiveBufferSize>
		<getReceiveBufferSize public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getReceiveBufferSize>
		<setReuseAddress public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReuseAddress>
		<getReuseAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getReuseAddress>
		<setBroadcast public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setBroadcast>
		<getBroadcast public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getBroadcast>
		<setTrafficClass public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setTrafficClass>
		<getTrafficClass public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getTrafficClass>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<isClosed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isClosed>
		<getChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.DatagramChannel"/></f>
			<meta><m n=":overload"/></meta>
		</getChannel>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.net.SocketAddress"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new set="method">
					<f a="param1">
						<c path="java.net.DatagramSocketImpl"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.DatagramSocket"</e></m>
		</meta>
	</class>
	<class path="java.net.SocketOptions" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketOptions.class" extern="1" interface="1">
		<setOption public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOption>
		<getOption public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketOptions"</e></m>
		</meta>
	</class>
	<class path="java.net.DatagramSocketImpl" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/DatagramSocketImpl.class" extern="1">
		<implements path="java.net.SocketOptions"/>
		<setOption public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOption>
		<getOption public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<create set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</create>
		<bind set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<c path="java.net.InetAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<send set="method">
			<f a="param1">
				<c path="java.net.DatagramPacket"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</send>
		<connect set="method">
			<f a="param1:param2">
				<c path="java.net.InetAddress"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</connect>
		<disconnect set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</disconnect>
		<peek set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</peek>
		<peekData set="method">
			<f a="param1">
				<c path="java.net.DatagramPacket"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</peekData>
		<receive set="method">
			<f a="param1">
				<c path="java.net.DatagramPacket"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</receive>
		<setTTL set="method">
			<f a="param1">
				<t path="java.types.Int8"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setTTL>
		<getTTL set="method">
			<f a=""><t path="java.types.Int8"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getTTL>
		<setTimeToLive set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setTimeToLive>
		<getTimeToLive set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getTimeToLive>
		<join set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</join>
		<leave set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</leave>
		<joinGroup set="method">
			<f a="param1:param2">
				<c path="java.net.SocketAddress"/>
				<c path="java.net.NetworkInterface"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</joinGroup>
		<leaveGroup set="method">
			<f a="param1:param2">
				<c path="java.net.SocketAddress"/>
				<c path="java.net.NetworkInterface"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</leaveGroup>
		<close set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<getLocalPort set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalPort>
		<getFileDescriptor set="method">
			<f a=""><c path="java.io.FileDescriptor"/></f>
			<meta><m n=":overload"/></meta>
		</getFileDescriptor>
		<fd><c path="java.io.FileDescriptor"/></fd>
		<localPort><x path="Int"/></localPort>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.DatagramSocketImpl"</e></m>
		</meta>
	</class>
	<class path="java.net.DatagramSocketImplFactory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/DatagramSocketImplFactory.class" extern="1" interface="1">
		<createDatagramSocketImpl public="1" set="method">
			<f a=""><c path="java.net.DatagramSocketImpl"/></f>
			<meta><m n=":overload"/></meta>
		</createDatagramSocketImpl>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.DatagramSocketImplFactory"</e></m>
		</meta>
	</class>
	<class path="java.net.FileNameMap" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/FileNameMap.class" extern="1" interface="1">
		<getContentTypeFor public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getContentTypeFor>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.FileNameMap"</e></m>
		</meta>
	</class>
	<class path="java.net.InetAddress" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetAddress.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getByAddress public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<c path="java.net.InetAddress"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getByAddress public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><t path="java.types.Int8"/></c>
		<c path="java.net.InetAddress"/>
	</f>
	<meta><m n=":overload"/></meta>
</getByAddress></overloads>
		</getByAddress>
		<getByName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.InetAddress"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getByName>
		<getAllByName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.NativeArray"><c path="java.net.InetAddress"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getAllByName>
		<getLoopbackAddress public="1" set="method" static="1">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLoopbackAddress>
		<getLocalHost public="1" set="method" static="1">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalHost>
		<isMulticastAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMulticastAddress>
		<isAnyLocalAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAnyLocalAddress>
		<isLoopbackAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isLoopbackAddress>
		<isLinkLocalAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isLinkLocalAddress>
		<isSiteLocalAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSiteLocalAddress>
		<isMCGlobal public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMCGlobal>
		<isMCNodeLocal public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMCNodeLocal>
		<isMCLinkLocal public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMCLinkLocal>
		<isMCSiteLocal public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMCSiteLocal>
		<isMCOrgLocal public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isMCOrgLocal>
		<isReachable public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><isReachable public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.net.NetworkInterface"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</isReachable></overloads>
		</isReachable>
		<getHostName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getHostName>
		<getCanonicalHostName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getCanonicalHostName>
		<getAddress public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAddress>
		<getHostAddress public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getHostAddress>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.InetAddress"</e></m>
		</meta>
	</class>
	<class path="java.net.InetAddress_CacheEntry" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetAddress$CacheEntry.class" module="java.net.InetAddress" extern="1"><meta>
	<m n=":final"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.net.InetAddress$CacheEntry"</e></m>
</meta></class>
	<class path="java.net.InetAddress_Cache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetAddress$Cache.class" module="java.net.InetAddress" extern="1">
		<put public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><c path="java.net.InetAddress"/></c>
				<c path="java.net.InetAddress_Cache"/>
			</f>
			<meta><m n=":overload"/></meta>
		</put>
		<get public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.InetAddress_CacheEntry"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<new public="1" set="method">
			<f a="param1">
				<e path="java.net.InetAddress_Cache_Type"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.InetAddress$Cache"</e></m>
		</meta>
	</class>
	<enum path="java.net.InetAddress_Cache_Type" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetAddress$Cache$Type.class" module="java.net.InetAddress"><meta><m n=":native"><e>"java.net.InetAddress$Cache$Type"</e></m></meta></enum>
	<class path="java.net.SocketAddress" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketAddress.class" extern="1">
		<implements path="java.io.Serializable"/>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketAddress"</e></m>
		</meta>
	</class>
	<class path="java.net.InetSocketAddress" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetSocketAddress.class" extern="1">
		<extends path="java.net.SocketAddress"/>
		<createUnresolved public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<c path="java.net.InetSocketAddress"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createUnresolved>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getPort>
		<getAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getAddress>
		<getHostName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getHostName>
		<getHostString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getHostString>
		<isUnresolved public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isUnresolved>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hashCode>
		<new public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.InetSocketAddress"</e></m>
		</meta>
	</class>
	<class path="java.net.InetSocketAddress_InetSocketAddressHolder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetSocketAddress$InetSocketAddressHolder.class" module="java.net.InetSocketAddress" extern="1">
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hashCode>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.InetSocketAddress$InetSocketAddressHolder"</e></m>
		</meta>
	</class>
	<class path="java.net.InetSocketAddress_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InetSocketAddress$1.class" module="java.net.InetSocketAddress" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.net.InetSocketAddress$1"</e></m>
</meta></class>
	<class path="java.net.InterfaceAddress" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/InterfaceAddress.class" extern="1">
		<getAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getAddress>
		<getBroadcast public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getBroadcast>
		<getNetworkPrefixLength public="1" set="method">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
		</getNetworkPrefixLength>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.InterfaceAddress"</e></m>
		</meta>
	</class>
	<class path="java.net.NetworkInterface" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/NetworkInterface.class" extern="1">
		<getByName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.NetworkInterface"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getByName>
		<getByIndex public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.net.NetworkInterface"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getByIndex>
		<getByInetAddress public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<c path="java.net.NetworkInterface"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getByInetAddress>
		<getNetworkInterfaces public="1" set="method" static="1">
			<f a=""><c path="java.util.Enumeration"><c path="java.net.NetworkInterface"/></c></f>
			<meta><m n=":overload"/></meta>
		</getNetworkInterfaces>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<getInetAddresses public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="java.net.InetAddress"/></c></f>
			<meta><m n=":overload"/></meta>
		</getInetAddresses>
		<getInterfaceAddresses public="1" set="method">
			<f a=""><c path="java.util.List"><c path="java.net.InterfaceAddress"/></c></f>
			<meta><m n=":overload"/></meta>
		</getInterfaceAddresses>
		<getSubInterfaces public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="java.net.NetworkInterface"/></c></f>
			<meta><m n=":overload"/></meta>
		</getSubInterfaces>
		<getParent public="1" set="method">
			<f a=""><c path="java.net.NetworkInterface"/></f>
			<meta><m n=":overload"/></meta>
		</getParent>
		<getIndex public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getIndex>
		<getDisplayName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getDisplayName>
		<isUp public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isUp>
		<isLoopback public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isLoopback>
		<isPointToPoint public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isPointToPoint>
		<supportsMulticast public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</supportsMulticast>
		<getHardwareAddress public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getHardwareAddress>
		<getMTU public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getMTU>
		<isVirtual public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isVirtual>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.NetworkInterface"</e></m>
		</meta>
	</class>
	<class path="java.net.ProtocolFamily" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/ProtocolFamily.class" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.ProtocolFamily"</e></m>
		</meta>
	</class>
	<class path="java.net.Proxy" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/Proxy.class" extern="1">
		<NO_PROXY public="1" static="1">
			<c path="java.net.Proxy"/>
			<meta><m n=":final"/></meta>
		</NO_PROXY>
		<type public="1" set="method">
			<f a=""><e path="java.net.Proxy_Type"/></f>
			<meta><m n=":overload"/></meta>
		</type>
		<address public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</address>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hashCode>
		<new public="1" set="method">
			<f a="param1:param2">
				<e path="java.net.Proxy_Type"/>
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.Proxy"</e></m>
		</meta>
	</class>
	<enum path="java.net.Proxy_Type" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/Proxy$Type.class" module="java.net.Proxy"><meta><m n=":native"><e>"java.net.Proxy$Type"</e></m></meta></enum>
	<class path="java.net.ServerSocket" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/ServerSocket.class" extern="1">
		<implements path="java.io.Closeable"/>
		<setSocketFactory public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.SocketImplFactory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSocketFactory>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><bind public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketAddress"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</bind></overloads>
		</bind>
		<getInetAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getInetAddress>
		<getLocalPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalPort>
		<getLocalSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalSocketAddress>
		<accept public="1" set="method">
			<f a=""><c path="java.net.Socket"/></f>
			<meta><m n=":overload"/></meta>
		</accept>
		<implAccept set="method">
			<f a="param1">
				<c path="java.net.Socket"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</implAccept>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<getChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.ServerSocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</getChannel>
		<isBound public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isBound>
		<isClosed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isClosed>
		<setSoTimeout public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSoTimeout>
		<getSoTimeout public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSoTimeout>
		<setReuseAddress public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReuseAddress>
		<getReuseAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getReuseAddress>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<setReceiveBufferSize public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReceiveBufferSize>
		<getReceiveBufferSize public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getReceiveBufferSize>
		<setPerformancePreferences public="1" set="method">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setPerformancePreferences>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.ServerSocket"</e></m>
		</meta>
	</class>
	<class path="java.net.Socket" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/Socket.class" extern="1">
		<implements path="java.io.Closeable"/>
		<setSocketImplFactory public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.SocketImplFactory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSocketImplFactory>
		<connect public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><connect public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketAddress"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</connect></overloads>
		</connect>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<getInetAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getInetAddress>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<getLocalPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalPort>
		<getRemoteSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getRemoteSocketAddress>
		<getLocalSocketAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalSocketAddress>
		<getChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</getChannel>
		<getInputStream public="1" set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getInputStream>
		<getOutputStream public="1" set="method">
			<f a=""><c path="java.io.OutputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getOutputStream>
		<setTcpNoDelay public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setTcpNoDelay>
		<getTcpNoDelay public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getTcpNoDelay>
		<setSoLinger public="1" set="method">
			<f a="param1:param2">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSoLinger>
		<getSoLinger public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSoLinger>
		<sendUrgentData public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</sendUrgentData>
		<setOOBInline public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOOBInline>
		<getOOBInline public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getOOBInline>
		<setSoTimeout public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSoTimeout>
		<getSoTimeout public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSoTimeout>
		<setSendBufferSize public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setSendBufferSize>
		<getSendBufferSize public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getSendBufferSize>
		<setReceiveBufferSize public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReceiveBufferSize>
		<getReceiveBufferSize public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getReceiveBufferSize>
		<setKeepAlive public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setKeepAlive>
		<getKeepAlive public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getKeepAlive>
		<setTrafficClass public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setTrafficClass>
		<getTrafficClass public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getTrafficClass>
		<setReuseAddress public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReuseAddress>
		<getReuseAddress public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getReuseAddress>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<shutdownInput public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownInput>
		<shutdownOutput public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownOutput>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<isConnected public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isConnected>
		<isBound public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isBound>
		<isClosed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isClosed>
		<isInputShutdown public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isInputShutdown>
		<isOutputShutdown public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOutputShutdown>
		<setPerformancePreferences public="1" set="method">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setPerformancePreferences>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<x path="Int"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="String"/>
						<x path="Int"/>
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new set="method">
					<f a="param1">
						<c path="java.net.SocketImpl"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.net.Proxy"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.Socket"</e></m>
		</meta>
	</class>
	<class path="java.net.SocketImpl" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketImpl.class" extern="1">
		<implements path="java.net.SocketOptions"/>
		<setOption public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOption>
		<getOption public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<create set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</create>
		<connect set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<connect set="method">
					<f a="param1:param2">
						<c path="java.net.SocketAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</connect>
				<connect set="method">
					<f a="param1:param2">
						<c path="java.net.InetAddress"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</connect>
			</overloads>
		</connect>
		<bind set="method">
			<f a="param1:param2">
				<c path="java.net.InetAddress"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<listen set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</listen>
		<accept set="method">
			<f a="param1">
				<c path="java.net.SocketImpl"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</accept>
		<getInputStream set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getInputStream>
		<getOutputStream set="method">
			<f a=""><c path="java.io.OutputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getOutputStream>
		<available set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</available>
		<close set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<shutdownInput set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownInput>
		<shutdownOutput set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownOutput>
		<getFileDescriptor set="method">
			<f a=""><c path="java.io.FileDescriptor"/></f>
			<meta><m n=":overload"/></meta>
		</getFileDescriptor>
		<getInetAddress set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getInetAddress>
		<getPort set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<supportsUrgentData set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</supportsUrgentData>
		<sendUrgentData set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</sendUrgentData>
		<getLocalPort set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalPort>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<setPerformancePreferences set="method">
			<f a="param1:param2:param3">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setPerformancePreferences>
		<localport><x path="Int"/></localport>
		<port><x path="Int"/></port>
		<address><c path="java.net.InetAddress"/></address>
		<fd><c path="java.io.FileDescriptor"/></fd>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketImpl"</e></m>
		</meta>
	</class>
	<class path="java.net.SocketImplFactory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketImplFactory.class" extern="1" interface="1">
		<createSocketImpl public="1" set="method">
			<f a=""><c path="java.net.SocketImpl"/></f>
			<meta><m n=":overload"/></meta>
		</createSocketImpl>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketImplFactory"</e></m>
		</meta>
	</class>
	<class path="java.net.SocketOption" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketOption.class" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<type public="1" set="method">
			<f a=""><c path="java.lang.Class"><c path="java.net.SocketOption.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</type>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketOption"</e></m>
		</meta>
	</class>
	<class path="java.net.SocketOptions_Statics" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/SocketOptions.class" module="java.net.SocketOptions" extern="1">
		<SO_OOBINLINE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_OOBINLINE>
		<SO_KEEPALIVE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_KEEPALIVE>
		<SO_RCVBUF public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_RCVBUF>
		<SO_SNDBUF public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_SNDBUF>
		<SO_TIMEOUT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_TIMEOUT>
		<SO_LINGER public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_LINGER>
		<IP_TOS public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</IP_TOS>
		<IP_MULTICAST_LOOP public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</IP_MULTICAST_LOOP>
		<IP_MULTICAST_IF2 public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</IP_MULTICAST_IF2>
		<IP_MULTICAST_IF public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</IP_MULTICAST_IF>
		<SO_BROADCAST public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_BROADCAST>
		<SO_REUSEADDR public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_REUSEADDR>
		<SO_BINDADDR public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</SO_BINDADDR>
		<TCP_NODELAY public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</TCP_NODELAY>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.SocketOptions"</e></m>
		</meta>
	</class>
	<class path="java.net.URI" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URI.class" extern="1">
		<implements path="java.io.Serializable"/>
		<implements path="java.lang.Comparable"><c path="java.net.URI"/></implements>
		<create public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URI"/>
			</f>
			<meta><m n=":overload"/></meta>
		</create>
		<parseServerAuthority public="1" set="method">
			<f a=""><c path="java.net.URI"/></f>
			<meta><m n=":overload"/></meta>
		</parseServerAuthority>
		<normalize public="1" set="method">
			<f a=""><c path="java.net.URI"/></f>
			<meta><m n=":overload"/></meta>
		</normalize>
		<resolve public="1" set="method">
			<f a="param1">
				<c path="java.net.URI"/>
				<c path="java.net.URI"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><resolve public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<c path="java.net.URI"/>
	</f>
	<meta><m n=":overload"/></meta>
</resolve></overloads>
		</resolve>
		<relativize public="1" set="method">
			<f a="param1">
				<c path="java.net.URI"/>
				<c path="java.net.URI"/>
			</f>
			<meta><m n=":overload"/></meta>
		</relativize>
		<toURL public="1" set="method">
			<f a=""><c path="java.net.URL"/></f>
			<meta><m n=":overload"/></meta>
		</toURL>
		<getScheme public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getScheme>
		<isAbsolute public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAbsolute>
		<isOpaque public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpaque>
		<getRawSchemeSpecificPart public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawSchemeSpecificPart>
		<getSchemeSpecificPart public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSchemeSpecificPart>
		<getRawAuthority public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawAuthority>
		<getAuthority public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getAuthority>
		<getRawUserInfo public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawUserInfo>
		<getUserInfo public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getUserInfo>
		<getHost public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getHost>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<getRawPath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawPath>
		<getPath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getPath>
		<getRawQuery public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawQuery>
		<getQuery public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getQuery>
		<getRawFragment public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRawFragment>
		<getFragment public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getFragment>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.net.URI"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toASCIIString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toASCIIString>
		<new public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5:param6:param7">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.URI"</e></m>
		</meta>
	</class>
	<class path="java.net.URI_Parser" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URI$Parser.class" module="java.net.URI" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.net.URI$Parser"</e></m>
</meta></class>
	<class path="java.net.URL" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URL.class" extern="1">
		<implements path="java.io.Serializable"/>
		<setURLStreamHandlerFactory public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.URLStreamHandlerFactory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setURLStreamHandlerFactory>
		<set set="method">
			<f a="param1:param2:param3:param4:param5">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><set set="method">
	<f a="param1:param2:param3:param4:param5:param6:param7:param8">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</set></overloads>
		</set>
		<getQuery public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getQuery>
		<getPath public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getPath>
		<getUserInfo public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getUserInfo>
		<getAuthority public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getAuthority>
		<getPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getPort>
		<getDefaultPort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultPort>
		<getProtocol public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getProtocol>
		<getHost public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getHost>
		<getFile public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getFile>
		<getRef public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRef>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<sameFile public="1" set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</sameFile>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toExternalForm public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toExternalForm>
		<toURI public="1" set="method">
			<f a=""><c path="java.net.URI"/></f>
			<meta><m n=":overload"/></meta>
		</toURI>
		<openConnection public="1" set="method">
			<f a=""><c path="java.net.URLConnection"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><openConnection public="1" set="method">
	<f a="param1">
		<c path="java.net.Proxy"/>
		<c path="java.net.URLConnection"/>
	</f>
	<meta><m n=":overload"/></meta>
</openConnection></overloads>
		</openConnection>
		<openStream public="1" set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</openStream>
		<getContent public="1" set="method">
			<f a=""><d/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><getContent public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
		<d/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</getContent></overloads>
		</getContent>
		<new public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.net.URL"/>
						<c path="String"/>
						<c path="java.net.URLStreamHandler"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="java.net.URL"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5">
						<c path="String"/>
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<c path="java.net.URLStreamHandler"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.URL"</e></m>
		</meta>
	</class>
	<class path="java.net.URLConnection" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URLConnection.class" extern="1">
		<getFileNameMap public="1" set="method" static="1">
			<f a=""><c path="java.net.FileNameMap"/></f>
			<meta><m n=":overload"/></meta>
		</getFileNameMap>
		<setFileNameMap public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.FileNameMap"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setFileNameMap>
		<setDefaultAllowUserInteraction public="1" set="method" static="1">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDefaultAllowUserInteraction>
		<getDefaultAllowUserInteraction public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultAllowUserInteraction>
		<setDefaultRequestProperty public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setDefaultRequestProperty>
		<getDefaultRequestProperty public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getDefaultRequestProperty>
		<setContentHandlerFactory public="1" set="method" static="1">
			<f a="param1">
				<c path="java.net.ContentHandlerFactory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setContentHandlerFactory>
		<guessContentTypeFromName public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</guessContentTypeFromName>
		<guessContentTypeFromStream public="1" set="method" static="1">
			<f a="param1">
				<c path="java.io.InputStream"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</guessContentTypeFromStream>
		<connect public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</connect>
		<setConnectTimeout public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setConnectTimeout>
		<getConnectTimeout public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getConnectTimeout>
		<setReadTimeout public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setReadTimeout>
		<getReadTimeout public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getReadTimeout>
		<getURL public="1" set="method">
			<f a=""><c path="java.net.URL"/></f>
			<meta><m n=":overload"/></meta>
		</getURL>
		<getContentLength public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getContentLength>
		<getContentLengthLong public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getContentLengthLong>
		<getContentType public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getContentType>
		<getContentEncoding public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getContentEncoding>
		<getExpiration public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getExpiration>
		<getDate public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getDate>
		<getLastModified public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getLastModified>
		<getHeaderField public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getHeaderField public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getHeaderField></overloads>
		</getHeaderField>
		<getHeaderFields public="1" set="method">
			<f a=""><c path="java.util.Map">
	<c path="String"/>
	<c path="java.util.List"><c path="String"/></c>
</c></f>
			<meta><m n=":overload"/></meta>
		</getHeaderFields>
		<getHeaderFieldInt public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getHeaderFieldInt>
		<getHeaderFieldLong public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getHeaderFieldLong>
		<getHeaderFieldDate public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getHeaderFieldDate>
		<getHeaderFieldKey public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getHeaderFieldKey>
		<getContent public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getContent public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="java.lang.Class"><d/></c></c>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</getContent></overloads>
		</getContent>
		<getPermission public="1" set="method">
			<f a=""><c path="java.security.Permission"/></f>
			<meta><m n=":overload"/></meta>
		</getPermission>
		<getInputStream public="1" set="method">
			<f a=""><c path="java.io.InputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getInputStream>
		<getOutputStream public="1" set="method">
			<f a=""><c path="java.io.OutputStream"/></f>
			<meta><m n=":overload"/></meta>
		</getOutputStream>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<setDoInput public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDoInput>
		<getDoInput public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getDoInput>
		<setDoOutput public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDoOutput>
		<getDoOutput public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getDoOutput>
		<setAllowUserInteraction public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setAllowUserInteraction>
		<getAllowUserInteraction public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getAllowUserInteraction>
		<setUseCaches public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setUseCaches>
		<getUseCaches public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getUseCaches>
		<setIfModifiedSince public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setIfModifiedSince>
		<getIfModifiedSince public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getIfModifiedSince>
		<getDefaultUseCaches public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultUseCaches>
		<setDefaultUseCaches public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setDefaultUseCaches>
		<setRequestProperty public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setRequestProperty>
		<addRequestProperty public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</addRequestProperty>
		<getRequestProperty public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getRequestProperty>
		<getRequestProperties public="1" set="method">
			<f a=""><c path="java.util.Map">
	<c path="String"/>
	<c path="java.util.List"><c path="String"/></c>
</c></f>
			<meta><m n=":overload"/></meta>
		</getRequestProperties>
		<connected><x path="Bool"/></connected>
		<ifModifiedSince><c path="haxe.Int64"/></ifModifiedSince>
		<useCaches><x path="Bool"/></useCaches>
		<allowUserInteraction><x path="Bool"/></allowUserInteraction>
		<doOutput><x path="Bool"/></doOutput>
		<doInput><x path="Bool"/></doInput>
		<url><c path="java.net.URL"/></url>
		<new set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.URLConnection"</e></m>
		</meta>
	</class>
	<class path="java.net.URLStreamHandler" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URLStreamHandler.class" extern="1">
		<openConnection set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<c path="java.net.URLConnection"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><openConnection set="method">
	<f a="param1:param2">
		<c path="java.net.URL"/>
		<c path="java.net.Proxy"/>
		<c path="java.net.URLConnection"/>
	</f>
	<meta><m n=":overload"/></meta>
</openConnection></overloads>
		</openConnection>
		<parseURL set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.net.URL"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</parseURL>
		<getDefaultPort set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getDefaultPort>
		<equals set="method">
			<f a="param1:param2">
				<c path="java.net.URL"/>
				<c path="java.net.URL"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<sameFile set="method">
			<f a="param1:param2">
				<c path="java.net.URL"/>
				<c path="java.net.URL"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</sameFile>
		<getHostAddress set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<c path="java.net.InetAddress"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getHostAddress>
		<hostsEqual set="method">
			<f a="param1:param2">
				<c path="java.net.URL"/>
				<c path="java.net.URL"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</hostsEqual>
		<toExternalForm set="method">
			<f a="param1">
				<c path="java.net.URL"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toExternalForm>
		<setURL set="method">
			<f a="param1:param2:param3:param4:param5:param6:param7:param8:param9">
				<c path="java.net.URL"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setURL set="method">
	<f a="param1:param2:param3:param4:param5:param6">
		<c path="java.net.URL"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":deprecated"/>
	</meta>
</setURL></overloads>
		</setURL>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.URLStreamHandler"</e></m>
		</meta>
	</class>
	<class path="java.net.URLStreamHandlerFactory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/net/URLStreamHandlerFactory.class" extern="1" interface="1">
		<createURLStreamHandler public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URLStreamHandler"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createURLStreamHandler>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.net.URLStreamHandlerFactory"</e></m>
		</meta>
	</class>
	<class path="java.nio.Buffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/Buffer.class" extern="1">
		<capacity public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</capacity>
		<position public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><position public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.nio.Buffer"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</position></overloads>
		</position>
		<limit public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><limit public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.nio.Buffer"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</limit></overloads>
		</limit>
		<mark public="1" set="method">
			<f a=""><c path="java.nio.Buffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</mark>
		<reset public="1" set="method">
			<f a=""><c path="java.nio.Buffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</reset>
		<clear public="1" set="method">
			<f a=""><c path="java.nio.Buffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</clear>
		<flip public="1" set="method">
			<f a=""><c path="java.nio.Buffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</flip>
		<rewind public="1" set="method">
			<f a=""><c path="java.nio.Buffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</rewind>
		<remaining public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</remaining>
		<hasRemaining public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasRemaining>
		<isReadOnly public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isReadOnly>
		<hasArray public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasArray>
		<array public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</array>
		<arrayOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</arrayOffset>
		<isDirect public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.Buffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.ByteBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/ByteBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.ByteBuffer"/></implements>
		<allocateDirect public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocateDirect>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><t path="java.types.Int8"/></c>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.ByteBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.ByteBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.ByteBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><t path="java.types.Int8"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<t path="java.types.Int8"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<t path="java.types.Int8"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.ByteBuffer"/>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Int8"/>
						<c path="java.nio.ByteBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.ByteBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><order public="1" set="method">
	<f a="param1">
		<c path="java.nio.ByteOrder"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</order></overloads>
		</order>
		<getChar public="1" set="method">
			<f a=""><t path="java.types.Char16"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getChar public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<t path="java.types.Char16"/>
	</f>
	<meta><m n=":overload"/></meta>
</getChar></overloads>
		</getChar>
		<putChar public="1" set="method">
			<f a="param1">
				<t path="java.types.Char16"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putChar public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<t path="java.types.Char16"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putChar></overloads>
		</putChar>
		<asCharBuffer public="1" set="method">
			<f a=""><c path="java.nio.CharBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asCharBuffer>
		<getShort public="1" set="method">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getShort public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<t path="java.types.Int16"/>
	</f>
	<meta><m n=":overload"/></meta>
</getShort></overloads>
		</getShort>
		<putShort public="1" set="method">
			<f a="param1">
				<t path="java.types.Int16"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putShort public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<t path="java.types.Int16"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putShort></overloads>
		</putShort>
		<asShortBuffer public="1" set="method">
			<f a=""><c path="java.nio.ShortBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asShortBuffer>
		<getInt public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getInt public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</getInt></overloads>
		</getInt>
		<putInt public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putInt public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Int"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putInt></overloads>
		</putInt>
		<asIntBuffer public="1" set="method">
			<f a=""><c path="java.nio.IntBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asIntBuffer>
		<getLong public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getLong public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="haxe.Int64"/>
	</f>
	<meta><m n=":overload"/></meta>
</getLong></overloads>
		</getLong>
		<putLong public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putLong public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<c path="haxe.Int64"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putLong></overloads>
		</putLong>
		<asLongBuffer public="1" set="method">
			<f a=""><c path="java.nio.LongBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asLongBuffer>
		<getFloat public="1" set="method">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getFloat public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Single"/>
	</f>
	<meta><m n=":overload"/></meta>
</getFloat></overloads>
		</getFloat>
		<putFloat public="1" set="method">
			<f a="param1">
				<x path="Single"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putFloat public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Single"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putFloat></overloads>
		</putFloat>
		<asFloatBuffer public="1" set="method">
			<f a=""><c path="java.nio.FloatBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asFloatBuffer>
		<getDouble public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getDouble public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Float"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDouble></overloads>
		</getDouble>
		<putDouble public="1" set="method">
			<f a="param1">
				<x path="Float"/>
				<c path="java.nio.ByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><putDouble public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<x path="Float"/>
		<c path="java.nio.ByteBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</putDouble></overloads>
		</putDouble>
		<asDoubleBuffer public="1" set="method">
			<f a=""><c path="java.nio.DoubleBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asDoubleBuffer>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.ByteBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.ByteOrder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/ByteOrder.class" extern="1">
		<nativeOrder public="1" set="method" static="1">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</nativeOrder>
		<LITTLE_ENDIAN public="1" static="1">
			<c path="java.nio.ByteOrder"/>
			<meta><m n=":final"/></meta>
		</LITTLE_ENDIAN>
		<BIG_ENDIAN public="1" static="1">
			<c path="java.nio.ByteOrder"/>
			<meta><m n=":final"/></meta>
		</BIG_ENDIAN>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.ByteOrder"</e></m>
		</meta>
	</class>
	<class path="java.nio.CharBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/CharBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Readable"/>
		<implements path="java.lang.CharSequence"/>
		<implements path="java.lang.Appendable"/>
		<implements path="java.lang.Comparable"><c path="java.nio.CharBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.CharBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.CharBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<wrap public="1" set="method">
					<f a="param1">
						<c path="java.lang.CharSequence"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</wrap>
				<wrap public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</wrap>
				<wrap public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</wrap>
			</overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><t path="java.types.Char16"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.CharBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.CharBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.CharBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.CharBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><t path="java.types.Char16"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<t path="java.types.Char16"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<t path="java.types.Char16"/>
				<c path="java.nio.CharBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Char16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.CharBuffer"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Char16"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.CharBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.CharBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<length public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</length>
		<charAt public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<t path="java.types.Char16"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</charAt>
		<subSequence public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.CharBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</subSequence>
		<append public="1" set="method">
			<f a="param1">
				<c path="java.lang.CharSequence"/>
				<c path="java.nio.CharBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<append public="1" set="method">
					<f a="param1">
						<t path="java.types.Char16"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
				<append public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.lang.CharSequence"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.CharBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</append>
			</overloads>
		</append>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.CharBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.DoubleBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/DoubleBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.DoubleBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.DoubleBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.DoubleBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><x path="Float"/></c>
		<c path="java.nio.DoubleBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><x path="Float"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.DoubleBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.DoubleBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.DoubleBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Float"/></c>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Float"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Float"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<x path="Float"/>
				<c path="java.nio.DoubleBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Float"/></c>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Float"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.DoubleBuffer"/>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Float"/>
						<c path="java.nio.DoubleBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.DoubleBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.DoubleBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.DoubleBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.FloatBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/FloatBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.FloatBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.FloatBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><x path="Single"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.FloatBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><x path="Single"/></c>
		<c path="java.nio.FloatBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><x path="Single"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.FloatBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.FloatBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.FloatBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><x path="Single"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Single"/></c>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Single"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Single"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<x path="Single"/>
				<c path="java.nio.FloatBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Single"/></c>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Single"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.FloatBuffer"/>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Single"/>
						<c path="java.nio.FloatBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.FloatBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.FloatBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.FloatBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.IntBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/IntBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.IntBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.IntBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.IntBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><x path="Int"/></c>
		<c path="java.nio.IntBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><x path="Int"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.IntBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.IntBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.IntBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Int"/></c>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.IntBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><x path="Int"/></c>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.IntBuffer"/>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.IntBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.IntBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.IntBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.IntBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.LongBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/LongBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.LongBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.LongBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><c path="haxe.Int64"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.LongBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="haxe.Int64"/></c>
		<c path="java.nio.LongBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><c path="haxe.Int64"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.LongBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.LongBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.LongBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="haxe.Int64"/></c>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="haxe.Int64"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.LongBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="haxe.Int64"/></c>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="haxe.Int64"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.LongBuffer"/>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<c path="haxe.Int64"/>
						<c path="java.nio.LongBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.LongBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.LongBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.LongBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.MappedByteBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/MappedByteBuffer.class" extern="1">
		<extends path="java.nio.ByteBuffer"/>
		<isLoaded public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isLoaded>
		<load public="1" set="method">
			<f a=""><c path="java.nio.MappedByteBuffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</load>
		<force public="1" set="method">
			<f a=""><c path="java.nio.MappedByteBuffer"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</force>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.MappedByteBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.ShortBuffer" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/ShortBuffer.class" extern="1">
		<extends path="java.nio.Buffer"/>
		<implements path="java.lang.Comparable"><c path="java.nio.ShortBuffer"/></implements>
		<allocate public="1" set="method" static="1">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.ShortBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</allocate>
		<wrap public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><t path="java.types.Int16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.ShortBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><wrap public="1" set="method">
	<f a="param1">
		<c path="java.NativeArray"><t path="java.types.Int16"/></c>
		<c path="java.nio.ShortBuffer"/>
	</f>
	<meta><m n=":overload"/></meta>
</wrap></overloads>
		</wrap>
		<array public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int16"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</array>
		<isDirect public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirect>
		<arrayOffset public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</arrayOffset>
		<hasArray public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</hasArray>
		<slice public="1" set="method">
			<f a=""><c path="java.nio.ShortBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</slice>
		<duplicate public="1" set="method">
			<f a=""><c path="java.nio.ShortBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</duplicate>
		<asReadOnlyBuffer public="1" set="method">
			<f a=""><c path="java.nio.ShortBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</asReadOnlyBuffer>
		<get public="1" set="method">
			<f a=""><t path="java.types.Int16"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<get public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int16"/></c>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
				<get public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<t path="java.types.Int16"/>
					</f>
					<meta><m n=":overload"/></meta>
				</get>
			</overloads>
		</get>
		<put public="1" set="method">
			<f a="param1">
				<t path="java.types.Int16"/>
				<c path="java.nio.ShortBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><t path="java.types.Int16"/></c>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><t path="java.types.Int16"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1">
						<c path="java.nio.ShortBuffer"/>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
				<put public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<t path="java.types.Int16"/>
						<c path="java.nio.ShortBuffer"/>
					</f>
					<meta><m n=":overload"/></meta>
				</put>
			</overloads>
		</put>
		<compact public="1" set="method">
			<f a=""><c path="java.nio.ShortBuffer"/></f>
			<meta><m n=":overload"/></meta>
		</compact>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.ShortBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<order public="1" set="method">
			<f a=""><c path="java.nio.ByteOrder"/></f>
			<meta><m n=":overload"/></meta>
		</order>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.ShortBuffer"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.Channel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/Channel.class" extern="1" interface="1">
		<extends path="java.io.Closeable"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.Channel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.AsynchronousChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/AsynchronousChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.Channel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.AsynchronousChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.AsynchronousFileChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/AsynchronousFileChannel.class" extern="1">
		<implements path="java.nio.channels.AsynchronousChannel"/>
		<open public="1" set="method" static="1">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.file.Path"/>
				<c path="java.util.Set"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.util.concurrent.ExecutorService"/>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<c path="java.nio.channels.AsynchronousFileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><open public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.file.Path"/>
		<c path="java.NativeArray"><c path="java.nio.file.OpenOption"/></c>
		<c path="java.nio.channels.AsynchronousFileChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</open></overloads>
		</open>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<size public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<truncate public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.channels.AsynchronousFileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</truncate>
		<force public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</force>
		<lock public="1" params="A" set="method">
			<f a="param1:param2:param3:param4:param5">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
				<c path="lock.A"/>
				<c path="java.nio.channels.CompletionHandler">
					<c path="java.nio.channels.FileLock"/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<lock public="1" set="method">
					<f a=""><c path="java.util.concurrent.Future"><c path="java.nio.channels.FileLock"/></c></f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</lock>
				<lock public="1" set="method">
					<f a="param1:param2:param3">
						<c path="haxe.Int64"/>
						<c path="haxe.Int64"/>
						<x path="Bool"/>
						<c path="java.util.concurrent.Future"><c path="java.nio.channels.FileLock"/></c>
					</f>
					<meta><m n=":overload"/></meta>
				</lock>
				<lock public="1" params="A" set="method">
					<f a="param1:param2">
						<c path="lock.A"/>
						<c path="java.nio.channels.CompletionHandler">
							<c path="java.nio.channels.FileLock"/>
							<d/>
						</c>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</lock>
			</overloads>
		</lock>
		<tryLock public="1" set="method">
			<f a="param1:param2:param3">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
				<c path="java.nio.channels.FileLock"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><tryLock public="1" set="method">
	<f a=""><c path="java.nio.channels.FileLock"/></f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</tryLock></overloads>
		</tryLock>
		<read public="1" params="A" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.ByteBuffer"/>
				<c path="haxe.Int64"/>
				<c path="read.A"/>
				<c path="java.nio.channels.CompletionHandler">
					<t path="Null"><x path="Int"/></t>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><read public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.ByteBuffer"/>
		<c path="haxe.Int64"/>
		<c path="java.util.concurrent.Future"><t path="Null"><x path="Int"/></t></c>
	</f>
	<meta><m n=":overload"/></meta>
</read></overloads>
		</read>
		<write public="1" params="A" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.ByteBuffer"/>
				<c path="haxe.Int64"/>
				<c path="write.A"/>
				<c path="java.nio.channels.CompletionHandler">
					<t path="Null"><x path="Int"/></t>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><write public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.ByteBuffer"/>
		<c path="haxe.Int64"/>
		<c path="java.util.concurrent.Future"><t path="Null"><x path="Int"/></t></c>
	</f>
	<meta><m n=":overload"/></meta>
</write></overloads>
		</write>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.AsynchronousFileChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.ReadableByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/ReadableByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.Channel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.ReadableByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.WritableByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/WritableByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.Channel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</write>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.WritableByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.ByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/ByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.ReadableByteChannel"/>
		<extends path="java.nio.channels.WritableByteChannel"/>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</write>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.ByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.CompletionHandler" params="V:A" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/CompletionHandler.class" extern="1" interface="1">
		<completed public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.channels.CompletionHandler.V"/>
				<c path="java.nio.channels.CompletionHandler.A"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</completed>
		<failed public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.Throwable"/>
				<c path="java.nio.channels.CompletionHandler.A"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</failed>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.CompletionHandler"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.InterruptibleChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/InterruptibleChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.Channel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.InterruptibleChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.spi.AbstractInterruptibleChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/spi/AbstractInterruptibleChannel.class" extern="1">
		<implements path="java.nio.channels.Channel"/>
		<implements path="java.nio.channels.InterruptibleChannel"/>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</close>
		<implCloseChannel set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</implCloseChannel>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isOpen>
		<begin set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</begin>
		<end set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</end>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.spi.AbstractInterruptibleChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.SelectableChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/SelectableChannel.class" extern="1">
		<extends path="java.nio.channels.spi.AbstractInterruptibleChannel"/>
		<implements path="java.nio.channels.Channel"/>
		<provider public="1" set="method">
			<f a=""><c path="java.nio.channels.spi.SelectorProvider"/></f>
			<meta><m n=":overload"/></meta>
		</provider>
		<validOps public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</validOps>
		<isRegistered public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isRegistered>
		<keyFor public="1" set="method">
			<f a="param1">
				<c path="java.nio.channels.Selector"/>
				<c path="java.nio.channels.SelectionKey"/>
			</f>
			<meta><m n=":overload"/></meta>
		</keyFor>
		<register public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.channels.Selector"/>
				<x path="Int"/>
				<d/>
				<c path="java.nio.channels.SelectionKey"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><register public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.channels.Selector"/>
		<x path="Int"/>
		<c path="java.nio.channels.SelectionKey"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</register></overloads>
		</register>
		<configureBlocking public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<c path="java.nio.channels.SelectableChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</configureBlocking>
		<isBlocking public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isBlocking>
		<blockingLock public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</blockingLock>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.SelectableChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.spi.AbstractSelectableChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/spi/AbstractSelectableChannel.class" extern="1">
		<extends path="java.nio.channels.SelectableChannel"/>
		<implCloseChannel set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</implCloseChannel>
		<configureBlocking public="1" set="method" override="1">
			<f a="param1">
				<x path="Bool"/>
				<c path="java.nio.channels.SelectableChannel"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</configureBlocking>
		<blockingLock public="1" set="method" override="1">
			<f a=""><d/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</blockingLock>
		<isBlocking public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isBlocking>
		<register public="1" set="method" override="1">
			<f a="param1:param2:param3">
				<c path="java.nio.channels.Selector"/>
				<x path="Int"/>
				<d/>
				<c path="java.nio.channels.SelectionKey"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</register>
		<keyFor public="1" set="method" override="1">
			<f a="param1">
				<c path="java.nio.channels.Selector"/>
				<c path="java.nio.channels.SelectionKey"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</keyFor>
		<isRegistered public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isRegistered>
		<provider public="1" set="method" override="1">
			<f a=""><c path="java.nio.channels.spi.SelectorProvider"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</provider>
		<implCloseSelectableChannel set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</implCloseSelectableChannel>
		<implConfigureBlocking set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</implConfigureBlocking>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.spi.AbstractSelectableChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.ScatteringByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/ScatteringByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.ReadableByteChannel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.ScatteringByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.GatheringByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/GatheringByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.WritableByteChannel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.GatheringByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.NetworkChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/NetworkChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.Channel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.NetworkChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<setOption public="1" params="T" set="method">
			<f a="param1:param2">
				<c path="java.net.SocketOption"><c path="setOption.T"/></c>
				<c path="setOption.T"/>
				<c path="java.nio.channels.NetworkChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOption>
		<getOption public="1" params="T" set="method">
			<f a="param1">
				<c path="java.net.SocketOption"><c path="getOption.T"/></c>
				<c path="getOption.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<supportedOptions public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.net.SocketOption"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</supportedOptions>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.NetworkChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.MulticastChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/MulticastChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.NetworkChannel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.NetworkChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<setOption public="1" params="T" set="method">
			<f a="param1:param2">
				<c path="java.net.SocketOption"><c path="setOption.T"/></c>
				<c path="setOption.T"/>
				<c path="java.nio.channels.NetworkChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setOption>
		<getOption public="1" params="T" set="method">
			<f a="param1">
				<c path="java.net.SocketOption"><c path="getOption.T"/></c>
				<c path="getOption.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<supportedOptions public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.net.SocketOption"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</supportedOptions>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<join public="1" set="method">
			<f a="param1:param2">
				<c path="java.net.InetAddress"/>
				<c path="java.net.NetworkInterface"/>
				<c path="java.nio.channels.MembershipKey"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><join public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.net.InetAddress"/>
		<c path="java.net.NetworkInterface"/>
		<c path="java.net.InetAddress"/>
		<c path="java.nio.channels.MembershipKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</join></overloads>
		</join>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.MulticastChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.DatagramChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/DatagramChannel.class" extern="1">
		<extends path="java.nio.channels.spi.AbstractSelectableChannel"/>
		<implements path="java.nio.channels.ByteChannel"/>
		<implements path="java.nio.channels.ScatteringByteChannel"/>
		<implements path="java.nio.channels.GatheringByteChannel"/>
		<implements path="java.nio.channels.MulticastChannel"/>
		<open public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.DatagramChannel"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><open public="1" set="method">
	<f a="param1">
		<c path="java.net.ProtocolFamily"/>
		<c path="java.nio.channels.DatagramChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</open></overloads>
		</open>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<setOption public="1" params="T" set="method">
			<f a="param1:param2">
				<c path="java.net.SocketOption"><c path="setOption.T"/></c>
				<c path="setOption.T"/>
				<c path="java.nio.channels.DatagramChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setOption public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketOption"><d/></c>
		<d/>
		<c path="java.nio.channels.NetworkChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</setOption></overloads>
		</setOption>
		<getOption public="1" params="T" set="method">
			<f a="param1">
				<c path="java.net.SocketOption"><c path="getOption.T"/></c>
				<c path="getOption.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<supportedOptions public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.net.SocketOption"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</supportedOptions>
		<join public="1" set="method">
			<f a="param1:param2">
				<c path="java.net.InetAddress"/>
				<c path="java.net.NetworkInterface"/>
				<c path="java.nio.channels.MembershipKey"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><join public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.net.InetAddress"/>
		<c path="java.net.NetworkInterface"/>
		<c path="java.net.InetAddress"/>
		<c path="java.nio.channels.MembershipKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</join></overloads>
		</join>
		<validOps public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</validOps>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.DatagramChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<socket public="1" set="method">
			<f a=""><c path="java.net.DatagramSocket"/></f>
			<meta><m n=":overload"/></meta>
		</socket>
		<isConnected public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isConnected>
		<connect public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.DatagramChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</connect>
		<disconnect public="1" set="method">
			<f a=""><c path="java.nio.channels.DatagramChannel"/></f>
			<meta><m n=":overload"/></meta>
		</disconnect>
		<getRemoteAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getRemoteAddress>
		<receive public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<c path="java.net.SocketAddress"/>
			</f>
			<meta><m n=":overload"/></meta>
		</receive>
		<send public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.ByteBuffer"/>
				<c path="java.net.SocketAddress"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</send>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</read>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.DatagramChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.SeekableByteChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/SeekableByteChannel.class" extern="1" interface="1">
		<extends path="java.nio.channels.ByteChannel"/>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</read>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</write>
		<position public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><position public="1" set="method">
	<f a="param1">
		<c path="haxe.Int64"/>
		<c path="java.nio.channels.SeekableByteChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</position></overloads>
		</position>
		<size public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<truncate public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.channels.SeekableByteChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</truncate>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.SeekableByteChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.FileChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/FileChannel.class" extern="1">
		<extends path="java.nio.channels.spi.AbstractInterruptibleChannel"/>
		<implements path="java.nio.channels.SeekableByteChannel"/>
		<implements path="java.nio.channels.GatheringByteChannel"/>
		<implements path="java.nio.channels.ScatteringByteChannel"/>
		<open public="1" set="method" static="1">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.util.Set"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<c path="java.nio.channels.FileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><open public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.file.Path"/>
		<c path="java.NativeArray"><c path="java.nio.file.OpenOption"/></c>
		<c path="java.nio.channels.FileChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</open></overloads>
		</open>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1:param2">
						<c path="java.nio.ByteBuffer"/>
						<c path="haxe.Int64"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</read>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1:param2">
						<c path="java.nio.ByteBuffer"/>
						<c path="haxe.Int64"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<position public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><position public="1" set="method">
	<f a="param1">
		<c path="haxe.Int64"/>
		<c path="java.nio.channels.FileChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</position></overloads>
		</position>
		<size public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<truncate public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.channels.FileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</truncate>
		<force public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</force>
		<transferTo public="1" set="method">
			<f a="param1:param2:param3">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<c path="java.nio.channels.WritableByteChannel"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</transferTo>
		<transferFrom public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.channels.ReadableByteChannel"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</transferFrom>
		<map public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.channels.FileChannel_MapMode"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<c path="java.nio.MappedByteBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</map>
		<lock public="1" set="method">
			<f a="param1:param2:param3">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
				<c path="java.nio.channels.FileLock"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><lock public="1" set="method">
	<f a=""><c path="java.nio.channels.FileLock"/></f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</lock></overloads>
		</lock>
		<tryLock public="1" set="method">
			<f a="param1:param2:param3">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
				<c path="java.nio.channels.FileLock"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><tryLock public="1" set="method">
	<f a=""><c path="java.nio.channels.FileLock"/></f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</tryLock></overloads>
		</tryLock>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.FileChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.FileChannel_MapMode" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/FileChannel$MapMode.class" module="java.nio.channels.FileChannel" extern="1">
		<PRIVATE public="1" static="1">
			<c path="java.nio.channels.FileChannel_MapMode"/>
			<meta><m n=":final"/></meta>
		</PRIVATE>
		<READ_WRITE public="1" static="1">
			<c path="java.nio.channels.FileChannel_MapMode"/>
			<meta><m n=":final"/></meta>
		</READ_WRITE>
		<READ_ONLY public="1" static="1">
			<c path="java.nio.channels.FileChannel_MapMode"/>
			<meta><m n=":final"/></meta>
		</READ_ONLY>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.FileChannel$MapMode"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.FileLock" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/FileLock.class" extern="1">
		<implements path="java.lang.AutoCloseable"/>
		<channel public="1" set="method">
			<f a=""><c path="java.nio.channels.FileChannel"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</channel>
		<acquiredBy public="1" set="method">
			<f a=""><c path="java.nio.channels.Channel"/></f>
			<meta><m n=":overload"/></meta>
		</acquiredBy>
		<position public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</position>
		<size public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</size>
		<isShared public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isShared>
		<overlaps public="1" set="method">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</overlaps>
		<isValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isValid>
		<release public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</release>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</close>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</toString>
		<new set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.channels.FileChannel"/>
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new set="method">
	<f a="param1:param2:param3:param4">
		<c path="java.nio.channels.AsynchronousFileChannel"/>
		<c path="haxe.Int64"/>
		<c path="haxe.Int64"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.FileLock"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.MembershipKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/MembershipKey.class" extern="1">
		<isValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isValid>
		<drop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</drop>
		<block public="1" set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<c path="java.nio.channels.MembershipKey"/>
			</f>
			<meta><m n=":overload"/></meta>
		</block>
		<unblock public="1" set="method">
			<f a="param1">
				<c path="java.net.InetAddress"/>
				<c path="java.nio.channels.MembershipKey"/>
			</f>
			<meta><m n=":overload"/></meta>
		</unblock>
		<channel public="1" set="method">
			<f a=""><c path="java.nio.channels.MulticastChannel"/></f>
			<meta><m n=":overload"/></meta>
		</channel>
		<group public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</group>
		<networkInterface public="1" set="method">
			<f a=""><c path="java.net.NetworkInterface"/></f>
			<meta><m n=":overload"/></meta>
		</networkInterface>
		<sourceAddress public="1" set="method">
			<f a=""><c path="java.net.InetAddress"/></f>
			<meta><m n=":overload"/></meta>
		</sourceAddress>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.MembershipKey"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.Pipe" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/Pipe.class" extern="1">
		<open public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.Pipe"/></f>
			<meta><m n=":overload"/></meta>
		</open>
		<source public="1" set="method">
			<f a=""><c path="java.nio.channels.Pipe_SourceChannel"/></f>
			<meta><m n=":overload"/></meta>
		</source>
		<sink public="1" set="method">
			<f a=""><c path="java.nio.channels.Pipe_SinkChannel"/></f>
			<meta><m n=":overload"/></meta>
		</sink>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.Pipe"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.Pipe_SourceChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/Pipe$SourceChannel.class" module="java.nio.channels.Pipe" extern="1">
		<extends path="java.nio.channels.spi.AbstractSelectableChannel"/>
		<implements path="java.nio.channels.ReadableByteChannel"/>
		<implements path="java.nio.channels.ScatteringByteChannel"/>
		<read public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.nio.ByteBuffer"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<validOps public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</validOps>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.Pipe$SourceChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.Pipe_SinkChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/Pipe$SinkChannel.class" module="java.nio.channels.Pipe" extern="1">
		<extends path="java.nio.channels.spi.AbstractSelectableChannel"/>
		<implements path="java.nio.channels.WritableByteChannel"/>
		<implements path="java.nio.channels.GatheringByteChannel"/>
		<write public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.nio.ByteBuffer"/>
						<x path="Int"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<validOps public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</validOps>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.Pipe$SinkChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.SelectionKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/SelectionKey.class" extern="1">
		<OP_ACCEPT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</OP_ACCEPT>
		<OP_CONNECT public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</OP_CONNECT>
		<OP_WRITE public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</OP_WRITE>
		<OP_READ public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":final"/></meta>
		</OP_READ>
		<channel public="1" set="method">
			<f a=""><c path="java.nio.channels.SelectableChannel"/></f>
			<meta><m n=":overload"/></meta>
		</channel>
		<selector public="1" set="method">
			<f a=""><c path="java.nio.channels.Selector"/></f>
			<meta><m n=":overload"/></meta>
		</selector>
		<isValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isValid>
		<cancel public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</cancel>
		<interestOps public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><interestOps public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.nio.channels.SelectionKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</interestOps></overloads>
		</interestOps>
		<readyOps public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</readyOps>
		<isReadable public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isReadable>
		<isWritable public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isWritable>
		<isConnectable public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isConnectable>
		<isAcceptable public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isAcceptable>
		<attach public="1" set="method">
			<f a="param1">
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</attach>
		<attachment public="1" set="method">
			<f a=""><d/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</attachment>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.SelectionKey"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.Selector" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/Selector.class" extern="1">
		<implements path="java.io.Closeable"/>
		<open public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.Selector"/></f>
			<meta><m n=":overload"/></meta>
		</open>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<provider public="1" set="method">
			<f a=""><c path="java.nio.channels.spi.SelectorProvider"/></f>
			<meta><m n=":overload"/></meta>
		</provider>
		<keys public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.nio.channels.SelectionKey"/></c></f>
			<meta><m n=":overload"/></meta>
		</keys>
		<selectedKeys public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.nio.channels.SelectionKey"/></c></f>
			<meta><m n=":overload"/></meta>
		</selectedKeys>
		<selectNow public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</selectNow>
		<select public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><select public="1" set="method">
	<f a=""><x path="Int"/></f>
	<meta><m n=":overload"/></meta>
</select></overloads>
		</select>
		<wakeup public="1" set="method">
			<f a=""><c path="java.nio.channels.Selector"/></f>
			<meta><m n=":overload"/></meta>
		</wakeup>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.Selector"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.ServerSocketChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/ServerSocketChannel.class" extern="1">
		<extends path="java.nio.channels.spi.AbstractSelectableChannel"/>
		<implements path="java.nio.channels.NetworkChannel"/>
		<open public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.ServerSocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</open>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<setOption public="1" params="T" set="method">
			<f a="param1:param2">
				<c path="java.net.SocketOption"><c path="setOption.T"/></c>
				<c path="setOption.T"/>
				<c path="java.nio.channels.ServerSocketChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setOption public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketOption"><d/></c>
		<d/>
		<c path="java.nio.channels.NetworkChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</setOption></overloads>
		</setOption>
		<getOption public="1" params="T" set="method">
			<f a="param1">
				<c path="java.net.SocketOption"><c path="getOption.T"/></c>
				<c path="getOption.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<supportedOptions public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.net.SocketOption"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</supportedOptions>
		<validOps public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</validOps>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.ServerSocketChannel"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><bind public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketAddress"/>
		<x path="Int"/>
		<c path="java.nio.channels.ServerSocketChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</bind></overloads>
		</bind>
		<socket public="1" set="method">
			<f a=""><c path="java.net.ServerSocket"/></f>
			<meta><m n=":overload"/></meta>
		</socket>
		<accept public="1" set="method">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</accept>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.ServerSocketChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.SocketChannel" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/SocketChannel.class" extern="1">
		<extends path="java.nio.channels.spi.AbstractSelectableChannel"/>
		<implements path="java.nio.channels.ByteChannel"/>
		<implements path="java.nio.channels.ScatteringByteChannel"/>
		<implements path="java.nio.channels.GatheringByteChannel"/>
		<implements path="java.nio.channels.NetworkChannel"/>
		<open public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><open public="1" set="method">
	<f a="param1">
		<c path="java.net.SocketAddress"/>
		<c path="java.nio.channels.SocketChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</open></overloads>
		</open>
		<getLocalAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getLocalAddress>
		<setOption public="1" params="T" set="method">
			<f a="param1:param2">
				<c path="java.net.SocketOption"><c path="setOption.T"/></c>
				<c path="setOption.T"/>
				<c path="java.nio.channels.SocketChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setOption public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.SocketOption"><d/></c>
		<d/>
		<c path="java.nio.channels.NetworkChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</setOption></overloads>
		</setOption>
		<getOption public="1" params="T" set="method">
			<f a="param1">
				<c path="java.net.SocketOption"><c path="getOption.T"/></c>
				<c path="getOption.T"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getOption>
		<supportedOptions public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.net.SocketOption"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</supportedOptions>
		<validOps public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</validOps>
		<bind public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<c path="java.nio.channels.SocketChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</bind>
		<shutdownInput public="1" set="method">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownInput>
		<shutdownOutput public="1" set="method">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</shutdownOutput>
		<socket public="1" set="method">
			<f a=""><c path="java.net.Socket"/></f>
			<meta><m n=":overload"/></meta>
		</socket>
		<isConnected public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isConnected>
		<isConnectionPending public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isConnectionPending>
		<connect public="1" set="method">
			<f a="param1">
				<c path="java.net.SocketAddress"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</connect>
		<finishConnect public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</finishConnect>
		<getRemoteAddress public="1" set="method">
			<f a=""><c path="java.net.SocketAddress"/></f>
			<meta><m n=":overload"/></meta>
		</getRemoteAddress>
		<read public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<read public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</read>
				<read public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</read>
			</overloads>
		</read>
		<write public="1" set="method">
			<f a="param1">
				<c path="java.nio.ByteBuffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<write public="1" set="method">
					<f a="param1">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<c path="haxe.Int64"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</write>
				<write public="1" set="method">
					<f a="param1:param2:param3">
						<c path="java.NativeArray"><c path="java.nio.ByteBuffer"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="haxe.Int64"/>
					</f>
					<meta><m n=":overload"/></meta>
				</write>
			</overloads>
		</write>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.SocketChannel"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.spi.AbstractSelectionKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/spi/AbstractSelectionKey.class" extern="1">
		<extends path="java.nio.channels.SelectionKey"/>
		<cancel public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</cancel>
		<isValid public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isValid>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.spi.AbstractSelectionKey"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.spi.AbstractSelector" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/spi/AbstractSelector.class" extern="1">
		<extends path="java.nio.channels.Selector"/>
		<provider public="1" set="method" override="1">
			<f a=""><c path="java.nio.channels.spi.SelectorProvider"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</provider>
		<isOpen public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</isOpen>
		<close public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</close>
		<implCloseSelector set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</implCloseSelector>
		<cancelledKeys set="method">
			<f a=""><c path="java.util.Set"><c path="java.nio.channels.SelectionKey"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</cancelledKeys>
		<register set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.channels.spi.AbstractSelectableChannel"/>
				<x path="Int"/>
				<d/>
				<c path="java.nio.channels.SelectionKey"/>
			</f>
			<meta><m n=":overload"/></meta>
		</register>
		<deregister set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.AbstractSelectionKey"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</deregister>
		<begin set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</begin>
		<end set="method">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</end>
		<new set="method">
			<f a="param1">
				<c path="java.nio.channels.spi.SelectorProvider"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.spi.AbstractSelector"</e></m>
		</meta>
	</class>
	<class path="java.nio.channels.spi.SelectorProvider" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/channels/spi/SelectorProvider.class" extern="1">
		<provider public="1" set="method" static="1">
			<f a=""><c path="java.nio.channels.spi.SelectorProvider"/></f>
			<meta><m n=":overload"/></meta>
		</provider>
		<openDatagramChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.DatagramChannel"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><openDatagramChannel public="1" set="method">
	<f a="param1">
		<c path="java.net.ProtocolFamily"/>
		<c path="java.nio.channels.DatagramChannel"/>
	</f>
	<meta><m n=":overload"/></meta>
</openDatagramChannel></overloads>
		</openDatagramChannel>
		<openPipe public="1" set="method">
			<f a=""><c path="java.nio.channels.Pipe"/></f>
			<meta><m n=":overload"/></meta>
		</openPipe>
		<openSelector public="1" set="method">
			<f a=""><c path="java.nio.channels.spi.AbstractSelector"/></f>
			<meta><m n=":overload"/></meta>
		</openSelector>
		<openServerSocketChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.ServerSocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</openServerSocketChannel>
		<openSocketChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.SocketChannel"/></f>
			<meta><m n=":overload"/></meta>
		</openSocketChannel>
		<inheritedChannel public="1" set="method">
			<f a=""><c path="java.nio.channels.Channel"/></f>
			<meta><m n=":overload"/></meta>
		</inheritedChannel>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.channels.spi.SelectorProvider"</e></m>
		</meta>
	</class>
	<enum path="java.nio.file.AccessMode" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/AccessMode.class"><meta><m n=":native"><e>"java.nio.file.AccessMode"</e></m></meta></enum>
	<class path="java.nio.file.CopyOption" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/CopyOption.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.nio.file.CopyOption"</e></m>
</meta></class>
	<class path="java.nio.file.DirectoryStream" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/DirectoryStream.class" extern="1" interface="1">
		<extends path="java.lang.Iterable"><c path="java.nio.file.DirectoryStream.T"/></extends>
		<extends path="java.io.Closeable"/>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.nio.file.DirectoryStream.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.DirectoryStream"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.DirectoryStream_Filter" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/DirectoryStream$Filter.class" module="java.nio.file.DirectoryStream" extern="1" interface="1">
		<accept public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.DirectoryStream_Filter.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</accept>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.DirectoryStream$Filter"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.FileStore" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/FileStore.class" extern="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<type public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</type>
		<isReadOnly public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isReadOnly>
		<getTotalSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getTotalSpace>
		<getUsableSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getUsableSpace>
		<getUnallocatedSpace public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getUnallocatedSpace>
		<supportsFileAttributeView public="1" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.nio.file.attribute.FileAttributeView"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><supportsFileAttributeView public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</supportsFileAttributeView></overloads>
		</supportsFileAttributeView>
		<getFileStoreAttributeView public="1" params="V" set="method">
			<f a="param1">
				<c path="java.lang.Class"><c path="getFileStoreAttributeView.V"/></c>
				<c path="getFileStoreAttributeView.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFileStoreAttributeView>
		<getAttribute public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</getAttribute>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.FileStore"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.FileSystem" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/FileSystem.class" extern="1">
		<implements path="java.io.Closeable"/>
		<provider public="1" set="method">
			<f a=""><c path="java.nio.file.spi.FileSystemProvider"/></f>
			<meta><m n=":overload"/></meta>
		</provider>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<isOpen public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOpen>
		<isReadOnly public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isReadOnly>
		<getSeparator public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getSeparator>
		<getRootDirectories public="1" set="method">
			<f a=""><c path="java.lang.Iterable"><c path="java.nio.file.Path"/></c></f>
			<meta><m n=":overload"/></meta>
		</getRootDirectories>
		<getFileStores public="1" set="method">
			<f a=""><c path="java.lang.Iterable"><c path="java.nio.file.FileStore"/></c></f>
			<meta><m n=":overload"/></meta>
		</getFileStores>
		<supportedFileAttributeViews public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</supportedFileAttributeViews>
		<getPath public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><c path="String"/></c>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPath>
		<getPathMatcher public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.nio.file.PathMatcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPathMatcher>
		<getUserPrincipalLookupService public="1" set="method">
			<f a=""><c path="java.nio.file.attribute.UserPrincipalLookupService"/></f>
			<meta><m n=":overload"/></meta>
		</getUserPrincipalLookupService>
		<newWatchService public="1" set="method">
			<f a=""><c path="java.nio.file.WatchService"/></f>
			<meta><m n=":overload"/></meta>
		</newWatchService>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.FileSystem"</e></m>
		</meta>
	</class>
	<enum path="java.nio.file.LinkOption" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/LinkOption.class"><meta><m n=":native"><e>"java.nio.file.LinkOption"</e></m></meta></enum>
	<class path="java.nio.file.OpenOption" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/OpenOption.class" extern="1" interface="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.nio.file.OpenOption"</e></m>
</meta></class>
	<class path="java.nio.file.Watchable" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/Watchable.class" extern="1" interface="1">
		<register public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.WatchService"/>
				<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Kind"><d/></c></c>
				<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Modifier"/></c>
				<c path="java.nio.file.WatchKey"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><register public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.file.WatchService"/>
		<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Kind"><d/></c></c>
		<c path="java.nio.file.WatchKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</register></overloads>
		</register>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.Watchable"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.Path" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/Path.class" extern="1" interface="1">
		<extends path="java.nio.file.Watchable"/>
		<extends path="java.lang.Iterable"><c path="java.nio.file.Path"/></extends>
		<extends path="java.lang.Comparable"><c path="java.nio.file.Path"/></extends>
		<getFileSystem public="1" set="method">
			<f a=""><c path="java.nio.file.FileSystem"/></f>
			<meta><m n=":overload"/></meta>
		</getFileSystem>
		<isAbsolute public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isAbsolute>
		<getRoot public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</getRoot>
		<getFileName public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</getFileName>
		<getParent public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</getParent>
		<getNameCount public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</getNameCount>
		<getName public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getName>
		<subpath public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</subpath>
		<startsWith public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><startsWith public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</startsWith></overloads>
		</startsWith>
		<endsWith public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><endsWith public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</endsWith></overloads>
		</endsWith>
		<normalize public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</normalize>
		<resolve public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><resolve public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<c path="java.nio.file.Path"/>
	</f>
	<meta><m n=":overload"/></meta>
</resolve></overloads>
		</resolve>
		<resolveSibling public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><resolveSibling public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<c path="java.nio.file.Path"/>
	</f>
	<meta><m n=":overload"/></meta>
</resolveSibling></overloads>
		</resolveSibling>
		<relativize public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</relativize>
		<toUri public="1" set="method">
			<f a=""><c path="java.net.URI"/></f>
			<meta><m n=":overload"/></meta>
		</toUri>
		<toAbsolutePath public="1" set="method">
			<f a=""><c path="java.nio.file.Path"/></f>
			<meta><m n=":overload"/></meta>
		</toAbsolutePath>
		<toRealPath public="1" set="method">
			<f a="param1">
				<c path="java.NativeArray"><e path="java.nio.file.LinkOption"/></c>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toRealPath>
		<toFile public="1" set="method">
			<f a=""><c path="java.io.File"/></f>
			<meta><m n=":overload"/></meta>
		</toFile>
		<register public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.WatchService"/>
				<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Kind"><d/></c></c>
				<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Modifier"/></c>
				<c path="java.nio.file.WatchKey"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><register public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.file.WatchService"/>
		<c path="java.NativeArray"><c path="java.nio.file.WatchEvent_Kind"><d/></c></c>
		<c path="java.nio.file.WatchKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</register></overloads>
		</register>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.nio.file.Path"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</compareTo>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.Path"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.PathMatcher" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/PathMatcher.class" extern="1" interface="1">
		<matches public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</matches>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.PathMatcher"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.WatchEvent" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/WatchEvent.class" extern="1" interface="1">
		<kind public="1" set="method">
			<f a=""><c path="java.nio.file.WatchEvent_Kind"><c path="java.nio.file.WatchEvent.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</kind>
		<count public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</count>
		<context public="1" set="method">
			<f a=""><c path="java.nio.file.WatchEvent.T"/></f>
			<meta><m n=":overload"/></meta>
		</context>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.WatchEvent"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.WatchEvent_Kind" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/WatchEvent$Kind.class" module="java.nio.file.WatchEvent" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<type public="1" set="method">
			<f a=""><c path="java.lang.Class"><c path="java.nio.file.WatchEvent_Kind.T"/></c></f>
			<meta><m n=":overload"/></meta>
		</type>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.WatchEvent$Kind"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.WatchEvent_Modifier" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/WatchEvent$Modifier.class" module="java.nio.file.WatchEvent" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.WatchEvent$Modifier"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.WatchKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/WatchKey.class" extern="1" interface="1">
		<isValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isValid>
		<pollEvents public="1" set="method">
			<f a=""><c path="java.util.List"><c path="java.nio.file.WatchEvent"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</pollEvents>
		<reset public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</reset>
		<cancel public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</cancel>
		<watchable public="1" set="method">
			<f a=""><c path="java.nio.file.Watchable"/></f>
			<meta><m n=":overload"/></meta>
		</watchable>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.WatchKey"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.WatchService" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/WatchService.class" extern="1" interface="1">
		<extends path="java.io.Closeable"/>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</close>
		<poll public="1" set="method">
			<f a=""><c path="java.nio.file.WatchKey"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><poll public="1" set="method">
	<f a="param1:param2">
		<c path="haxe.Int64"/>
		<e path="java.util.concurrent.TimeUnit"/>
		<c path="java.nio.file.WatchKey"/>
	</f>
	<meta><m n=":overload"/></meta>
</poll></overloads>
		</poll>
		<take public="1" set="method">
			<f a=""><c path="java.nio.file.WatchKey"/></f>
			<meta><m n=":overload"/></meta>
		</take>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.WatchService"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.AttributeView" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/AttributeView.class" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.AttributeView"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.BasicFileAttributes" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/BasicFileAttributes.class" extern="1" interface="1">
		<lastModifiedTime public="1" set="method">
			<f a=""><c path="java.nio.file.attribute.FileTime"/></f>
			<meta><m n=":overload"/></meta>
		</lastModifiedTime>
		<lastAccessTime public="1" set="method">
			<f a=""><c path="java.nio.file.attribute.FileTime"/></f>
			<meta><m n=":overload"/></meta>
		</lastAccessTime>
		<creationTime public="1" set="method">
			<f a=""><c path="java.nio.file.attribute.FileTime"/></f>
			<meta><m n=":overload"/></meta>
		</creationTime>
		<isRegularFile public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isRegularFile>
		<isDirectory public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDirectory>
		<isSymbolicLink public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isSymbolicLink>
		<isOther public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isOther>
		<size public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<fileKey public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</fileKey>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.BasicFileAttributes"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileAttribute" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileAttribute.class" extern="1" interface="1">
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<value public="1" set="method">
			<f a=""><c path="java.nio.file.attribute.FileAttribute.T"/></f>
			<meta><m n=":overload"/></meta>
		</value>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.FileAttribute"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileAttributeView" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileAttributeView.class" extern="1" interface="1">
		<extends path="java.nio.file.attribute.AttributeView"/>
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.FileAttributeView"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileStoreAttributeView" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileStoreAttributeView.class" extern="1" interface="1">
		<extends path="java.nio.file.attribute.AttributeView"/>
		<name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</name>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.FileStoreAttributeView"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileTime" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileTime.class" extern="1">
		<implements path="java.lang.Comparable"><c path="java.nio.file.attribute.FileTime"/></implements>
		<from public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<e path="java.util.concurrent.TimeUnit"/>
				<c path="java.nio.file.attribute.FileTime"/>
			</f>
			<meta><m n=":overload"/></meta>
		</from>
		<fromMillis public="1" set="method" static="1">
			<f a="param1">
				<c path="haxe.Int64"/>
				<c path="java.nio.file.attribute.FileTime"/>
			</f>
			<meta><m n=":overload"/></meta>
		</fromMillis>
		<to public="1" set="method">
			<f a="param1">
				<e path="java.util.concurrent.TimeUnit"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</to>
		<toMillis public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</toMillis>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.attribute.FileTime"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.FileTime"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileTime_DaysAndNanos" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileTime$DaysAndNanos.class" module="java.nio.file.attribute.FileTime" extern="1">
		<implements path="java.lang.Comparable"><c path="java.nio.file.attribute.FileTime_DaysAndNanos"/></implements>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.attribute.FileTime_DaysAndNanos"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.FileTime$DaysAndNanos"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.FileTime_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/FileTime$1.class" module="java.nio.file.attribute.FileTime" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.nio.file.attribute.FileTime$1"</e></m>
</meta></class>
	<class path="java.security.Principal" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Principal.class" extern="1" interface="1">
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Principal"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.UserPrincipal" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/UserPrincipal.class" extern="1" interface="1">
		<extends path="java.security.Principal"/>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.UserPrincipal"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.GroupPrincipal" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/GroupPrincipal.class" extern="1" interface="1">
		<extends path="java.nio.file.attribute.UserPrincipal"/>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getName>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.GroupPrincipal"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.attribute.UserPrincipalLookupService" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/attribute/UserPrincipalLookupService.class" extern="1">
		<lookupPrincipalByName public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.nio.file.attribute.UserPrincipal"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lookupPrincipalByName>
		<lookupPrincipalByGroupName public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.nio.file.attribute.GroupPrincipal"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lookupPrincipalByGroupName>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.attribute.UserPrincipalLookupService"</e></m>
		</meta>
	</class>
	<class path="java.nio.file.spi.FileSystemProvider" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/nio/file/spi/FileSystemProvider.class" extern="1">
		<installedProviders public="1" set="method" static="1">
			<f a=""><c path="java.util.List"><c path="java.nio.file.spi.FileSystemProvider"/></c></f>
			<meta><m n=":overload"/></meta>
		</installedProviders>
		<getScheme public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getScheme>
		<newFileSystem public="1" set="method">
			<f a="param1:param2">
				<c path="java.net.URI"/>
				<c path="java.util.Map">
					<c path="String"/>
					<d/>
				</c>
				<c path="java.nio.file.FileSystem"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><newFileSystem public="1" set="method">
	<f a="param1:param2">
		<c path="java.nio.file.Path"/>
		<c path="java.util.Map">
			<c path="String"/>
			<d/>
		</c>
		<c path="java.nio.file.FileSystem"/>
	</f>
	<meta><m n=":overload"/></meta>
</newFileSystem></overloads>
		</newFileSystem>
		<getFileSystem public="1" set="method">
			<f a="param1">
				<c path="java.net.URI"/>
				<c path="java.nio.file.FileSystem"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFileSystem>
		<getPath public="1" set="method">
			<f a="param1">
				<c path="java.net.URI"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPath>
		<newInputStream public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.io.InputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newInputStream>
		<newOutputStream public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.io.OutputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newOutputStream>
		<newFileChannel public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.util.Set"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<c path="java.nio.channels.FileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newFileChannel>
		<newAsynchronousFileChannel public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.file.Path"/>
				<c path="java.util.Set"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.util.concurrent.ExecutorService"/>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<c path="java.nio.channels.AsynchronousFileChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newAsynchronousFileChannel>
		<newByteChannel public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.util.Set"><c path="java.nio.file.OpenOption"/></c>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<c path="java.nio.channels.SeekableByteChannel"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newByteChannel>
		<newDirectoryStream public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.DirectoryStream_Filter"><d/></c>
				<c path="java.nio.file.DirectoryStream"><c path="java.nio.file.Path"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</newDirectoryStream>
		<createDirectory public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createDirectory>
		<createSymbolicLink public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.attribute.FileAttribute"><d/></c></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createSymbolicLink>
		<createLink public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createLink>
		<delete public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</delete>
		<deleteIfExists public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</deleteIfExists>
		<readSymbolicLink public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
			</f>
			<meta><m n=":overload"/></meta>
		</readSymbolicLink>
		<copy public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.CopyOption"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</copy>
		<move public="1" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><c path="java.nio.file.CopyOption"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</move>
		<isSameFile public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isSameFile>
		<isHidden public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</isHidden>
		<getFileStore public="1" set="method">
			<f a="param1">
				<c path="java.nio.file.Path"/>
				<c path="java.nio.file.FileStore"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFileStore>
		<checkAccess public="1" set="method">
			<f a="param1:param2">
				<c path="java.nio.file.Path"/>
				<c path="java.NativeArray"><e path="java.nio.file.AccessMode"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkAccess>
		<getFileAttributeView public="1" params="V" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.lang.Class"><c path="getFileAttributeView.V"/></c>
				<c path="java.NativeArray"><e path="java.nio.file.LinkOption"/></c>
				<c path="getFileAttributeView.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFileAttributeView>
		<readAttributes public="1" params="A" set="method">
			<f a="param1:param2:param3">
				<c path="java.nio.file.Path"/>
				<c path="java.lang.Class"><c path="readAttributes.A"/></c>
				<c path="java.NativeArray"><e path="java.nio.file.LinkOption"/></c>
				<c path="readAttributes.A"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><readAttributes public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.nio.file.Path"/>
		<c path="String"/>
		<c path="java.NativeArray"><e path="java.nio.file.LinkOption"/></c>
		<c path="java.util.Map">
			<c path="String"/>
			<d/>
		</c>
	</f>
	<meta><m n=":overload"/></meta>
</readAttributes></overloads>
		</readAttributes>
		<setAttribute public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.nio.file.Path"/>
				<c path="String"/>
				<d/>
				<c path="java.NativeArray"><e path="java.nio.file.LinkOption"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setAttribute>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.nio.file.spi.FileSystemProvider"</e></m>
		</meta>
	</class>
	<class path="java.security.CodeSigner" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/CodeSigner.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getSignerCertPath public="1" set="method">
			<f a=""><c path="java.security.cert.CertPath"/></f>
			<meta><m n=":overload"/></meta>
		</getSignerCertPath>
		<getTimestamp public="1" set="method">
			<f a=""><c path="java.security.Timestamp"/></f>
			<meta><m n=":overload"/></meta>
		</getTimestamp>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.security.cert.CertPath"/>
				<c path="java.security.Timestamp"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.CodeSigner"</e></m>
		</meta>
	</class>
	<class path="java.security.CodeSource" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/CodeSource.class" extern="1">
		<implements path="java.io.Serializable"/>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<getLocation public="1" set="method">
			<f a=""><c path="java.net.URL"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getLocation>
		<getCertificates public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.security.cert.Certificate"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getCertificates>
		<getCodeSigners public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.security.CodeSigner"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getCodeSigners>
		<implies public="1" set="method">
			<f a="param1">
				<c path="java.security.CodeSource"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</implies>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.net.URL"/>
				<c path="java.NativeArray"><c path="java.security.cert.Certificate"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2">
		<c path="java.net.URL"/>
		<c path="java.NativeArray"><c path="java.security.CodeSigner"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.CodeSource"</e></m>
		</meta>
	</class>
	<class path="java.security.Guard" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Guard.class" extern="1" interface="1">
		<checkGuard public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkGuard>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Guard"</e></m>
		</meta>
	</class>
	<class path="java.security.Key" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Key.class" extern="1" interface="1">
		<extends path="java.io.Serializable"/>
		<getAlgorithm public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getAlgorithm>
		<getFormat public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getFormat>
		<getEncoded public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getEncoded>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Key"</e></m>
		</meta>
	</class>
	<class path="java.security.Key_Statics" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Key.class" module="java.security.Key" extern="1">
		<serialVersionUID public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</serialVersionUID>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Key"</e></m>
		</meta>
	</class>
	<class path="java.security.Permission" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Permission.class" extern="1">
		<implements path="java.security.Guard"/>
		<implements path="java.io.Serializable"/>
		<checkGuard public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</checkGuard>
		<implies public="1" set="method">
			<f a="param1">
				<c path="java.security.Permission"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</implies>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getName>
		<getActions public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getActions>
		<newPermissionCollection public="1" set="method">
			<f a=""><c path="java.security.PermissionCollection"/></f>
			<meta><m n=":overload"/></meta>
		</newPermissionCollection>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Permission"</e></m>
		</meta>
	</class>
	<class path="java.security.PermissionCollection" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/PermissionCollection.class" extern="1">
		<implements path="java.io.Serializable"/>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.security.Permission"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</add>
		<implies public="1" set="method">
			<f a="param1">
				<c path="java.security.Permission"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</implies>
		<elements public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="java.security.Permission"/></c></f>
			<meta><m n=":overload"/></meta>
		</elements>
		<setReadOnly public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</setReadOnly>
		<isReadOnly public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isReadOnly>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.PermissionCollection"</e></m>
		</meta>
	</class>
	<class path="java.security.ProtectionDomain" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/ProtectionDomain.class" extern="1">
		<getCodeSource public="1" set="method">
			<f a=""><c path="java.security.CodeSource"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getCodeSource>
		<getClassLoader public="1" set="method">
			<f a=""><c path="java.lang.ClassLoader"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getClassLoader>
		<getPrincipals public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.security.Principal"/></c></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getPrincipals>
		<getPermissions public="1" set="method">
			<f a=""><c path="java.security.PermissionCollection"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getPermissions>
		<implies public="1" set="method">
			<f a="param1">
				<c path="java.security.Permission"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</implies>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.security.CodeSource"/>
				<c path="java.security.PermissionCollection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2:param3:param4">
		<c path="java.security.CodeSource"/>
		<c path="java.security.PermissionCollection"/>
		<c path="java.lang.ClassLoader"/>
		<c path="java.NativeArray"><c path="java.security.Principal"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.ProtectionDomain"</e></m>
		</meta>
	</class>
	<class path="java.security.ProtectionDomain_Key" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/ProtectionDomain$Key.class" module="java.security.ProtectionDomain" extern="1"><meta>
	<m n=":final"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.security.ProtectionDomain$Key"</e></m>
</meta></class>
	<class path="java.security.PublicKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/PublicKey.class" extern="1" interface="1">
		<extends path="java.security.Key"/>
		<getAlgorithm public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getAlgorithm>
		<getFormat public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getFormat>
		<getEncoded public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getEncoded>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.PublicKey"</e></m>
		</meta>
	</class>
	<class path="java.security.PublicKey_Statics" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/PublicKey.class" module="java.security.PublicKey" extern="1">
		<serialVersionUID public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</serialVersionUID>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.PublicKey"</e></m>
		</meta>
	</class>
	<class path="java.security.Timestamp" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/Timestamp.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getTimestamp public="1" set="method">
			<f a=""><c path="java.util.Date"/></f>
			<meta><m n=":overload"/></meta>
		</getTimestamp>
		<getSignerCertPath public="1" set="method">
			<f a=""><c path="java.security.cert.CertPath"/></f>
			<meta><m n=":overload"/></meta>
		</getSignerCertPath>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.util.Date"/>
				<c path="java.security.cert.CertPath"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.Timestamp"</e></m>
		</meta>
	</class>
	<class path="java.security.cert.CertPath" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/cert/CertPath.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getType public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getType>
		<getEncodings public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getEncodings>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<getEncoded public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><getEncoded public="1" set="method">
	<f a="param1">
		<c path="String"/>
		<c path="java.NativeArray"><t path="java.types.Int8"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</getEncoded></overloads>
		</getEncoded>
		<getCertificates public="1" set="method">
			<f a=""><c path="java.util.List"><c path="java.security.cert.Certificate"/></c></f>
			<meta><m n=":overload"/></meta>
		</getCertificates>
		<writeReplace set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</writeReplace>
		<new set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.cert.CertPath"</e></m>
		</meta>
	</class>
	<class path="java.security.cert.CertPath_CertPathRep" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/cert/CertPath$CertPathRep.class" module="java.security.cert.CertPath" extern="1">
		<implements path="java.io.Serializable"/>
		<readResolve set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</readResolve>
		<new set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.cert.CertPath$CertPathRep"</e></m>
		</meta>
	</class>
	<class path="java.security.cert.Certificate" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/cert/Certificate.class" extern="1">
		<implements path="java.io.Serializable"/>
		<getType public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getType>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<getEncoded public="1" set="method">
			<f a=""><c path="java.NativeArray"><t path="java.types.Int8"/></c></f>
			<meta><m n=":overload"/></meta>
		</getEncoded>
		<verify public="1" set="method">
			<f a="param1">
				<c path="java.security.PublicKey"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><verify public="1" set="method">
	<f a="param1:param2">
		<c path="java.security.PublicKey"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</verify></overloads>
		</verify>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<getPublicKey public="1" set="method">
			<f a=""><c path="java.security.PublicKey"/></f>
			<meta><m n=":overload"/></meta>
		</getPublicKey>
		<writeReplace set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</writeReplace>
		<new set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.cert.Certificate"</e></m>
		</meta>
	</class>
	<class path="java.security.cert.Certificate_CertificateRep" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/security/cert/Certificate$CertificateRep.class" module="java.security.cert.Certificate" extern="1">
		<implements path="java.io.Serializable"/>
		<readResolve set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</readResolve>
		<new set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.NativeArray"><t path="java.types.Int8"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.security.cert.Certificate$CertificateRep"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.LocaleServiceProviderPool" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/LocaleServiceProviderPool.class" extern="1">
		<getPool public="1" set="method" static="1">
			<f a="param1">
				<c path="java.lang.Class"><c path="java.util.spi.LocaleServiceProvider"/></c>
				<c path="java.sun.util.LocaleServiceProviderPool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getPool>
		<getAllAvailableLocales public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="java.util.Locale"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAllAvailableLocales>
		<getAvailableLocales public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.util.Locale"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAvailableLocales>
		<hasProviders public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasProviders>
		<getLocalizedObject public="1" params="P:S" set="method">
			<f a="param1:param2:param3">
				<c path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter">
					<c path="getLocalizedObject.P"/>
					<c path="getLocalizedObject.S"/>
				</c>
				<c path="java.util.Locale"/>
				<c path="java.NativeArray"><d/></c>
				<c path="getLocalizedObject.S"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<getLocalizedObject public="1" params="P:S" set="method">
					<f a="param1:param2:param3:param4:param5:param6">
						<c path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter">
							<c path="getLocalizedObject.P"/>
							<c path="getLocalizedObject.S"/>
						</c>
						<c path="java.util.Locale"/>
						<c path="String"/>
						<c path="java.sun.util.resources.OpenListResourceBundle"/>
						<c path="String"/>
						<c path="java.NativeArray"><d/></c>
						<c path="getLocalizedObject.S"/>
					</f>
					<meta><m n=":overload"/></meta>
				</getLocalizedObject>
				<getLocalizedObject public="1" params="P:S" set="method">
					<f a="param1:param2:param3:param4:param5">
						<c path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter">
							<c path="getLocalizedObject.P"/>
							<c path="getLocalizedObject.S"/>
						</c>
						<c path="java.util.Locale"/>
						<c path="java.sun.util.resources.OpenListResourceBundle"/>
						<c path="String"/>
						<c path="java.NativeArray"><d/></c>
						<c path="getLocalizedObject.S"/>
					</f>
					<meta><m n=":overload"/></meta>
				</getLocalizedObject>
			</overloads>
		</getLocalizedObject>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.LocaleServiceProviderPool"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.LocaleServiceProviderPool_AllAvailableLocales" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/LocaleServiceProviderPool$AllAvailableLocales.class" module="java.sun.util.LocaleServiceProviderPool" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"sun.util.LocaleServiceProviderPool$AllAvailableLocales"</e></m>
</meta></class>
	<class path="java.util.spi.LocaleServiceProvider" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/spi/LocaleServiceProvider.class" extern="1">
		<getAvailableLocales public="1" set="method">
			<f a=""><c path="java.NativeArray"><c path="java.util.Locale"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAvailableLocales>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.spi.LocaleServiceProvider"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.LocaleServiceProviderPool_NullProvider" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/LocaleServiceProviderPool$NullProvider.class" module="java.sun.util.LocaleServiceProviderPool" extern="1">
		<extends path="java.util.spi.LocaleServiceProvider"/>
		<getAvailableLocales public="1" set="method" override="1">
			<f a=""><c path="java.NativeArray"><c path="java.util.Locale"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAvailableLocales>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.LocaleServiceProviderPool$NullProvider"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter" params="P:S" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/LocaleServiceProviderPool$LocalizedObjectGetter.class" module="java.sun.util.LocaleServiceProviderPool" extern="1" interface="1">
		<getObject public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter.P"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter.S"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getObject>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.LocaleServiceProviderPool$LocalizedObjectGetter"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.locale.BaseLocale" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/BaseLocale.class" extern="1">
		<createInstance public="1" set="method" static="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<c path="java.sun.util.locale.BaseLocale"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createInstance>
		<getInstance public="1" set="method" static="1">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="java.sun.util.locale.BaseLocale"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getInstance>
		<SEP public="1" static="1">
			<c path="String"/>
			<meta><m n=":final"/></meta>
		</SEP>
		<getLanguage public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getLanguage>
		<getScript public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getScript>
		<getRegion public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getRegion>
		<getVariant public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getVariant>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.locale.BaseLocale"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.locale.BaseLocale_Key" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/BaseLocale$Key.class" module="java.sun.util.locale.BaseLocale" extern="1">
		<implements path="java.lang.Comparable"><c path="java.sun.util.locale.BaseLocale_Key"/></implements>
		<normalize public="1" set="method" static="1">
			<f a="param1">
				<c path="java.sun.util.locale.BaseLocale_Key"/>
				<c path="java.sun.util.locale.BaseLocale_Key"/>
			</f>
			<meta><m n=":overload"/></meta>
		</normalize>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.sun.util.locale.BaseLocale_Key"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<new public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.locale.BaseLocale$Key"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.locale.LocaleObjectCache" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/LocaleObjectCache.class" extern="1">
		<get public="1" set="method">
			<f a="param1">
				<c path="java.sun.util.locale.LocaleObjectCache.K"/>
				<c path="java.sun.util.locale.LocaleObjectCache.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<put set="method">
			<f a="param1:param2">
				<c path="java.sun.util.locale.LocaleObjectCache.K"/>
				<c path="java.sun.util.locale.LocaleObjectCache.V"/>
				<c path="java.sun.util.locale.LocaleObjectCache.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</put>
		<createObject set="method">
			<f a="param1">
				<c path="java.sun.util.locale.LocaleObjectCache.K"/>
				<c path="java.sun.util.locale.LocaleObjectCache.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</createObject>
		<normalizeKey set="method">
			<f a="param1">
				<c path="java.sun.util.locale.LocaleObjectCache.K"/>
				<c path="java.sun.util.locale.LocaleObjectCache.K"/>
			</f>
			<meta><m n=":overload"/></meta>
		</normalizeKey>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2:param3">
		<x path="Int"/>
		<x path="Single"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.locale.LocaleObjectCache"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.locale.BaseLocale_Cache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/BaseLocale$Cache.class" module="java.sun.util.locale.BaseLocale" extern="1">
		<extends path="java.sun.util.locale.LocaleObjectCache">
			<c path="java.sun.util.locale.BaseLocale_Key"/>
			<c path="java.sun.util.locale.BaseLocale"/>
		</extends>
		<createObject set="method" override="1">
			<f a="param1">
				<c path="java.sun.util.locale.BaseLocale_Key"/>
				<c path="java.sun.util.locale.BaseLocale"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><createObject set="method">
	<f a="param1">
		<d/>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</createObject></overloads>
		</createObject>
		<normalizeKey set="method" override="1">
			<f a="param1">
				<c path="java.sun.util.locale.BaseLocale_Key"/>
				<c path="java.sun.util.locale.BaseLocale_Key"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><normalizeKey set="method">
	<f a="param1">
		<d/>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</normalizeKey></overloads>
		</normalizeKey>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.locale.BaseLocale$Cache"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.locale.BaseLocale_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/BaseLocale$1.class" module="java.sun.util.locale.BaseLocale" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"sun.util.locale.BaseLocale$1"</e></m>
</meta></class>
	<class path="java.sun.util.locale.LocaleObjectCache_CacheEntry" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/locale/LocaleObjectCache$CacheEntry.class" module="java.sun.util.locale.LocaleObjectCache" extern="1">
		<extends path="java.lang.ref.SoftReference"><c path="java.sun.util.locale.LocaleObjectCache_CacheEntry.V"/></extends>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.locale.LocaleObjectCache$CacheEntry"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle.class" extern="1">
		<getBundle public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.ResourceBundle"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads>
				<getBundle public="1" set="method">
					<f a="param1:param2:param3:param4">
						<c path="String"/>
						<c path="java.util.Locale"/>
						<c path="java.lang.ClassLoader"/>
						<c path="java.util.ResourceBundle_Control"/>
						<c path="java.util.ResourceBundle"/>
					</f>
					<meta><m n=":overload"/></meta>
				</getBundle>
				<getBundle public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<c path="java.util.Locale"/>
						<c path="java.lang.ClassLoader"/>
						<c path="java.util.ResourceBundle"/>
					</f>
					<meta><m n=":overload"/></meta>
				</getBundle>
				<getBundle public="1" set="method">
					<f a="param1:param2:param3">
						<c path="String"/>
						<c path="java.util.Locale"/>
						<c path="java.util.ResourceBundle_Control"/>
						<c path="java.util.ResourceBundle"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</getBundle>
				<getBundle public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.util.Locale"/>
						<c path="java.util.ResourceBundle"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</getBundle>
				<getBundle public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="java.util.ResourceBundle_Control"/>
						<c path="java.util.ResourceBundle"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":final"/>
					</meta>
				</getBundle>
			</overloads>
		</getBundle>
		<clearCache public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><clearCache public="1" set="method">
	<f a="param1">
		<c path="java.lang.ClassLoader"/>
		<x path="Void"/>
	</f>
	<meta>
		<m n=":overload"/>
		<m n=":final"/>
	</meta>
</clearCache></overloads>
		</clearCache>
		<getString public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getString>
		<getStringArray public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.NativeArray"><c path="String"/></c>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getStringArray>
		<getObject public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<d/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getObject>
		<getLocale public="1" set="method">
			<f a=""><c path="java.util.Locale"/></f>
			<meta><m n=":overload"/></meta>
		</getLocale>
		<setParent set="method">
			<f a="param1">
				<c path="java.util.ResourceBundle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setParent>
		<handleGetObject set="method">
			<f a="param1">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</handleGetObject>
		<getKeys public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getKeys>
		<containsKey public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsKey>
		<keySet public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</keySet>
		<handleKeySet set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</handleKeySet>
		<parent><c path="java.util.ResourceBundle"/></parent>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle"</e></m>
		</meta>
	</class>
	<class path="java.sun.util.resources.OpenListResourceBundle" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@sun/util/resources/OpenListResourceBundle.class" extern="1">
		<extends path="java.util.ResourceBundle"/>
		<getKeys public="1" set="method" override="1">
			<f a=""><c path="java.util.Enumeration"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getKeys>
		<handleGetObject public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</handleGetObject>
		<handleGetKeys public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</handleGetKeys>
		<getParent public="1" set="method">
			<f a=""><c path="java.sun.util.resources.OpenListResourceBundle"/></f>
			<meta><m n=":overload"/></meta>
		</getParent>
		<getContents set="method">
			<f a=""><c path="java.NativeArray"><c path="java.NativeArray"><d/></c></c></f>
			<meta><m n=":overload"/></meta>
		</getContents>
		<createMap set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.util.Map">
					<d/>
					<d/>
				</c>
			</f>
			<meta><m n=":overload"/></meta>
		</createMap>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"sun.util.resources.OpenListResourceBundle"</e></m>
		</meta>
	</class>
	<typedef path="java.types.Char16" params="" file="/usr/lib/haxe/std/java/types/Char16.hx"><x path="java.Char16"/></typedef>
	<typedef path="java.types.Int16" params="" file="/usr/lib/haxe/std/java/types/Int16.hx"><x path="java.Int16"/></typedef>
	<typedef path="java.types.Int8" params="" file="/usr/lib/haxe/std/java/types/Int8.hx"><x path="java.Int8"/></typedef>
	<class path="java.util.Collection" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Collection.class" extern="1" interface="1">
		<extends path="java.lang.Iterable"><c path="java.util.Collection.E"/></extends>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<contains public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.util.Collection.E"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<toArray public="1" set="method">
			<f a=""><c path="java.NativeArray"><d/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><toArray public="1" params="T" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="toArray.T"/></c>
		<c path="java.NativeArray"><c path="toArray.T"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</toArray></overloads>
		</toArray>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection.E"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</add>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<containsAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsAll>
		<addAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.Collection.E"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</addAll>
		<removeAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeAll>
		<retainAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</retainAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Collection"</e></m>
		</meta>
	</class>
	<class path="java.util.AbstractCollection" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/AbstractCollection.class" extern="1">
		<implements path="java.util.Collection"><c path="java.util.AbstractCollection.E"/></implements>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.util.AbstractCollection.E"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<contains public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<toArray public="1" set="method">
			<f a=""><c path="java.NativeArray"><d/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><toArray public="1" params="T" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="toArray.T"/></c>
		<c path="java.NativeArray"><c path="toArray.T"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</toArray></overloads>
		</toArray>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.util.AbstractCollection.E"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</add>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<containsAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsAll>
		<addAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.AbstractCollection.E"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</addAll>
		<removeAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeAll>
		<retainAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</retainAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.AbstractCollection"</e></m>
		</meta>
	</class>
	<class path="java.util.Set" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Set.class" extern="1" interface="1">
		<extends path="java.util.Collection"><c path="java.util.Set.E"/></extends>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<contains public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.util.Set.E"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<toArray public="1" set="method">
			<f a=""><c path="java.NativeArray"><d/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><toArray public="1" params="T" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="toArray.T"/></c>
		<c path="java.NativeArray"><c path="toArray.T"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</toArray></overloads>
		</toArray>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.util.Set.E"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</add>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<containsAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsAll>
		<addAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.Set.E"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</addAll>
		<retainAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</retainAll>
		<removeAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Set"</e></m>
		</meta>
	</class>
	<class path="java.util.AbstractSet" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/AbstractSet.class" extern="1">
		<extends path="java.util.AbstractCollection"><c path="java.util.AbstractSet.E"/></extends>
		<implements path="java.util.Set"><c path="java.util.AbstractSet.E"/></implements>
		<removeAll public="1" set="method" override="1">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeAll>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.AbstractSet"</e></m>
		</meta>
	</class>
	<class path="java.util.Date" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Date.class" extern="1">
		<implements path="java.lang.Comparable"><c path="java.util.Date"/></implements>
		<implements path="java.lang.Cloneable"/>
		<implements path="java.io.Serializable"/>
		<UTC public="1" set="method" static="1">
			<f a="param1:param2:param3:param4:param5:param6">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</UTC>
		<parse public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</parse>
		<clone public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<getYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getYear>
		<setYear public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getMonth>
		<setMonth public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getDate>
		<setDate public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getDay>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getHours>
		<setHours public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getMinutes>
		<setMinutes public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getSeconds>
		<setSeconds public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</setSeconds>
		<getTime public="1" set="method">
			<f a=""><c path="haxe.Int64"/></f>
			<meta><m n=":overload"/></meta>
		</getTime>
		<setTime public="1" set="method">
			<f a="param1">
				<c path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setTime>
		<before public="1" set="method">
			<f a="param1">
				<c path="java.util.Date"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</before>
		<after public="1" set="method">
			<f a="param1">
				<c path="java.util.Date"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</after>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<compareTo public="1" set="method">
			<f a="param1">
				<c path="java.util.Date"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><compareTo public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</compareTo></overloads>
		</compareTo>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<toLocaleString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</toLocaleString>
		<toGMTString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</toGMTString>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</getTimezoneOffset>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5:param6">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3:param4:param5">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2:param3">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta>
						<m n=":overload"/>
						<m n=":deprecated"/>
					</meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<c path="haxe.Int64"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Date"</e></m>
		</meta>
	</class>
	<class path="java.util.Dictionary" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Dictionary.class" extern="1">
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<keys public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="java.util.Dictionary.K"/></c></f>
			<meta><m n=":overload"/></meta>
		</keys>
		<elements public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><c path="java.util.Dictionary.V"/></c></f>
			<meta><m n=":overload"/></meta>
		</elements>
		<get public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.util.Dictionary.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<put public="1" set="method">
			<f a="param1:param2">
				<c path="java.util.Dictionary.K"/>
				<c path="java.util.Dictionary.V"/>
				<c path="java.util.Dictionary.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</put>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.util.Dictionary.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Dictionary"</e></m>
		</meta>
	</class>
	<class path="java.util.Enumeration" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Enumeration.class" extern="1" interface="1">
		<hasMoreElements public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasMoreElements>
		<nextElement public="1" set="method">
			<f a=""><c path="java.util.Enumeration.E"/></f>
			<meta><m n=":overload"/></meta>
		</nextElement>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Enumeration"</e></m>
		</meta>
	</class>
	<class path="java.util.Map" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Map.class" extern="1" interface="1">
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<containsKey public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsKey>
		<containsValue public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsValue>
		<get public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.util.Map.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<put public="1" set="method">
			<f a="param1:param2">
				<c path="java.util.Map.K"/>
				<c path="java.util.Map.V"/>
				<c path="java.util.Map.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</put>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<c path="java.util.Map.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<putAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Map">
					<c path="java.util.Map.K"/>
					<c path="java.util.Map.V"/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</putAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<keySet public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.util.Map.K"/></c></f>
			<meta><m n=":overload"/></meta>
		</keySet>
		<values public="1" set="method">
			<f a=""><c path="java.util.Collection"><c path="java.util.Map.V"/></c></f>
			<meta><m n=":overload"/></meta>
		</values>
		<entrySet public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.util.Map_Entry">
	<c path="java.util.Map.K"/>
	<c path="java.util.Map.V"/>
</c></c></f>
			<meta><m n=":overload"/></meta>
		</entrySet>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Map"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable.class" extern="1">
		<extends path="java.util.Dictionary">
			<c path="java.util.Hashtable.K"/>
			<c path="java.util.Hashtable.V"/>
		</extends>
		<implements path="java.io.Serializable"/>
		<implements path="java.lang.Cloneable"/>
		<implements path="java.util.Map">
			<c path="java.util.Hashtable.K"/>
			<c path="java.util.Hashtable.V"/>
		</implements>
		<remove public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<c path="java.util.Hashtable.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<put public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="java.util.Hashtable.K"/>
				<c path="java.util.Hashtable.V"/>
				<c path="java.util.Hashtable.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</put>
		<get public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<c path="java.util.Hashtable.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<elements public="1" set="method" override="1">
			<f a=""><c path="java.util.Enumeration"><c path="java.util.Hashtable.V"/></c></f>
			<meta><m n=":overload"/></meta>
		</elements>
		<keys public="1" set="method" override="1">
			<f a=""><c path="java.util.Enumeration"><c path="java.util.Hashtable.K"/></c></f>
			<meta><m n=":overload"/></meta>
		</keys>
		<isEmpty public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<size public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<contains public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<containsValue public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsValue>
		<containsKey public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsKey>
		<rehash set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</rehash>
		<putAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Map">
					<c path="java.util.Hashtable.K"/>
					<c path="java.util.Hashtable.V"/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</putAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<clone public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<keySet public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.util.Hashtable.K"/></c></f>
			<meta><m n=":overload"/></meta>
		</keySet>
		<entrySet public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="java.util.Map_Entry">
	<c path="java.util.Hashtable.K"/>
	<c path="java.util.Hashtable.V"/>
</c></c></f>
			<meta><m n=":overload"/></meta>
		</entrySet>
		<values public="1" set="method">
			<f a=""><c path="java.util.Collection"><c path="java.util.Hashtable.V"/></c></f>
			<meta><m n=":overload"/></meta>
		</values>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="java.util.Map">
							<c path="java.util.Hashtable.K"/>
							<c path="java.util.Hashtable.V"/>
						</c>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<x path="Int"/>
						<x path="Single"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_Holder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$Holder.class" module="java.util.Hashtable" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.Hashtable$Holder"</e></m>
</meta></class>
	<class path="java.util.Hashtable_KeySet" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$KeySet.class" module="java.util.Hashtable" extern="1">
		<extends path="java.util.AbstractSet"><d/></extends>
		<clear public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<remove public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<contains public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<size public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<iterator public="1" set="method" override="1">
			<f a=""><c path="java.util.Iterator"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable$KeySet"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_EntrySet" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$EntrySet.class" module="java.util.Hashtable" extern="1">
		<extends path="java.util.AbstractSet"><c path="java.util.Map_Entry">
	<d/>
	<d/>
</c></extends>
		<clear public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<size public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<remove public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</remove>
		<contains public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<add public="1" set="method" override="1">
			<f a="param1">
				<c path="java.util.Map_Entry">
					<d/>
					<d/>
				</c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><add public="1" set="method">
	<f a="param1">
		<d/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</add></overloads>
		</add>
		<iterator public="1" set="method" override="1">
			<f a=""><c path="java.util.Iterator"><c path="java.util.Map_Entry">
	<d/>
	<d/>
</c></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable$EntrySet"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_ValueCollection" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$ValueCollection.class" module="java.util.Hashtable" extern="1">
		<extends path="java.util.AbstractCollection"><d/></extends>
		<clear public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<contains public="1" set="method" override="1">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<size public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<iterator public="1" set="method" override="1">
			<f a=""><c path="java.util.Iterator"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable$ValueCollection"</e></m>
		</meta>
	</class>
	<class path="java.util.Map_Entry" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Map$Entry.class" module="java.util.Map" extern="1" interface="1">
		<getKey public="1" set="method">
			<f a=""><c path="java.util.Map_Entry.K"/></f>
			<meta><m n=":overload"/></meta>
		</getKey>
		<getValue public="1" set="method">
			<f a=""><c path="java.util.Map_Entry.V"/></f>
			<meta><m n=":overload"/></meta>
		</getValue>
		<setValue public="1" set="method">
			<f a="param1">
				<c path="java.util.Map_Entry.V"/>
				<c path="java.util.Map_Entry.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setValue>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Map$Entry"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_Entry" params="K:V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$Entry.class" module="java.util.Hashtable" extern="1">
		<implements path="java.util.Map_Entry">
			<c path="java.util.Hashtable_Entry.K"/>
			<c path="java.util.Hashtable_Entry.V"/>
		</implements>
		<clone set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<getKey public="1" set="method">
			<f a=""><c path="java.util.Hashtable_Entry.K"/></f>
			<meta><m n=":overload"/></meta>
		</getKey>
		<getValue public="1" set="method">
			<f a=""><c path="java.util.Hashtable_Entry.V"/></f>
			<meta><m n=":overload"/></meta>
		</getValue>
		<setValue public="1" set="method">
			<f a="param1">
				<c path="java.util.Hashtable_Entry.V"/>
				<c path="java.util.Hashtable_Entry.V"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setValue>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<new set="method">
			<f a="param1:param2:param3:param4">
				<x path="Int"/>
				<c path="java.util.Hashtable_Entry.K"/>
				<c path="java.util.Hashtable_Entry.V"/>
				<c path="java.util.Hashtable_Entry">
					<c path="java.util.Hashtable_Entry.K"/>
					<c path="java.util.Hashtable_Entry.V"/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable$Entry"</e></m>
		</meta>
	</class>
	<class path="java.util.Iterator" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Iterator.class" extern="1" interface="1">
		<hasNext public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasNext>
		<next public="1" set="method">
			<f a=""><c path="java.util.Iterator.E"/></f>
			<meta><m n=":overload"/></meta>
		</next>
		<remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</remove>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Iterator"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_Enumerator" params="T" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$Enumerator.class" module="java.util.Hashtable" extern="1">
		<implements path="java.util.Iterator"><c path="java.util.Hashtable_Enumerator.T"/></implements>
		<implements path="java.util.Enumeration"><c path="java.util.Hashtable_Enumerator.T"/></implements>
		<hasMoreElements public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasMoreElements>
		<nextElement public="1" set="method">
			<f a=""><c path="java.util.Hashtable_Enumerator.T"/></f>
			<meta><m n=":overload"/></meta>
		</nextElement>
		<hasNext public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasNext>
		<next public="1" set="method">
			<f a=""><c path="java.util.Hashtable_Enumerator.T"/></f>
			<meta><m n=":overload"/></meta>
		</next>
		<remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</remove>
		<expectedModCount><x path="Int"/></expectedModCount>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Hashtable$Enumerator"</e></m>
		</meta>
	</class>
	<class path="java.util.Hashtable_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Hashtable$1.class" module="java.util.Hashtable" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.Hashtable$1"</e></m>
</meta></class>
	<class path="java.util.List" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/List.class" extern="1" interface="1">
		<extends path="java.util.Collection"><c path="java.util.List.E"/></extends>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isEmpty>
		<contains public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</contains>
		<iterator public="1" set="method">
			<f a=""><c path="java.util.Iterator"><c path="java.util.List.E"/></c></f>
			<meta><m n=":overload"/></meta>
		</iterator>
		<toArray public="1" set="method">
			<f a=""><c path="java.NativeArray"><d/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><toArray public="1" params="T" set="method">
	<f a="param1">
		<c path="java.NativeArray"><c path="toArray.T"/></c>
		<c path="java.NativeArray"><c path="toArray.T"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</toArray></overloads>
		</toArray>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.util.List.E"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><add public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<c path="java.util.List.E"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</add></overloads>
		</add>
		<remove public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><remove public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.util.List.E"/>
	</f>
	<meta><m n=":overload"/></meta>
</remove></overloads>
		</remove>
		<containsAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</containsAll>
		<addAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.List.E"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><addAll public="1" set="method">
	<f a="param1:param2">
		<x path="Int"/>
		<c path="java.util.Collection"><c path="java.util.List.E"/></c>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</addAll></overloads>
		</addAll>
		<removeAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeAll>
		<retainAll public="1" set="method">
			<f a="param1">
				<c path="java.util.Collection"><d/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</retainAll>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<get public="1" set="method">
			<f a="param1">
				<x path="Int"/>
				<c path="java.util.List.E"/>
			</f>
			<meta><m n=":overload"/></meta>
		</get>
		<set public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<c path="java.util.List.E"/>
				<c path="java.util.List.E"/>
			</f>
			<meta><m n=":overload"/></meta>
		</set>
		<indexOf public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
		</lastIndexOf>
		<listIterator public="1" set="method">
			<f a=""><c path="java.util.ListIterator"><c path="java.util.List.E"/></c></f>
			<meta><m n=":overload"/></meta>
			<overloads><listIterator public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="java.util.ListIterator"><c path="java.util.List.E"/></c>
	</f>
	<meta><m n=":overload"/></meta>
</listIterator></overloads>
		</listIterator>
		<subList public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.util.List"><c path="java.util.List.E"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</subList>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.List"</e></m>
		</meta>
	</class>
	<class path="java.util.ListIterator" params="E" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ListIterator.class" extern="1" interface="1">
		<extends path="java.util.Iterator"><c path="java.util.ListIterator.E"/></extends>
		<hasNext public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasNext>
		<next public="1" set="method">
			<f a=""><c path="java.util.ListIterator.E"/></f>
			<meta><m n=":overload"/></meta>
		</next>
		<hasPrevious public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasPrevious>
		<previous public="1" set="method">
			<f a=""><c path="java.util.ListIterator.E"/></f>
			<meta><m n=":overload"/></meta>
		</previous>
		<nextIndex public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</nextIndex>
		<previousIndex public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</previousIndex>
		<remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</remove>
		<set public="1" set="method">
			<f a="param1">
				<c path="java.util.ListIterator.E"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</set>
		<add public="1" set="method">
			<f a="param1">
				<c path="java.util.ListIterator.E"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</add>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ListIterator"</e></m>
		</meta>
	</class>
	<class path="java.util.Locale" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale.class" extern="1">
		<implements path="java.lang.Cloneable"/>
		<implements path="java.io.Serializable"/>
		<getDefault public="1" set="method" static="1">
			<f a=""><c path="java.util.Locale"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getDefault public="1" set="method">
	<f a="param1">
		<e path="java.util.Locale_Category"/>
		<c path="java.util.Locale"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDefault></overloads>
		</getDefault>
		<setDefault public="1" set="method" static="1">
			<f a="param1">
				<c path="java.util.Locale"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><setDefault public="1" set="method">
	<f a="param1:param2">
		<e path="java.util.Locale_Category"/>
		<c path="java.util.Locale"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</setDefault></overloads>
		</setDefault>
		<getAvailableLocales public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="java.util.Locale"/></c></f>
			<meta><m n=":overload"/></meta>
		</getAvailableLocales>
		<getISOCountries public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getISOCountries>
		<getISOLanguages public="1" set="method" static="1">
			<f a=""><c path="java.NativeArray"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getISOLanguages>
		<forLanguageTag public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale"/>
			</f>
			<meta><m n=":overload"/></meta>
		</forLanguageTag>
		<UNICODE_LOCALE_EXTENSION public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</UNICODE_LOCALE_EXTENSION>
		<PRIVATE_USE_EXTENSION public="1" set="null" static="1">
			<t path="java.types.Char16"/>
			<meta><m n=":final"/></meta>
		</PRIVATE_USE_EXTENSION>
		<ROOT public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</ROOT>
		<CANADA_FRENCH public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</CANADA_FRENCH>
		<CANADA public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</CANADA>
		<US public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</US>
		<UK public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</UK>
		<TAIWAN public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</TAIWAN>
		<PRC public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</PRC>
		<CHINA public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</CHINA>
		<KOREA public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</KOREA>
		<JAPAN public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</JAPAN>
		<ITALY public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</ITALY>
		<GERMANY public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</GERMANY>
		<FRANCE public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</FRANCE>
		<TRADITIONAL_CHINESE public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</TRADITIONAL_CHINESE>
		<SIMPLIFIED_CHINESE public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</SIMPLIFIED_CHINESE>
		<CHINESE public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</CHINESE>
		<KOREAN public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</KOREAN>
		<JAPANESE public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</JAPANESE>
		<ITALIAN public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</ITALIAN>
		<GERMAN public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</GERMAN>
		<FRENCH public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</FRENCH>
		<ENGLISH public="1" static="1">
			<c path="java.util.Locale"/>
			<meta><m n=":final"/></meta>
		</ENGLISH>
		<getLanguage public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getLanguage>
		<getScript public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getScript>
		<getCountry public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getCountry>
		<getVariant public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getVariant>
		<getExtension public="1" set="method">
			<f a="param1">
				<t path="java.types.Char16"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getExtension>
		<getExtensionKeys public="1" set="method">
			<f a=""><c path="java.util.Set"><t path="Null"><t path="java.types.Char16"/></t></c></f>
			<meta><m n=":overload"/></meta>
		</getExtensionKeys>
		<getUnicodeLocaleAttributes public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getUnicodeLocaleAttributes>
		<getUnicodeLocaleType public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getUnicodeLocaleType>
		<getUnicodeLocaleKeys public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</getUnicodeLocaleKeys>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</toString>
		<toLanguageTag public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toLanguageTag>
		<getISO3Language public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getISO3Language>
		<getISO3Country public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</getISO3Country>
		<getDisplayLanguage public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><getDisplayLanguage public="1" set="method">
	<f a="param1">
		<c path="java.util.Locale"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDisplayLanguage></overloads>
		</getDisplayLanguage>
		<getDisplayScript public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><getDisplayScript public="1" set="method">
	<f a="param1">
		<c path="java.util.Locale"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDisplayScript></overloads>
		</getDisplayScript>
		<getDisplayCountry public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><getDisplayCountry public="1" set="method">
	<f a="param1">
		<c path="java.util.Locale"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDisplayCountry></overloads>
		</getDisplayCountry>
		<getDisplayVariant public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><getDisplayVariant public="1" set="method">
	<f a="param1">
		<c path="java.util.Locale"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDisplayVariant></overloads>
		</getDisplayVariant>
		<getDisplayName public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
			<overloads><getDisplayName public="1" set="method">
	<f a="param1">
		<c path="java.util.Locale"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getDisplayName></overloads>
		</getDisplayName>
		<clone public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<new public="1" set="method">
			<f a="param1:param2:param3">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<new public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
				<new public="1" set="method">
					<f a="param1:param2">
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<meta><m n=":overload"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Locale"</e></m>
		</meta>
	</class>
	<class path="java.util.Locale_Cache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$Cache.class" module="java.util.Locale" extern="1">
		<extends path="java.sun.util.locale.LocaleObjectCache">
			<c path="java.util.Locale_LocaleKey"/>
			<c path="java.util.Locale"/>
		</extends>
		<createObject set="method" override="1">
			<f a="param1">
				<c path="java.util.Locale_LocaleKey"/>
				<c path="java.util.Locale"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><createObject set="method">
	<f a="param1">
		<d/>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</createObject></overloads>
		</createObject>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Locale$Cache"</e></m>
		</meta>
	</class>
	<class path="java.util.Locale_LocaleKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$LocaleKey.class" module="java.util.Locale" extern="1">
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Locale$LocaleKey"</e></m>
		</meta>
	</class>
	<class path="java.util.Locale_LocaleNameGetter" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$LocaleNameGetter.class" module="java.util.Locale" extern="1">
		<implements path="java.sun.util.LocaleServiceProviderPool_LocalizedObjectGetter">
			<c path="java.util.spi.LocaleNameProvider"/>
			<c path="String"/>
		</implements>
		<getObject public="1" set="method">
			<f a="param1:param2:param3:param4">
				<c path="java.util.spi.LocaleNameProvider"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
				<c path="java.NativeArray"><d/></c>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getObject public="1" set="method">
	<f a="param1:param2:param3:param4">
		<d/>
		<c path="java.util.Locale"/>
		<c path="String"/>
		<c path="java.NativeArray"><d/></c>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</getObject></overloads>
		</getObject>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Locale$LocaleNameGetter"</e></m>
		</meta>
	</class>
	<enum path="java.util.Locale_Category" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$Category.class" module="java.util.Locale"><meta><m n=":native"><e>"java.util.Locale$Category"</e></m></meta></enum>
	<class path="java.util.Locale_Builder" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$Builder.class" module="java.util.Locale" extern="1">
		<setLocale public="1" set="method">
			<f a="param1">
				<c path="java.util.Locale"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLocale>
		<setLanguageTag public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLanguageTag>
		<setLanguage public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setLanguage>
		<setScript public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setScript>
		<setRegion public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setRegion>
		<setVariant public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setVariant>
		<setExtension public="1" set="method">
			<f a="param1:param2">
				<t path="java.types.Char16"/>
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setExtension>
		<setUnicodeLocaleKeyword public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</setUnicodeLocaleKeyword>
		<addUnicodeLocaleAttribute public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</addUnicodeLocaleAttribute>
		<removeUnicodeLocaleAttribute public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.Locale_Builder"/>
			</f>
			<meta><m n=":overload"/></meta>
		</removeUnicodeLocaleAttribute>
		<clear public="1" set="method">
			<f a=""><c path="java.util.Locale_Builder"/></f>
			<meta><m n=":overload"/></meta>
		</clear>
		<clearExtensions public="1" set="method">
			<f a=""><c path="java.util.Locale_Builder"/></f>
			<meta><m n=":overload"/></meta>
		</clearExtensions>
		<build public="1" set="method">
			<f a=""><c path="java.util.Locale"/></f>
			<meta><m n=":overload"/></meta>
		</build>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Locale$Builder"</e></m>
		</meta>
	</class>
	<class path="java.util.Locale_1" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Locale$1.class" module="java.util.Locale" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.Locale$1"</e></m>
</meta></class>
	<class path="java.util.Properties" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Properties.class" extern="1">
		<extends path="java.util.Hashtable">
			<d/>
			<d/>
		</extends>
		<setProperty public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":overload"/></meta>
		</setProperty>
		<load public="1" set="method">
			<f a="param1">
				<c path="java.io.Reader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><load public="1" set="method">
	<f a="param1">
		<c path="java.io.InputStream"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</load></overloads>
		</load>
		<save public="1" set="method">
			<f a="param1:param2">
				<c path="java.io.OutputStream"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":deprecated"/>
			</meta>
		</save>
		<store public="1" set="method">
			<f a="param1:param2">
				<c path="java.io.Writer"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><store public="1" set="method">
	<f a="param1:param2">
		<c path="java.io.OutputStream"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</store></overloads>
		</store>
		<loadFromXML public="1" set="method">
			<f a="param1">
				<c path="java.io.InputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</loadFromXML>
		<storeToXML public="1" set="method">
			<f a="param1:param2">
				<c path="java.io.OutputStream"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><storeToXML public="1" set="method">
	<f a="param1:param2:param3">
		<c path="java.io.OutputStream"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</storeToXML></overloads>
		</storeToXML>
		<getProperty public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><getProperty public="1" set="method">
	<f a="param1:param2">
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</getProperty></overloads>
		</getProperty>
		<propertyNames public="1" set="method">
			<f a=""><c path="java.util.Enumeration"><d/></c></f>
			<meta><m n=":overload"/></meta>
		</propertyNames>
		<stringPropertyNames public="1" set="method">
			<f a=""><c path="java.util.Set"><c path="String"/></c></f>
			<meta><m n=":overload"/></meta>
		</stringPropertyNames>
		<list public="1" set="method">
			<f a="param1">
				<c path="java.io.PrintStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><list public="1" set="method">
	<f a="param1">
		<c path="java.io.PrintWriter"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</list></overloads>
		</list>
		<defaults><c path="java.util.Properties"/></defaults>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1">
		<c path="java.util.Properties"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Properties"</e></m>
		</meta>
	</class>
	<class path="java.util.Properties_LineReader" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/Properties$LineReader.class" module="java.util.Properties" extern="1">
		<new public="1" set="method">
			<f a="param1:param2">
				<c path="java.util.Properties"/>
				<c path="java.io.InputStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method">
	<f a="param1:param2">
		<c path="java.util.Properties"/>
		<c path="java.io.Reader"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.Properties$LineReader"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_RBClassLoader" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$RBClassLoader.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.lang.ClassLoader"/>
		<getResourceAsStream public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.io.InputStream"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResourceAsStream>
		<getResource public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.net.URL"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getResource>
		<loadClass public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.lang.Class"><d/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</loadClass>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$RBClassLoader"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_CacheKey" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$CacheKey.class" module="java.util.ResourceBundle" extern="1">
		<implements path="java.lang.Cloneable"/>
		<equals public="1" set="method">
			<f a="param1">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</equals>
		<hashCode public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</hashCode>
		<clone public="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$CacheKey"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_CacheKeyReference" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$CacheKeyReference.class" module="java.util.ResourceBundle" extern="1" interface="1">
		<getCacheKey public="1" set="method">
			<f a=""><c path="java.util.ResourceBundle_CacheKey"/></f>
			<meta><m n=":overload"/></meta>
		</getCacheKey>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$CacheKeyReference"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_LoaderReference" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$LoaderReference.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.lang.ref.WeakReference"><c path="java.lang.ClassLoader"/></extends>
		<implements path="java.util.ResourceBundle_CacheKeyReference"/>
		<getCacheKey public="1" set="method">
			<f a=""><c path="java.util.ResourceBundle_CacheKey"/></f>
			<meta><m n=":overload"/></meta>
		</getCacheKey>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$LoaderReference"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_BundleReference" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$BundleReference.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.lang.ref.SoftReference"><c path="java.util.ResourceBundle"/></extends>
		<implements path="java.util.ResourceBundle_CacheKeyReference"/>
		<getCacheKey public="1" set="method">
			<f a=""><c path="java.util.ResourceBundle_CacheKey"/></f>
			<meta><m n=":overload"/></meta>
		</getCacheKey>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$BundleReference"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_Control" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$Control.class" module="java.util.ResourceBundle" extern="1">
		<getControl public="1" set="method" static="1">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<c path="java.util.ResourceBundle_Control"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getControl>
		<getNoFallbackControl public="1" set="method" static="1">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<c path="java.util.ResourceBundle_Control"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</getNoFallbackControl>
		<TTL_NO_EXPIRATION_CONTROL public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</TTL_NO_EXPIRATION_CONTROL>
		<TTL_DONT_CACHE public="1" set="null" static="1">
			<c path="haxe.Int64"/>
			<meta><m n=":final"/></meta>
		</TTL_DONT_CACHE>
		<FORMAT_PROPERTIES public="1" static="1">
			<c path="java.util.List"><c path="String"/></c>
			<meta><m n=":final"/></meta>
		</FORMAT_PROPERTIES>
		<FORMAT_CLASS public="1" static="1">
			<c path="java.util.List"><c path="String"/></c>
			<meta><m n=":final"/></meta>
		</FORMAT_CLASS>
		<FORMAT_DEFAULT public="1" static="1">
			<c path="java.util.List"><c path="String"/></c>
			<meta><m n=":final"/></meta>
		</FORMAT_DEFAULT>
		<getFormats public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.List"><c path="String"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getFormats>
		<getCandidateLocales public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="java.util.List"><c path="java.util.Locale"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getCandidateLocales>
		<getFallbackLocale public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="java.util.Locale"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFallbackLocale>
		<newBundle public="1" set="method">
			<f a="param1:param2:param3:param4:param5">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
				<c path="java.lang.ClassLoader"/>
				<x path="Bool"/>
				<c path="java.util.ResourceBundle"/>
			</f>
			<meta><m n=":overload"/></meta>
		</newBundle>
		<getTimeToLive public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="haxe.Int64"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getTimeToLive>
		<needsReload public="1" set="method">
			<f a="param1:param2:param3:param4:param5:param6">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
				<c path="java.lang.ClassLoader"/>
				<c path="java.util.ResourceBundle"/>
				<c path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</needsReload>
		<toBundleName public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</toBundleName>
		<toResourceName public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":final"/>
			</meta>
		</toResourceName>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$Control"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_Control_CandidateListCache" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$Control$CandidateListCache.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.sun.util.locale.LocaleObjectCache">
			<c path="java.sun.util.locale.BaseLocale"/>
			<c path="java.util.List"><c path="java.util.Locale"/></c>
		</extends>
		<createObject set="method" override="1">
			<f a="param1">
				<c path="java.sun.util.locale.BaseLocale"/>
				<c path="java.util.List"><c path="java.util.Locale"/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><createObject set="method">
	<f a="param1">
		<d/>
		<d/>
	</f>
	<meta><m n=":overload"/></meta>
</createObject></overloads>
		</createObject>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$Control$CandidateListCache"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_SingleFormatControl" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$SingleFormatControl.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.util.ResourceBundle_Control"/>
		<getFormats public="1" set="method" override="1">
			<f a="param1">
				<c path="String"/>
				<c path="java.util.List"><c path="String"/></c>
			</f>
			<meta><m n=":overload"/></meta>
		</getFormats>
		<new set="method">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$SingleFormatControl"</e></m>
		</meta>
	</class>
	<class path="java.util.ResourceBundle_NoFallbackControl" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/ResourceBundle$NoFallbackControl.class" module="java.util.ResourceBundle" extern="1">
		<extends path="java.util.ResourceBundle_SingleFormatControl"/>
		<getFallbackLocale public="1" set="method" override="1">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="java.util.Locale"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getFallbackLocale>
		<new set="method">
			<f a="param1">
				<c path="java.util.List"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.ResourceBundle$NoFallbackControl"</e></m>
		</meta>
	</class>
	<class path="java.util.concurrent.Callable" params="V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/concurrent/Callable.class" extern="1" interface="1">
		<call public="1" set="method">
			<f a=""><c path="java.util.concurrent.Callable.V"/></f>
			<meta><m n=":overload"/></meta>
		</call>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.concurrent.Callable"</e></m>
		</meta>
	</class>
	<class path="java.util.concurrent.Executor" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/concurrent/Executor.class" extern="1" interface="1">
		<execute public="1" set="method">
			<f a="param1">
				<c path="java.lang.Runnable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</execute>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.concurrent.Executor"</e></m>
		</meta>
	</class>
	<class path="java.util.concurrent.ExecutorService" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/concurrent/ExecutorService.class" extern="1" interface="1">
		<extends path="java.util.concurrent.Executor"/>
		<execute public="1" set="method">
			<f a="param1">
				<c path="java.lang.Runnable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
		</execute>
		<shutdown public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</shutdown>
		<shutdownNow public="1" set="method">
			<f a=""><c path="java.util.List"><c path="java.lang.Runnable"/></c></f>
			<meta><m n=":overload"/></meta>
		</shutdownNow>
		<isShutdown public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isShutdown>
		<isTerminated public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isTerminated>
		<awaitTermination public="1" set="method">
			<f a="param1:param2">
				<c path="haxe.Int64"/>
				<e path="java.util.concurrent.TimeUnit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</awaitTermination>
		<submit public="1" params="T" set="method">
			<f a="param1">
				<c path="java.util.concurrent.Callable"><c path="submit.T"/></c>
				<c path="java.util.concurrent.Future"><c path="submit.T"/></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<submit public="1" set="method">
					<f a="param1">
						<c path="java.lang.Runnable"/>
						<c path="java.util.concurrent.Future"><d/></c>
					</f>
					<meta><m n=":overload"/></meta>
				</submit>
				<submit public="1" params="T" set="method">
					<f a="param1:param2">
						<c path="java.lang.Runnable"/>
						<c path="submit.T"/>
						<c path="java.util.concurrent.Future"><c path="submit.T"/></c>
					</f>
					<meta><m n=":overload"/></meta>
				</submit>
			</overloads>
		</submit>
		<invokeAll public="1" params="T" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.concurrent.Callable"><c path="invokeAll.T"/></c></c>
				<c path="java.util.List"><c path="java.util.concurrent.Future"><c path="invokeAll.T"/></c></c>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><invokeAll public="1" params="T" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Collection"><c path="java.util.concurrent.Callable"><c path="invokeAll.T"/></c></c>
		<c path="haxe.Int64"/>
		<e path="java.util.concurrent.TimeUnit"/>
		<c path="java.util.List"><c path="java.util.concurrent.Future"><c path="invokeAll.T"/></c></c>
	</f>
	<meta><m n=":overload"/></meta>
</invokeAll></overloads>
		</invokeAll>
		<invokeAny public="1" params="T" set="method">
			<f a="param1">
				<c path="java.util.Collection"><c path="java.util.concurrent.Callable"><c path="invokeAny.T"/></c></c>
				<c path="invokeAny.T"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><invokeAny public="1" params="T" set="method">
	<f a="param1:param2:param3">
		<c path="java.util.Collection"><c path="java.util.concurrent.Callable"><c path="invokeAny.T"/></c></c>
		<c path="haxe.Int64"/>
		<e path="java.util.concurrent.TimeUnit"/>
		<c path="invokeAny.T"/>
	</f>
	<meta><m n=":overload"/></meta>
</invokeAny></overloads>
		</invokeAny>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.concurrent.ExecutorService"</e></m>
		</meta>
	</class>
	<class path="java.util.concurrent.Future" params="V" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/concurrent/Future.class" extern="1" interface="1">
		<cancel public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":overload"/></meta>
		</cancel>
		<isCancelled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isCancelled>
		<isDone public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</isDone>
		<get public="1" set="method">
			<f a=""><c path="java.util.concurrent.Future.V"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><get public="1" set="method">
	<f a="param1:param2">
		<c path="haxe.Int64"/>
		<e path="java.util.concurrent.TimeUnit"/>
		<c path="java.util.concurrent.Future.V"/>
	</f>
	<meta><m n=":overload"/></meta>
</get></overloads>
		</get>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.concurrent.Future"</e></m>
		</meta>
	</class>
	<enum path="java.util.concurrent.TimeUnit" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/concurrent/TimeUnit.class"><meta><m n=":native"><e>"java.util.concurrent.TimeUnit"</e></m></meta></enum>
	<class path="java.util.regex.MatchResult" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/MatchResult.class" extern="1" interface="1">
		<start public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><start public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</start></overloads>
		</start>
		<end public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><end public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</end></overloads>
		</end>
		<group public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><group public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<c path="String"/>
	</f>
	<meta><m n=":overload"/></meta>
</group></overloads>
		</group>
		<groupCount public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</groupCount>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.MatchResult"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Matcher" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Matcher.class" extern="1">
		<implements path="java.util.regex.MatchResult"/>
		<quoteReplacement public="1" set="method" static="1">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</quoteReplacement>
		<pattern public="1" set="method">
			<f a=""><c path="java.util.regex.Pattern"/></f>
			<meta><m n=":overload"/></meta>
		</pattern>
		<toMatchResult public="1" set="method">
			<f a=""><c path="java.util.regex.MatchResult"/></f>
			<meta><m n=":overload"/></meta>
		</toMatchResult>
		<usePattern public="1" set="method">
			<f a="param1">
				<c path="java.util.regex.Pattern"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</usePattern>
		<reset public="1" set="method">
			<f a=""><c path="java.util.regex.Matcher"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><reset public="1" set="method">
	<f a="param1">
		<c path="java.lang.CharSequence"/>
		<c path="java.util.regex.Matcher"/>
	</f>
	<meta><m n=":overload"/></meta>
</reset></overloads>
		</reset>
		<start public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><start public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</start></overloads>
		</start>
		<end public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><end public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</end></overloads>
		</end>
		<group public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
			<overloads>
				<group public="1" set="method">
					<f a="param1">
						<c path="String"/>
						<c path="String"/>
					</f>
					<meta><m n=":overload"/></meta>
				</group>
				<group public="1" set="method">
					<f a="param1">
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":overload"/></meta>
				</group>
			</overloads>
		</group>
		<groupCount public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</groupCount>
		<matches public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</matches>
		<find public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><find public="1" set="method">
	<f a="param1">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":overload"/></meta>
</find></overloads>
		</find>
		<lookingAt public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</lookingAt>
		<appendReplacement public="1" set="method">
			<f a="param1:param2">
				<c path="java.lang.StringBuffer"/>
				<c path="String"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendReplacement>
		<appendTail public="1" set="method">
			<f a="param1">
				<c path="java.lang.StringBuffer"/>
				<c path="java.lang.StringBuffer"/>
			</f>
			<meta><m n=":overload"/></meta>
		</appendTail>
		<replaceAll public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</replaceAll>
		<replaceFirst public="1" set="method">
			<f a="param1">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</replaceFirst>
		<region public="1" set="method">
			<f a="param1:param2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</region>
		<regionStart public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</regionStart>
		<regionEnd public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":overload"/></meta>
		</regionEnd>
		<hasTransparentBounds public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasTransparentBounds>
		<useTransparentBounds public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</useTransparentBounds>
		<hasAnchoringBounds public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hasAnchoringBounds>
		<useAnchoringBounds public="1" set="method">
			<f a="param1">
				<x path="Bool"/>
				<c path="java.util.regex.Matcher"/>
			</f>
			<meta><m n=":overload"/></meta>
		</useAnchoringBounds>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":overload"/></meta>
		</toString>
		<hitEnd public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</hitEnd>
		<requireEnd public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":overload"/></meta>
		</requireEnd>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Matcher"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_TreeInfo" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$TreeInfo.class" module="java.util.regex.Pattern" extern="1"><meta>
	<m n=":final"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.regex.Pattern$TreeInfo"</e></m>
</meta></class>
	<class path="java.util.regex.Pattern_Node" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Node.class" module="java.util.regex.Pattern" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.regex.Pattern$Node"</e></m>
</meta></class>
	<class path="java.util.regex.Pattern_CharProperty" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$CharProperty.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$CharProperty"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BmpCharProperty" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BmpCharProperty.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BmpCharProperty"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BitClass" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BitClass.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_BmpCharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BitClass"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_LastNode" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$LastNode.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$LastNode"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Start" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Start.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Start"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_StartS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$StartS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Start"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$StartS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Begin" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Begin.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Begin"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_End" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$End.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$End"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Caret" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Caret.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Caret"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_UnixCaret" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$UnixCaret.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$UnixCaret"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_LastMatch" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$LastMatch.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$LastMatch"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Dollar" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Dollar.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Dollar"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_UnixDollar" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$UnixDollar.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$UnixDollar"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SingleS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SingleS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SingleS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Single" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Single.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_BmpCharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Single"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SingleI" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SingleI.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_BmpCharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SingleI"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SingleU" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SingleU.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SingleU"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Block" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Block.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Block"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Script" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Script.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Script"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Category" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Category.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Category"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Utype" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Utype.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Utype"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Ctype" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Ctype.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_BmpCharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Ctype"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceNode" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceNode.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceNode"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Slice" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Slice.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceNode"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Slice"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceI" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceI.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceNode"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceI"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceU" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceU.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceNode"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceU"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceNode"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceIS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceIS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceNode"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceIS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_SliceUS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$SliceUS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_SliceIS"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$SliceUS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_All" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$All.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$All"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Dot" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Dot.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Dot"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_UnixDot" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$UnixDot.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$UnixDot"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Ques" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Ques.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Ques"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Curly" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Curly.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Curly"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_GroupCurly" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$GroupCurly.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$GroupCurly"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BranchConn" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BranchConn.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BranchConn"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Branch" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Branch.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Branch"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_GroupHead" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$GroupHead.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$GroupHead"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_GroupRef" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$GroupRef.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$GroupRef"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_GroupTail" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$GroupTail.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$GroupTail"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Prolog" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Prolog.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Prolog"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Loop" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Loop.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Loop"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_LazyLoop" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$LazyLoop.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Loop"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$LazyLoop"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BackRef" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BackRef.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BackRef"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_CIBackRef" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$CIBackRef.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$CIBackRef"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_First" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$First.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$First"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Conditional" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Conditional.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Conditional"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Pos" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Pos.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Pos"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Neg" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Neg.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Neg"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Behind" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Behind.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Behind"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BehindS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BehindS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Behind"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BehindS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_NotBehind" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$NotBehind.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$NotBehind"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_NotBehindS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$NotBehindS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_NotBehind"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$NotBehindS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_Bound" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$Bound.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$Bound"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BnM" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BnM.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_Node"/>
		<meta>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BnM"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_BnMS" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$BnMS.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_BnM"/>
		<meta>
			<m n=":final"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$BnMS"</e></m>
		</meta>
	</class>
	<class path="java.util.regex.Pattern_CharPropertyNames" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$CharPropertyNames.class" module="java.util.regex.Pattern" extern="1"><meta>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.regex.Pattern$CharPropertyNames"</e></m>
</meta></class>
	<class path="java.util.regex.Pattern_CharPropertyNames_CharPropertyFactory" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$CharPropertyNames$CharPropertyFactory.class" module="java.util.regex.Pattern" extern="1"><meta>
	<m n=":abstract"/>
	<m n=":javaNative"/>
	<m n=":native"><e>"java.util.regex.Pattern$CharPropertyNames$CharPropertyFactory"</e></m>
</meta></class>
	<class path="java.util.regex.Pattern_CharPropertyNames_CloneableProperty" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/regex/Pattern$CharPropertyNames$CloneableProperty.class" module="java.util.regex.Pattern" extern="1">
		<extends path="java.util.regex.Pattern_CharProperty"/>
		<implements path="java.lang.Cloneable"/>
		<clone public="1" set="method">
			<f a=""><c path="java.util.regex.Pattern_CharPropertyNames_CloneableProperty"/></f>
			<meta><m n=":overload"/></meta>
		</clone>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.regex.Pattern$CharPropertyNames$CloneableProperty"</e></m>
		</meta>
	</class>
	<class path="java.util.spi.LocaleNameProvider" params="" file="/home/tong/dev/haxelib/hxjava/3,0,0-rc,1/lib/hxjava-std.jar@java/util/spi/LocaleNameProvider.class" extern="1">
		<extends path="java.util.spi.LocaleServiceProvider"/>
		<getDisplayLanguage public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDisplayLanguage>
		<getDisplayScript public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDisplayScript>
		<getDisplayCountry public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDisplayCountry>
		<getDisplayVariant public="1" set="method">
			<f a="param1:param2">
				<c path="String"/>
				<c path="java.util.Locale"/>
				<c path="String"/>
			</f>
			<meta><m n=":overload"/></meta>
		</getDisplayVariant>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
		</new>
		<meta>
			<m n=":abstract"/>
			<m n=":javaNative"/>
			<m n=":native"><e>"java.util.spi.LocaleNameProvider"</e></m>
		</meta>
	</class>
	<class path="sys.io.Process" params="" file="/usr/lib/haxe/std/java/_std/sys/io/Process.hx">
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<proc><c path="java.lang.Process"/></proc>
		<getPid public="1" set="method" line="60"><f a=""><x path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="67"><f a=""><x path="Int"/></f></exitCode>
		<close public="1" set="method" line="79"><f a=""><x path="Void"/></f></close>
		<kill public="1" set="method" line="84"><f a=""><x path="Void"/></f></kill>
		<new public="1" set="method" line="39"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io._Process.ProcessInput" params="" file="/usr/lib/haxe/std/java/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="java.io.NativeInput"/>
		<chained><c path="haxe.io.BytesInput"/></chained>
		<bufferContents public="1" set="method" line="96"><f a=""><x path="Void"/></f></bufferContents>
		<readByte public="1" set="method" line="103" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="120" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="144" override="1"><f a=""><x path="Void"/></f></close>
	</class>
	<class path="sys.net.Host" params="" file="/usr/lib/haxe/std/java/_std/sys/net/Host.hx">
		<localhost public="1" set="method" line="50" static="1"><f a=""><c path="String"/></f></localhost>
		<ip public="1" set="null"><x path="Int"/></ip>
		<wrapped>
			<c path="java.net.InetAddress"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</wrapped>
		<toString public="1" set="method" line="40"><f a=""><c path="String"/></f></toString>
		<reverse public="1" set="method" line="45"><f a=""><c path="String"/></f></reverse>
		<new public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/lib/haxe/std/java/_std/sys/net/Socket.hx">
		<select public="1" set="method" line="166" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		[read] contains sockets on which we want to wait for available data to be read,
		[write] contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		[others] contains sockets on which we want to wait for exceptional conditions.
		[select] will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a [timeout] (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use [setBlocking(false)] or [setTimeout] to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use [setBlocking(false)] or [setTimeout] to prevent that.</haxe_doc>
		</output>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retreive your custom infos after a [select].
	*</haxe_doc>
		</custom>
		<sock><c path="java.net.Socket"/></sock>
		<server><c path="java.net.ServerSocket"/></server>
		<boundAddr><c path="java.net.SocketAddress"/></boundAddr>
		<create set="method" line="42"><f a=""><x path="Void"/></f></create>
		<close public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<read public="1" set="method" line="63">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.</haxe_doc>
		</read>
		<write public="1" set="method" line="68">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.</haxe_doc>
		</write>
		<connect public="1" set="method" line="73">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't sucessfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method" line="84">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use [accept()] to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method" line="92">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method" line="104">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method" line="113">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<peer public="1" set="method" line="123">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about the other side of a connected socket.</haxe_doc>
		</peer>
		<host public="1" set="method" line="133">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about our side of a connected socket.</haxe_doc>
		</host>
		<setTimeout public="1" set="method" line="142">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<waitForRead public="1" set="method" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setBlocking public="1" set="method" line="154">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediatly by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method" line="159">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediatly send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="xmpp.Attention" params="" file="../../xmpp/Attention.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<createXml public="1" get="inline" set="null" line="28" static="1"><f a=""><c path="Xml"/></f></createXml>
	</class>
	<class path="xmpp.Auth" params="" file="../../xmpp/Auth.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Auth"/>
</f></parse>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<digest public="1"><c path="String"/></digest>
		<resource public="1"><c path="String"/></resource>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?username:?password:?digest:?resource">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ extension used for inband account authentication.</haxe_doc>
	</class>
	<class path="xmpp.Bind" params="" file="../../xmpp/Bind.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Bind"/>
</f></parse>
		<resource public="1"><c path="String"/></resource>
		<jid public="1"><c path="String"/></jid>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="37"><f a="?resource:?jid">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[IQ extension used to bind a resource to a stream.
	http://xmpp.org/rfcs/rfc3920.html#bind">RFC3920#bind]]></haxe_doc>
	</class>
	<class path="xmpp.Packet" params="" file="../../xmpp/Packet.hx">
		<PROTOCOL public="1" set="null" line="29" static="1"><c path="String"/></PROTOCOL>
		<parse public="1" set="method" line="82" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses given XML into a XMPP packet object.</haxe_doc>
		</parse>
		<parseAttributes set="method" line="94" static="1">
			<f a="p:x">
				<c path="xmpp.Packet"/>
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses/adds basic attributes to the XMPP packet.</haxe_doc>
		</parseAttributes>
		<_type public="1" set="null">
			<e path="xmpp.PacketType"/>
			<haxe_doc>The top level type of the XMPP packet</haxe_doc>
		</_type>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<id public="1"><c path="String"/></id>
		<lang public="1"><c path="String"/></lang>
		<properties public="1"><c path="Array"><c path="Xml"/></c></properties>
		<errors public="1"><c path="Array"><c path="xmpp.Error"/></c></errors>
		<toXml public="1" set="method" line="52">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates/Returns the XML representation of this XMPP packet.</haxe_doc>
		</toXml>
		<toString public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Creates/Returns the string representation of this XMPP packet.</haxe_doc>
		</toString>
		<addAttributes set="method" line="66">
			<f a="x">
				<c path="Xml"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Adds the basic packet attributes to the given XML.</haxe_doc>
		</addAttributes>
		<new set="method" line="40"><f a="?to:?from:?id:?lang">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.Caps" params="" file="../../xmpp/Caps.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc></haxe_doc>
		</parse>
		<has public="1" set="method" line="83" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given xmpp packet has a caps property</haxe_doc>
		</has>
		<fromPresence public="1" set="method" line="101" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc>Extracts the caps information from given presence packet</haxe_doc>
		</fromPresence>
		<createVerfificationString public="1" set="method" line="111" static="1">
			<f a="identities:features:?dataform">
				<t path="Iterable"><t path="xmpp.disco.Identity"/></t>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<c path="String"/>
			</f>
			<haxe_doc>http://xmpp.org/extensions/xep-0115.html#ver</haxe_doc>
		</createVerfificationString>
		<sortIdentities set="method" line="149" static="1"><f a="a:b">
	<t path="xmpp.disco.Identity"/>
	<t path="xmpp.disco.Identity"/>
	<x path="Int"/>
</f></sortIdentities>
		<sortDataFormFields set="method" line="162" static="1"><f a="a:b">
	<c path="xmpp.dataform.Field"/>
	<c path="xmpp.dataform.Field"/>
	<x path="Int"/>
</f></sortDataFormFields>
		<sortString set="method" line="166" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></sortString>
		<hash public="1">
			<c path="String"/>
			<haxe_doc>The hashing algorithm used to generate the verification string, fe: sha-1.</haxe_doc>
		</hash>
		<node public="1">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application, typically a URL at the website
		of the project or company that produces the software</haxe_doc>
		</node>
		<ver public="1">
			<c path="String"/>
			<haxe_doc>A string that is used to verify the identity and supported features of the entity</haxe_doc>
		</ver>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>A set of nametokens specifying additional feature bundles.
		This attribute is deprecated!</haxe_doc>
		</ext>
		<toXml public="1" set="method" line="64"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="57"><f a="hash:node:ver:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="xmpp.DataForm" params="" file="../../xmpp/DataForm.hx">
		<XMLNS public="1" set="null" line="34" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.DataForm"/>
</f></parse>
		<type public="1"><e path="xmpp.dataform.FormType"/></type>
		<title public="1"><c path="String"/></title>
		<instructions public="1"><c path="String"/></instructions>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<reported public="1"><c path="xmpp.dataform.Reported"/></reported>
		<items public="1"><c path="Array"><c path="xmpp.dataform.Item"/></c></items>
		<toXml public="1" set="method" line="49"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="43"><f a="?type">
	<e path="xmpp.dataform.FormType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>DataForm packet extension (for iq and message packets).

	XEP-0004: Data Forms: http://xmpp.org/extensions/xep-0004.html</haxe_doc>
	</class>
	<class path="xmpp.DateTime" params="" file="../../xmpp/DateTime.hx">
		<EREG_DATE public="1" line="35" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC date expression.
		CCYY-MM-DDThh:mm:ss[.sss]TZD</haxe_doc>
		</EREG_DATE>
		<EREG_TIME public="1" line="41" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC time expression.
		hh:mm:ss[.sss][TZD]</haxe_doc>
		</EREG_TIME>
		<isValidDate public="1" get="inline" set="null" line="43" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidDate>
		<isValidTime public="1" get="inline" set="null" line="47" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidTime>
		<now public="1" get="inline" set="null" line="54" static="1">
			<f a="?offset">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the current time as UTC formatted string</haxe_doc>
		</now>
		<fromDate public="1" get="inline" set="null" line="61" static="1">
			<f a="d:?offset">
				<c path="Date"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromDate>
		<fromTime public="1" get="inline" set="null" line="68" static="1">
			<f a="t:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromTime>
		<toDate public="1" set="method" line="79" static="1">
			<f a="utc:?tzo">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc><![CDATA[Create a Date object from a UTC time string

		//TODO this offset thing will fail!
		// TODO 24+ -> 0
		//untested!]]></haxe_doc>
		</toDate>
		<utc public="1" set="method" line="105" static="1">
			<f a="t:?offset">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Formats a (regular) date string to a XMPP compatible UTC date string (CCYY-MM-DDThh:mm:ss[.sss]TZD)
		For example: 2008-11-01 18:45:47 gets 2008-11-01T18:45:47Z
		Optionally a timezone offset could be attached.</haxe_doc>
		</utc>
		<getParts public="1" set="method" line="152" static="1">
			<f a="utc">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Return the parts of a UTC time string
		//TODO include tzo</haxe_doc>
		</getParts>
		<getTZOValue public="1" set="method" line="170" static="1">
			<f a="tzo">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the given TZO as integer value</haxe_doc>
		</getTZOValue>
		<getTimeValue public="1" set="method" line="177" static="1"><f a="t">
	<c path="String"/>
	<x path="Int"/>
</f></getTimeValue>
		<haxe_doc>Standardization of ISO 8601 profiles and their lexical representation.

	XMPP Date and Time Profiles: http://xmpp.org/extensions/xep-0082.html</haxe_doc>
	</class>
	<class path="xmpp.EntityTime" params="" file="../../xmpp/EntityTime.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="78" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.EntityTime"/>
</f></parse>
		<utc public="1">
			<c path="String"/>
			<haxe_doc>The UTC time according to the responding entity.
		 The format conforms to the dateTime profile specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html)
		 and MUST be expressed in UTC.</haxe_doc>
		</utc>
		<tzo public="1">
			<c path="String"/>
			<haxe_doc>The entity's numeric time zone offset from UTC.
		The format conforms to the Time Zone Definition (TZD) specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html).
		Example: +02:00</haxe_doc>
		</tzo>
		<toXml public="1" set="method" line="70"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="48"><f a="?utc:?tzo">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<typedef path="xmpp.ApplicationErrorCondition" params="" file="../../xmpp/ErrorPacket.hx" module="xmpp.ErrorPacket"><a>
	<xmlns><c path="String"/></xmlns>
	<condition><c path="String"/></condition>
</a></typedef>
	<enum path="xmpp.ErrorType" params="" file="../../xmpp/ErrorType.hx">
		<auth><haxe_doc>Retry after providing credentials</haxe_doc></auth>
		<cancel><haxe_doc>Do not retry (the error is unrecoverable)</haxe_doc></cancel>
		<continue_><haxe_doc>Proceed (the condition was only a warning)</haxe_doc></continue_>
		<modify><haxe_doc>Retry after changing the data sent</haxe_doc></modify>
		<wait><haxe_doc>Retry after waiting (the error is temporary)</haxe_doc></wait>
	</enum>
	<class path="xmpp.HXR" params="" file="../../xmpp/HXR.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<create public="1" set="method" line="33" static="1">
			<f a="?d">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</create>
		<getData public="1" get="inline" set="null" line="42" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</getData>
		<haxe_doc>Haxe/XMPP remoting extension</haxe_doc>
	</class>
	<class path="xmpp.IQ" params="" file="../../xmpp/IQ.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="82" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.IQ"/>
</f></parse>
		<createQueryXml public="1" set="method" line="105" static="1">
			<f a="ns:?name">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc><![CDATA[Creates a '<query xmlns="namspace"/>' XML tag]]></haxe_doc>
		</createQueryXml>
		<createResult public="1" get="inline" set="null" line="114" static="1">
			<f a="iq:?from">
				<c path="xmpp.IQ"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a result type IQ from the given request</haxe_doc>
		</createResult>
		<createError public="1" set="method" line="121" static="1">
			<f a="iq:?errors:?from">
				<c path="xmpp.IQ"/>
				<c path="Array"><c path="xmpp.Error"/></c>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a error type IQ packet from given request</haxe_doc>
		</createError>
		<type public="1">
			<e path="xmpp.IQType"/>
			<haxe_doc>Either: get/set/result/error</haxe_doc>
		</type>
		<x public="1">
			<t path="xmpp.PacketElement"/>
			<haxe_doc>The exclusive child of the IQ packet</haxe_doc>
		</x>
		<toXml public="1" set="method" line="74" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="66"><f a="?type:?id:?to:?from">
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[InfoQuery XMPP packet

	Info/Query, or IQ, is a "request-response" mechanism, similar in some ways to the Hypertext Transfer Protocol [HTTP].
	The semantics of IQ enable an entity to make a request of, and receive a response from, another entity.
	The data content of the request and response is defined by the schema or other structural definition associated with the XML namespace that qualifies the direct child element of the IQ element,
	and the interaction is tracked by the requesting entity through use of the 'id' attribute. Thus, IQ interactions follow a common pattern of structured data exchange such as get/result or set/result (although an error can be returned in reply to a request if appropriate)

	Requesting                  Responding
	  Entity                      Entity
	----------                  ----------
	    |                            |
	    | <iq id='1' type='get'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='1' type='result'>  |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |
	    | <iq id='2' type='set'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='2' type='error'>   |
	    |   [ ... condition ... ]    |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |]]></haxe_doc>
	</class>
	<enum path="xmpp.IQType" params="" file="../../xmpp/IQType.hx">
		<get/>
		<set/>
		<result/>
		<error/>
	</enum>
	<class path="xmpp.LOP" params="" file="../../xmpp/LOP.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.LastActivity" params="" file="../../xmpp/LastActivity.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.LastActivity"/>
</f></parse>
		<parseSeconds public="1" get="inline" set="null" line="50" static="1">
			<f a="x">
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Parses/Returns the time value of the given IQ query xml.</haxe_doc>
		</parseSeconds>
		<seconds public="1"><x path="Int"/></seconds>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="33"><f a="?seconds">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="xmpp.MUC" params="" file="../../xmpp/MUC.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.MUCAdmin" params="" file="../../xmpp/MUCAdmin.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCAdmin"/>
</f></parse>
		<items public="1"><c path="Array"><c path="xmpp.muc.Item"/></c></items>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCOwner" params="" file="../../xmpp/MUCOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<items public="1"><c path="List"><c path="xmpp.muc.Item"/></c></items>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCUser" params="" file="../../xmpp/MUCUser.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCUser"/>
</f></parse>
		<decline public="1"><c path="xmpp.muc.Decline"/></decline>
		<destroy public="1"><c path="xmpp.muc.Destroy"/></destroy>
		<invite public="1"><c path="xmpp.muc.Invite"/></invite>
		<item public="1"><c path="xmpp.muc.Item"/></item>
		<password public="1"><c path="String"/></password>
		<status public="1"><c path="xmpp.muc.Status"/></status>
		<toXml public="1" set="method" line="44"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Message" params="" file="../../xmpp/Message.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="60" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Message"/>
</f></parse>
		<type public="1">
			<e path="xmpp.MessageType"/>
			<haxe_doc></haxe_doc>
		</type>
		<body public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</body>
		<subject public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</subject>
		<thread public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</thread>
		<toXml public="1" set="method" line="50" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?to:?body:?subject:?type:?thread:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.MessageType"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XMPP message packet.</haxe_doc>
	</class>
	<enum path="xmpp.MessageType" params="" file="../../xmpp/MessageType.hx">
		<normal/>
		<error/>
		<chat/>
		<groupchat/>
		<headline/>
		<haxe_doc></haxe_doc>
	</enum>
	<typedef path="xmpp.PacketElement" params="" file="../../xmpp/PacketElement.hx"><a><toXml set="method"><f a=""><c path="Xml"/></f></toXml></a></typedef>
	<typedef path="xmpp.PacketFilter" params="" file="../../xmpp/PacketFilter.hx"><a><accept set="method">
	<f a="packet">
		<c path="xmpp.Packet"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Returns true if the given XMPP packet passes through this filter.</haxe_doc>
</accept></a></typedef>
	<enum path="xmpp.PacketType" params="" file="../../xmpp/PacketType.hx">
		<iq><haxe_doc></haxe_doc></iq>
		<message><haxe_doc></haxe_doc></message>
		<presence><haxe_doc></haxe_doc></presence>
		<custom><haxe_doc></haxe_doc></custom>
		<haxe_doc>Core XMPP packet types.</haxe_doc>
	</enum>
	<class path="xmpp.PersonalEvent" params="" file="../../xmpp/PersonalEvent.hx">
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<xmlns public="1" set="null"><c path="String"/></xmlns>
		<getNode public="1" set="method" line="41">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the (subclass) namespace.</haxe_doc>
		</getNode>
		<empty public="1" set="method" line="48">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns a empty XML node for disabling the personal event.</haxe_doc>
		</empty>
		<toXml public="1" set="method" line="52"><f a=""><c path="Xml"/></f></toXml>
		<new set="method" line="33"><f a="nodeName:xmlns">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for personal event classes.
	The implementing class HAS TO HAVE a static XMLNS field (required by jabber.PersonalEventListener)!</haxe_doc>
	</class>
	<class path="xmpp.Ping" params="" file="../../xmpp/Ping.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<xml public="1" line="29" static="1"><c path="Xml"/></xml>
		<haxe_doc><![CDATA[<a href="http://www.xmpp.org/extensions/xep-0199.html">XEP 199 - XMPP Ping</a>]]></haxe_doc>
	</class>
	<class path="xmpp.PlainPacket" params="" file="../../xmpp/PlainPacket.hx">
		<extends path="xmpp.Packet"/>
		<src public="1">
			<c path="Xml"/>
			<haxe_doc>Plain XML content of the packet.</haxe_doc>
		</src>
		<toXml public="1" get="inline" set="null" line="40" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="src">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Plain/Custom XMPP packet.</haxe_doc>
	</class>
	<class path="xmpp.Presence" params="" file="../../xmpp/Presence.hx">
		<extends path="xmpp.Packet"/>
		<MAX_STATUS_SIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_STATUS_SIZE>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Presence"/>
</f></parse>
		<type public="1"><e path="xmpp.PresenceType"/></type>
		<show public="1"><e path="xmpp.PresenceShow"/></show>
		<status public="1" set="accessor"><c path="String"/></status>
		<priority public="1"><t path="Null"><x path="Int"/></t></priority>
		<set_status set="method" line="46"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_status>
		<toXml public="1" set="method" line="52" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="37"><f a="?show:?status:?priority:?type">
	<e path="xmpp.PresenceShow"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>RFC-3921 - Instant Messaging and Presence: http://xmpp.org/rfcs/rfc3921.html
	Exchanging Presence Information: http://www.xmpp.org/rfcs/rfc3921.html#presence</haxe_doc>
	</class>
	<enum path="xmpp.PresenceShow" params="" file="../../xmpp/PresenceShow.hx">
		<chat><haxe_doc>Especially socialable</haxe_doc></chat>
		<away><haxe_doc>Away from device</haxe_doc></away>
		<xa><haxe_doc>Extended Away</haxe_doc></xa>
		<dnd><haxe_doc>Busy</haxe_doc></dnd>
		<haxe_doc>Four elements, which provide insights into a human users availbility
	for and interest in communication.</haxe_doc>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="xmpp.PresenceType" params="" file="../../xmpp/PresenceType.hx">
		<error/>
		<probe/>
		<subscribe/>
		<subscribed/>
		<unavailable/>
		<unsubscribe/>
		<unsubscribed/>
	</enum>
	<class path="xmpp.PrivacyList" params="" file="../../xmpp/PrivacyList.hx">
		<parse public="1" set="method" line="42" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyList"/>
</f></parse>
		<name public="1"><c path="String"/></name>
		<items public="1"><c path="Array"><c path="xmpp.privacylist.Item"/></c></items>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PrivacyLists" params="" file="../../xmpp/PrivacyLists.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="59" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyLists"/>
</f></parse>
		<active public="1"><c path="String"/></active>
		<_default public="1"><c path="String"/></_default>
		<lists public="1"><c path="Array"><c path="xmpp.PrivacyList"/></c></lists>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<iterator public="1" get="inline" set="null" line="55"><f a=""><t path="Iterator"><c path="xmpp.PrivacyList"/></t></f></iterator>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.PrivateStorage" params="" file="../../xmpp/PrivateStorage.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivateStorage"/>
</f></parse>
		<name public="1"><c path="String"/></name>
		<namespace public="1"><c path="String"/></namespace>
		<data public="1"><c path="Xml"/></data>
		<toXml public="1" set="method" line="40"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="name:namespace:?data">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PubSub" params="" file="../../xmpp/PubSub.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="90" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSub"/>
</f></parse>
		<subscribe public="1"><a>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></subscribe>
		<options public="1"><c path="xmpp.pubsub.Options"/></options>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<create public="1"><c path="String"/></create>
		<configure public="1"><c path="xmpp.DataForm"/></configure>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<publish public="1"><c path="xmpp.pubsub.Publish"/></publish>
		<retract public="1"><c path="xmpp.pubsub.Retract"/></retract>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<unsubscribe public="1"><a>
	<subid><c path="String"/></subid>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></unsubscribe>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubEvent" params="" file="../../xmpp/PubSubEvent.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubEvent"/>
</f></parse>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<configuration public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configuration>
		<delete public="1"><c path="String"/></delete>
		<purge public="1"><c path="String"/></purge>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubOwner" params="" file="../../xmpp/PubSubOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubOwner"/>
</f></parse>
		<delete public="1">
			<c path="String"/>
			<haxe_doc>Set to "" (empty string) to add a empty delete element</haxe_doc>
		</delete>
		<purge public="1"><c path="String"/></purge>
		<configure public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configure>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<_default public="1"><a>
	<form><c path="xmpp.DataForm"/></form>
	<empty><x path="Bool"/></empty>
</a></_default>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Register" params="" file="../../xmpp/Register.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="96" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Register"/>
</f></parse>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<email public="1"><c path="String"/></email>
		<name public="1"><c path="String"/></name>
		<nick public="1"><c path="String"/></nick>
		<first public="1"><c path="String"/></first>
		<last public="1"><c path="String"/></last>
		<address public="1"><c path="String"/></address>
		<city public="1"><c path="String"/></city>
		<state public="1"><c path="String"/></state>
		<zip public="1"><c path="String"/></zip>
		<phone public="1"><c path="String"/></phone>
		<url public="1"><c path="String"/></url>
		<date public="1"><c path="String"/></date>
		<misc public="1"><c path="String"/></misc>
		<text public="1"><c path="String"/></text>
		<key public="1"><c path="String"/></key>
		<registered public="1"><x path="Bool"/></registered>
		<remove public="1"><x path="Bool"/></remove>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="61"><f a=""><c path="Xml"/></f></toXml>
		<createElement set="method" line="88"><f a="x:id">
	<c path="Xml"/>
	<c path="String"/>
	<c path="Xml"/>
</f></createElement>
		<new public="1" set="method" line="53"><f a="?username:?password:?email:?name">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration</haxe_doc>
	</class>
	<class path="xmpp.Roster" params="" file="../../xmpp/Roster.hx">
		<extends path="List"><c path="xmpp.roster.Item"/></extends>
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Roster"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?items">
	<t path="Iterable"><c path="xmpp.roster.Item"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ roster extension.</haxe_doc>
	</class>
	<class path="xmpp.SASL" params="" file="../../xmpp/SASL.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<EREG_FAILURE public="1" line="32" static="1"><c path="EReg"/></EREG_FAILURE>
		<createAuth public="1" set="method" line="36" static="1">
			<f a="mech:?text">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createAuth>
		<createResponse public="1" set="method" line="47" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createResponse>
		<parseMechanisms public="1" set="method" line="58" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Parses list of SASL mechanisms.</haxe_doc>
		</parseMechanisms>
		<haxe_doc>Static methods for creation/manipulation of SASL XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.SoftwareVersion" params="" file="../../xmpp/SoftwareVersion.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="56" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.SoftwareVersion"/>
</f></parse>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity</haxe_doc>
		</os>
		<toXml public="1" set="method" line="48"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="42"><f a="?name:?version:?os">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="xmpp.Stream" params="" file="../../xmpp/Stream.hx">
		<STREAM public="1" set="null" line="29" static="1"><c path="String"/></STREAM>
		<CLIENT public="1" set="null" line="30" static="1"><c path="String"/></CLIENT>
		<SERVER public="1" set="null" line="31" static="1"><c path="String"/></SERVER>
		<createOpenXml public="1" set="method" line="39" static="1">
			<f a="ns:to:?version:?lang:?header">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Creates the opening XML tag of a XMPP stream.</haxe_doc>
		</createOpenXml>
		<haxe_doc>Static stuff for creation/manipulation of XMPP stream opening/closing tags.</haxe_doc>
	</class>
	<class path="xmpp.UserSearch" params="" file="../../xmpp/UserSearch.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="62" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.UserSearch"/>
</f></parse>
		<getFieldValue set="method" line="88" static="1"><f a="x">
	<c path="Xml"/>
	<c path="String"/>
</f></getFieldValue>
		<instructions public="1"><c path="String"/></instructions>
		<first public="1"><c path="String"/></first>
		<last public="1"><c path="String"/></last>
		<nick public="1"><c path="String"/></nick>
		<email public="1"><c path="String"/></email>
		<items public="1"><c path="Array"><t path="xmpp.UserSearchItem"/></c></items>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="xmpp.UserSearchItem" params="" file="../../xmpp/UserSearchItem.hx"><a>
	<nick><c path="String"/></nick>
	<last><c path="String"/></last>
	<jid><c path="String"/></jid>
	<first><c path="String"/></first>
	<email><c path="String"/></email>
</a></typedef>
	<class path="xmpp.VCardTemp" params="" file="../../xmpp/VCardTemp.hx">
		<XMLNS public="1" set="null" line="42" static="1"><c path="String"/></XMLNS>
		<PROD_ID public="1" set="null" line="43" static="1"><c path="String"/></PROD_ID>
		<VERSION public="1" set="null" line="44" static="1"><c path="String"/></VERSION>
		<hasPhoto public="1" set="method" line="153" static="1">
			<f a="vc">
				<c path="xmpp.VCardTemp"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given vcard has a photo attached (all xmpp.vcard.Photo).</haxe_doc>
		</hasPhoto>
		<emptyXml public="1" set="method" line="158" static="1"><f a=""><c path="Xml"/></f></emptyXml>
		<parse public="1" set="method" line="167" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.VCardTemp"/>
</f></parse>
		<parsePhoto set="method" line="306" static="1"><f a="x">
	<c path="Xml"/>
	<t path="xmpp.vcard.Photo"/>
</f></parsePhoto>
		<fn public="1"><c path="String"/></fn>
		<n public="1"><t path="xmpp.vcard.Name"/></n>
		<nickname public="1"><c path="String"/></nickname>
		<photo public="1"><t path="xmpp.vcard.Photo"/></photo>
		<birthday public="1"><c path="String"/></birthday>
		<addresses public="1"><c path="Array"><t path="xmpp.vcard.Address"/></c></addresses>
		<tels public="1"><c path="Array"><t path="xmpp.vcard.Tel"/></c></tels>
		<email public="1"><t path="xmpp.vcard.EMail"/></email>
		<jid public="1"><c path="String"/></jid>
		<tz public="1"><c path="String"/></tz>
		<geo public="1"><t path="xmpp.vcard.Geo"><x path="Float"/></t></geo>
		<title public="1"><c path="String"/></title>
		<role public="1"><c path="String"/></role>
		<org public="1"><t path="xmpp.vcard.Org"/></org>
		<url public="1"><c path="String"/></url>
		<desc public="1"><c path="String"/></desc>
		<toXml public="1" set="method" line="68"><f a=""><c path="Xml"/></f></toXml>
		<addXmlField set="method" line="144"><f a="n:x:?name">
	<c path="String"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></addXmlField>
		<new public="1" set="method" line="63"><f a=""><x path="Void"/></f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html
	RFC2426: http://tools.ietf.org/html/rfc2426

	Depricated! Replaced by XEP0292 (see xmpp.VCard).
	This is just a subset of RFC2426!</haxe_doc>
	</class>
	<class path="xmpp.X" params="" file="../../xmpp/X.hx"><create public="1" set="method" line="28" static="1"><f a="ns:?childs">
	<c path="String"/>
	<t path="Iterable"><c path="Xml"/></t>
	<c path="Xml"/>
</f></create></class>
	<class path="xmpp.XMLUtil" params="" file="../../xmpp/XMLUtil.hx">
		<createElement public="1" set="method" line="33" static="1">
			<f a="n:t">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param n Name of xml element to create
		@param t Node content</haxe_doc>
		</createElement>
		<addElement public="1" get="inline" set="null" line="44" static="1">
			<f a="x:name:content">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param n Name of xml node
		@param t Node content</haxe_doc>
		</addElement>
		<addField public="1" set="method" line="56" static="1">
			<f a="x:o:n:?required">
				<c path="Xml"/>
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the element to
		@param o The target object, provider of value
		@param n Name of XML node
		@param t Node content</haxe_doc>
		</addField>
		<addFields public="1" set="method" line="69" static="1">
			<f a="x:o:?fields">
				<c path="Xml"/>
				<d/>
				<t path="Iterable"><c path="String"/></t>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param o The target object to retrieve the field values from
		@param fields Optional names of fields, gets reflected if null</haxe_doc>
		</addFields>
		<reflectElements public="1" params="T" set="method" line="78" static="1">
			<f a="target:x">
				<c path="reflectElements.T"/>
				<c path="Xml"/>
				<c path="reflectElements.T"/>
			</f>
			<haxe_doc>TODO use?</haxe_doc>
		</reflectElements>
		<ns public="1" set="method" line="90" static="1">
			<f a="x:?ns">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get (if no ns specified) or set the namespace of the given xml element.

		@param x XML element to attach the create element to
		@param ns Optional namespace to set</haxe_doc>
		</ns>
		<setNamespace public="1" get="inline" set="null" line="100" static="1">
			<f a="x:s">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Hack because flash is unable to set xml namespace (since haxe 2.06) //TODO</haxe_doc>
		</setNamespace>
		<haxe_doc>XML utilities.</haxe_doc>
	</class>
	<class path="xmpp.dataform.Field" params="" file="../../xmpp/dataform/Field.hx">
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Field"/>
</f></parse>
		<parseFields public="1" set="method" line="74" static="1">
			<f a="t:x">
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
				<c path="Xml"/>
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
			</f>
			<haxe_doc>Parses all dataform fields into the given dataform field container.</haxe_doc>
		</parseFields>
		<label public="1"><c path="String"/></label>
		<type public="1"><e path="xmpp.dataform.FieldType"/></type>
		<variable public="1"><c path="String"/></variable>
		<desc public="1"><c path="String"/></desc>
		<required public="1"><x path="Bool"/></required>
		<values public="1"><c path="Array"><c path="String"/></c></values>
		<options public="1"><c path="Array"><c path="xmpp.dataform.FieldOption"/></c></options>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="36"><f a="?type">
	<e path="xmpp.dataform.FieldType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.FieldOption" params="" file="../../xmpp/dataform/FieldOption.hx">
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.FieldOption"/>
</f></parse>
		<label public="1"><c path="String"/></label>
		<value public="1"><c path="String"/></value>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?label:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.dataform.FieldType" params="" file="../../xmpp/dataform/FieldType.hx">
		<boolean><haxe_doc>The field enables an entity to gather or provide an either-or choice between two options.
		The default value is "false".</haxe_doc></boolean>
		<fixed><haxe_doc><![CDATA[The field is intended for data description (e.g., human-readable text such as "section" headers) rather than data gathering or provision.
		The <value/> child SHOULD NOT contain newlines (the \n and \r characters);
		instead an application SHOULD generate multiple fixed fields, each with one <value/> child.]]></haxe_doc></fixed>
		<hidden><haxe_doc>The field is not shown to the form-submitting entity, but instead is returned with the form.
		The form-submitting entity SHOULD NOT modify the value of a hidden field, 
		but MAY do so if such behavior is defined for the "using protocol".</haxe_doc></hidden>
		<jid_multi><haxe_doc>The field enables an entity to gather or provide multiple Jabber IDs.
		Each provided JID SHOULD be unique (as determined by comparison that includes application of the Nodeprep, Nameprep, and Resourceprep profiles of Stringprep as specified in XMPP Core),
		and duplicate JIDs MUST be ignored.</haxe_doc></jid_multi>
		<jid_single><haxe_doc>The field enables an entity to gather or provide a single Jabber ID.</haxe_doc></jid_single>
		<list_multi><haxe_doc>The field enables an entity to gather or provide one or more options from among many.
		A form-submitting entity chooses one or more items from among the options presented by the form-processing entity and MUST NOT insert new options.
		The form-submitting entity MUST NOT modify the order of items as received from the form-processing entity,
		since the order of items MAY be significant.</haxe_doc></list_multi>
		<list_single><haxe_doc>The field enables an entity to gather or provide one option from among many.
		A form-submitting entity chooses one item from among the options presented by the form-processing entity and MUST NOT insert new options.</haxe_doc></list_single>
		<text_multi><haxe_doc>The field enables an entity to gather or provide multiple lines of text.</haxe_doc></text_multi>
		<text_private><haxe_doc>The field enables an entity to gather or provide a single line or word of text,
		which shall be obscured in an interface (e.g., with multiple instances of the asterisk character).</haxe_doc></text_private>
		<text_single><haxe_doc>The field enables an entity to gather or provide a single line or word of text, which may be shown in an interface.
		This field type is the default and MUST be assumed if a form-submitting entity receives a field type it does not understand.</haxe_doc></text_single>
	</enum>
	<enum path="xmpp.dataform.FormType" params="" file="../../xmpp/dataform/FormType.hx">
		<cancel><haxe_doc>The form-submitting entity has cancelled submission of data to the form-processing entity.</haxe_doc></cancel>
		<form><haxe_doc>The form-processing entity is asking the form-submitting entity to complete a form.</haxe_doc></form>
		<result><haxe_doc>The form-processing entity is returning data (e.g., search results) to the form-submitting entity,
		or the data is a generic data set.</haxe_doc></result>
		<submit><haxe_doc>The form-submitting entity is submitting data to the form-processing entity.
		The submission MAY include fields that were not provided in the empty form,
		but the form-processing entity MUST ignore any fields that it does not understand.</haxe_doc></submit>
	</enum>
	<class path="xmpp.dataform.Item" params="" file="../../xmpp/dataform/Item.hx">
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Item"/>
</f></parse>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<toXml public="1" set="method" line="32"><f a=""><c path="Xml"/></f></toXml>
		<createXml set="method" line="36"><f a="n">
	<c path="String"/>
	<c path="Xml"/>
</f></createXml>
		<new public="1" set="method" line="28"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.Reported" params="" file="../../xmpp/dataform/Reported.hx">
		<extends path="xmpp.dataform.Item"/>
		<parse public="1" get="inline" set="null" line="34" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Reported"/>
</f></parse>
		<toXml public="1" set="method" line="30" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="26"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="xmpp.disco.Identity" params="" file="../../xmpp/disco/Identity.hx"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></typedef>
	<class path="xmpp.disco.Info" params="" file="../../xmpp/disco/Info.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Info"/>
</f></parse>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<features public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>List of features/namespaces</haxe_doc>
		</features>
		<node public="1">
			<c path="String"/>
			<haxe_doc>Specific node</haxe_doc>
		</node>
		<x public="1">
			<c path="Xml"/>
			<haxe_doc>Dataform</haxe_doc>
		</x>
		<toXml public="1" set="method" line="46"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="40"><f a="?identities:?features:?node">
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Item" params="" file="../../xmpp/disco/Item.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Item"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<name public="1"><c path="String"/></name>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="jid:?name:?node">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Items" params="" file="../../xmpp/disco/Items.hx">
		<extends path="List"><c path="xmpp.disco.Item"/></extends>
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Items"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.filter.IQFilter" params="" file="../../xmpp/filter/IQFilter.hx">
		<xmlns public="1"><c path="String"/></xmlns>
		<node public="1"><c path="String"/></node>
		<type public="1"><e path="xmpp.IQType"/></type>
		<accept public="1" set="method" line="39">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="?xmlns:?type:?node">
	<c path="String"/>
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters IQ packets: namespace/nodename/iqtype</haxe_doc>
	</class>
	<class path="xmpp.filter.MessageFilter" params="" file="../../xmpp/filter/MessageFilter.hx">
		<type public="1"><e path="xmpp.MessageType"/></type>
		<accept public="1" set="method" line="38">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="?type">
	<e path="xmpp.MessageType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters message packets, optional including xmpp.MessageType.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromContainsFilter" params="" file="../../xmpp/filter/PacketFromContainsFilter.hx">
		<contains public="1" set="accessor"><c path="String"/></contains>
		<ereg><c path="EReg"/></ereg>
		<set_contains set="method" line="37"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_contains>
		<accept public="1" set="method" line="42">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="33"><f a="contains">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets where the from attribute contains the given string.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromFilter" params="" file="../../xmpp/filter/PacketFromFilter.hx">
		<jid public="1"><c path="String"/></jid>
		<accept public="1" get="inline" set="null" line="35"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Bool"/>
</f></accept>
		<new public="1" set="method" line="31"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching 'from' attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketIDFilter" params="" file="../../xmpp/filter/PacketIDFilter.hx">
		<id public="1"><c path="String"/></id>
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching id attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketNameFilter" params="" file="../../xmpp/filter/PacketNameFilter.hx">
		<expr public="1"><c path="EReg"/></expr>
		<accept public="1" set="method" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="expr">
	<c path="EReg"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters (just) custom XMPP packets with given nodename expression.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketPropertyFilter" params="" file="../../xmpp/filter/PacketPropertyFilter.hx">
		<ns public="1"><c path="String"/></ns>
		<name public="1"><c path="String"/></name>
		<accept public="1" set="method" line="36">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="ns:?name">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.filter.PacketTypeFilter" params="" file="../../xmpp/filter/PacketTypeFilter.hx">
		<type public="1"><e path="xmpp.PacketType"/></type>
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<new public="1" set="method" line="31"><f a="type">
	<e path="xmpp.PacketType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters packets with matching xmpp.PacketType.</haxe_doc>
	</class>
	<typedef path="xmpp.lop.Binding" params="" file="../../xmpp/lop/Binding.hx"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
	<datatype><c path="String"/></datatype>
</a></typedef>
	<class path="xmpp.lop.Bindings" params="" file="../../xmpp/lop/Bindings.hx">
		<extends path="List"><t path="xmpp.lop.Binding"/></extends>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Bindings"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Ping" params="" file="../../xmpp/lop/Ping.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Ping"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<job_id public="1"><c path="String"/></job_id>
		<status public="1"><c path="String"/></status>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="vm_id:?job_id:?status">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.SpawnVM" params="" file="../../xmpp/lop/SpawnVM.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.SpawnVM"/>
</f></parse>
		<species public="1"><c path="String"/></species>
		<id public="1"><c path="String"/></id>
		<password public="1"><c path="String"/></password>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="species:?id:?password">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Submit" params="" file="../../xmpp/lop/Submit.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Submit"/>
</f></parse>
		<id public="1"><c path="String"/></id>
		<code public="1"><c path="String"/></code>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="id:?code">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Terminate" params="" file="../../xmpp/lop/Terminate.hx">
		<parse public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Terminate"/>
</f></parse>
		<vm_id public="1"><c path="String"/></vm_id>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.muc.Affiliation" params="" file="../../xmpp/muc/Affiliation.hx">
		<none/>
		<owner/>
		<admin/>
		<member/>
		<outcast/>
		<haxe_doc>Long-lived association or connection with a room.
	Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Decline" params="" file="../../xmpp/muc/Decline.hx">
		<parse public="1" set="method" line="50" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Decline"/>
</f></parse>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<reason public="1"><c path="String"/></reason>
		<nodeName><c path="String"/></nodeName>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="35"><f a="?reason:?to:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Destroy" params="" file="../../xmpp/muc/Destroy.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Destroy"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<reason public="1"><c path="String"/></reason>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="?jid:?reason">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Invite" params="" file="../../xmpp/muc/Invite.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Invite"/>
</f></parse>
		<to public="1"><c path="String"/></to>
		<from public="1"><c path="String"/></from>
		<reason public="1"><c path="String"/></reason>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="to:?reason:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Item" params="" file="../../xmpp/muc/Item.hx">
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Item"/>
</f></parse>
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<nick public="1"><c path="String"/></nick>
		<jid public="1"><c path="String"/></jid>
		<actor public="1"><c path="String"/></actor>
		<reason public="1"><c path="String"/></reason>
		<continue_ public="1"><c path="String"/></continue_>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="38"><f a="?affiliation:?role:?nick:?jid">
	<e path="xmpp.muc.Affiliation"/>
	<e path="xmpp.muc.Role"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<enum path="xmpp.muc.Role" params="" file="../../xmpp/muc/Role.hx">
		<none/>
		<visitor/>
		<participant/>
		<moderator/>
		<haxe_doc>Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Status" params="" file="../../xmpp/muc/Status.hx">
		<MYSELF public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></MYSELF>
		<ROOMNICK_CHANGED public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></ROOMNICK_CHANGED>
		<WAITS_FOR_UNLOCK public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></WAITS_FOR_UNLOCK>
		<parse public="1" get="inline" set="null" line="42" static="1"><f a="x">
	<a><get set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get></a>
	<c path="xmpp.muc.Status"/>
</f></parse>
		<code public="1"><x path="Int"/></code>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.Action" params="" file="../../xmpp/privacylist/Action.hx">
		<allow/>
		<deny/>
	</enum>
	<class path="xmpp.privacylist.Item" params="" file="../../xmpp/privacylist/Item.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.privacylist.Item"/>
</f></parse>
		<type public="1"><e path="xmpp.privacylist.ItemType"/></type>
		<action public="1"><e path="xmpp.privacylist.Action"/></action>
		<value public="1"><c path="String"/></value>
		<order public="1"><x path="Int"/></order>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="action:?type:?value:?order">
	<e path="xmpp.privacylist.Action"/>
	<e path="xmpp.privacylist.ItemType"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.ItemType" params="" file="../../xmpp/privacylist/ItemType.hx">
		<group/>
		<jid/>
		<subscription/>
	</enum>
	<class path="xmpp.pubsub.Affiliation" params="" file="../../xmpp/pubsub/Affiliation.hx">
		<parse public="1" set="method" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliation"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<affiliation public="1"><e path="xmpp.pubsub.AffiliationState"/></affiliation>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="node:affiliation">
	<c path="String"/>
	<e path="xmpp.pubsub.AffiliationState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.AffiliationState" params="" file="../../xmpp/pubsub/AffiliationState.hx">
		<none/>
		<owner/>
		<publisher/>
		<member/>
		<outcast/>
		<haxe_doc><![CDATA[<a href="http://xmpp.org/extensions/xep-0060.html#affiliations">Affiliations</a>]]></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Affiliations" params="" file="../../xmpp/pubsub/Affiliations.hx">
		<extends path="List"><c path="xmpp.pubsub.Affiliation"/></extends>
		<parse public="1" set="method" line="33" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliations"/>
</f></parse>
		<toXml public="1" set="method" line="26"><f a=""><c path="Xml"/></f></toXml>
	</class>
	<class path="xmpp.pubsub.Item" params="" file="../../xmpp/pubsub/Item.hx">
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Item"/>
</f></parse>
		<id public="1"><c path="String"/></id>
		<payload public="1"><c path="Xml"/></payload>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?id:?payload">
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Items" params="" file="../../xmpp/pubsub/Items.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Items"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<maxItems public="1"><t path="Null"><x path="Int"/></t></maxItems>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="30"><f a="?node:?subid:?maxItems">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Options" params="" file="../../xmpp/pubsub/Options.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Options"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?jid:?node:?subid:?form">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.DataForm"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Publish" params="" file="../../xmpp/pubsub/Publish.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Publish"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="28"><f a="node:?items">
	<c path="String"/>
	<t path="Iterable"><c path="xmpp.pubsub.Item"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Retract" params="" file="../../xmpp/pubsub/Retract.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Retract"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<notify public="1"><x path="Bool"/></notify>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="29"><f a="node:?itemIDs:?notify">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Subscription" params="" file="../../xmpp/pubsub/Subscription.hx">
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscription"/>
</f></parse>
		<jid public="1"><c path="String"/></jid>
		<node public="1"><c path="String"/></node>
		<subid public="1"><c path="String"/></subid>
		<subscription public="1"><e path="xmpp.pubsub.SubscriptionState"/></subscription>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="32"><f a="jid:?node:?subid:?subscription">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.pubsub.SubscriptionState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.SubscriptionState" params="" file="../../xmpp/pubsub/SubscriptionState.hx">
		<none><haxe_doc>The node MUST NOT send event notifications or payloads to the Entity.</haxe_doc></none>
		<pending><haxe_doc>An entity has requested to subscribe to a node and the request has not yet been approved by a node owner.
		The node MUST NOT send event notifications or payloads to the entity while it is in this state.</haxe_doc></pending>
		<unconfigured><haxe_doc>An entity has subscribed but its subscription options have not yet been configured.
		The node MAY send event notifications or payloads to the entity while it is in this state.
		The service MAY timeout unconfigured subscriptions.</haxe_doc></unconfigured>
		<subscribed><haxe_doc>An entity is subscribed to a node.
		The node MUST send all event notifications (and, if configured, payloads) to the entity while it is in this state
		(subject to subscriber configuration and content filtering).</haxe_doc></subscribed>
		<haxe_doc></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Subscriptions" params="" file="../../xmpp/pubsub/Subscriptions.hx">
		<extends path="List"><c path="xmpp.pubsub.Subscription"/></extends>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscriptions"/>
</f></parse>
		<node public="1"><c path="String"/></node>
		<toXml public="1" set="method" line="33"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="28"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.AskType" params="" file="../../xmpp/roster/AskType.hx">
		<subscribe><haxe_doc>Denotes that  a request to subscribe to a entities presence has been made.</haxe_doc></subscribe>
		<unsubscribe><haxe_doc>Denotes that a request to unscubscribe from a users presence has been made.</haxe_doc></unsubscribe>
		<haxe_doc>Roster ask types.</haxe_doc>
	</enum>
	<class path="xmpp.roster.Item" params="" file="../../xmpp/roster/Item.hx">
		<parse public="1" set="method" line="54" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.roster.Item"/>
</f></parse>
		<jid public="1" set="null"><c path="String"/></jid>
		<subscription public="1"><e path="xmpp.roster.Subscription"/></subscription>
		<name public="1"><c path="String"/></name>
		<askType public="1"><e path="xmpp.roster.AskType"/></askType>
		<groups public="1"><c path="List"><c path="String"/></c></groups>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="34"><f a="jid:?subscription:?name:?askType:?groups">
	<c path="String"/>
	<e path="xmpp.roster.Subscription"/>
	<c path="String"/>
	<e path="xmpp.roster.AskType"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.Subscription" params="" file="../../xmpp/roster/Subscription.hx">
		<none><haxe_doc>The user and subscriber have no interest in each other's presence.</haxe_doc></none>
		<to><haxe_doc>The user is interested in receiving presence updates from the subscriber.</haxe_doc></to>
		<from><haxe_doc>The subscriber is interested in receiving presence updates from the user.</haxe_doc></from>
		<both><haxe_doc>The user and subscriber have a mutual interest in each other's presence.</haxe_doc></both>
		<remove><haxe_doc>The user wishes to stop receiving presence updates from the subscriber.</haxe_doc></remove>
		<haxe_doc>Roster subscription states.</haxe_doc>
	</enum>
	<typedef path="xmpp.vcard.Address" params="" file="../../xmpp/vcard/Address.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<street>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</street>
	<region>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</region>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<postal>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</postal>
	<pobox>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pobox>
	<pcode>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcode>
	<parcel>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parcel>
	<locality>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</locality>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<extadd>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</extadd>
	<ctry>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</ctry>
</a></typedef>
	<typedef path="xmpp.vcard.EMail" params="" file="../../xmpp/vcard/EMail.hx"><a>
	<x400>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</x400>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<userid><c path="String"/></userid>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<internet>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</internet>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
</a></typedef>
	<typedef path="xmpp.vcard.Geo" params="T" file="../../xmpp/vcard/Geo.hx"><a>
	<lon><c path="xmpp.vcard.Geo.T"/></lon>
	<lat><c path="xmpp.vcard.Geo.T"/></lat>
</a></typedef>
	<typedef path="xmpp.vcard.Name" params="" file="../../xmpp/vcard/Name.hx"><a>
	<suffix><c path="String"/></suffix>
	<prefix><c path="String"/></prefix>
	<middle><c path="String"/></middle>
	<given><c path="String"/></given>
	<family><c path="String"/></family>
</a></typedef>
	<typedef path="xmpp.vcard.Org" params="" file="../../xmpp/vcard/Org.hx"><a>
	<orgunit><c path="String"/></orgunit>
	<orgname><c path="String"/></orgname>
</a></typedef>
	<typedef path="xmpp.vcard.Photo" params="" file="../../xmpp/vcard/Photo.hx"><a>
	<type><c path="String"/></type>
	<binval><c path="String"/></binval>
</a></typedef>
	<typedef path="xmpp.vcard.Tel" params="" file="../../xmpp/vcard/Tel.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<voice>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</voice>
	<video>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</video>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<pcs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcs>
	<pager>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pager>
	<number><c path="String"/></number>
	<msg>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</msg>
	<modem>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</modem>
	<isdn>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</isdn>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<fax>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</fax>
	<cell>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</cell>
	<bbs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</bbs>
</a></typedef>
</haxe>