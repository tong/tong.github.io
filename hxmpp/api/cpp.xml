<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.
		
		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However, 
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.
		
		This operation modifies `this` Array in place.
		
		The offset is calculated like so:
			
		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this` 
		  Array, i.e. `this.length + pos`. If this yields a negative value, the 
		  offset is 0.
		- Otherwise, the offset is `pos`.
		
		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.
		
		This operation modifies `this` Array in place.
		
		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.
		
		This operation modifies `this` Array in place.
		
		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].
		
		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.
		
		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies `this` Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.
		
		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.
		
		This operation does not modify `this` Array.
		
		The elements are not copied and retain their identity.
		
		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.
		
		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.
		
		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.
		
		If `this` is the empty Array `[]`, `null` is returned and the length 
		remains 0.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the offset
		it was added at.
		
		This operation modifies `this` Array in place.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this.length` will decrease by 1.
		
		If `this` is the empty Array `[]`, null is returned and the length 
		remains 0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.
		
		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`
		
		If `this` is the empty Array `[]`, the result is the empty String `""`. 
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.
		
		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.
		
		This operation does not modify `this` Array.
		
		If `a` is the empty Array `[]`, a copy of `this` Array is returned.
		
		The length of the returned Array is equal to the sum of `this.length` 
		and `a.length`.
		
		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a `List` which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/cpp/_std/Date.hx">
		<now public="1" set="method" line="50" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="54" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="60" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method" line="48">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method" line="46">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method" line="44">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method" line="42">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method" line="40">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method" line="38">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method" line="36">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method" line="30">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<mSeconds><x path="Float"/></mSeconds>
		<new public="1" set="method" line="26">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<getProcAddress public="1" get="inline" set="null" line="40" static="1">
			<f a="lib:prim">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</getProcAddress>
		<loadLazy public="1" set="method" line="48" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="64" static="1"><f a="inExp">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="66" static="1"><f a="inExp">
	<d/>
	<x path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="71" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="79" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="87" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="93" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/cpp/_std/EReg.hx">
		<regexp_new_options line="174" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></regexp_new_options>
		<regexp_match line="175" static="1"><f a=":::">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></regexp_match>
		<regexp_matched line="176" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></regexp_matched>
		<regexp_matched_pos line="177" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<a>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<map public="1" set="method" line="149">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string `s`, the function `f` is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the `g` flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</map>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.
		
		If `this` EReg does not match any substring, the result is `s`.
		
		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.
		
		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.
		
		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<split public="1" set="method" line="74">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.
		
		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.
		
		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.
		
		If two matching substrings appear next to each other, the result
		contains the empty String "" between them.
		
		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<matchSub public="1" set="method" line="65">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.matchSub(s.substr(pos,len))` can be used instead.
		
		This method modifies the internal state.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<matchedPos public="1" set="method" line="61">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="55">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.
		
		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.
		
		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.
		
		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.
		
		This method modifies the internal state.
		
		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<global><x path="Bool"/></global>
		<last><c path="String"/></last>
		<r><d/></r>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.
		
		This is equivalent to the shorthand syntax `~/r/opt`
		
		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="IntIterator" params="" file="/usr/lib/haxe/std/IntIterator.hx">
		<next public="1" set="method" line="61">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.
		
		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="52">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><x path="Int"/></max>
		<min><x path="Int"/></min>
		<new public="1" set="method" line="44">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).
		
		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.
	
	It is usually not used explicitly, but through it's special syntax:
	`min...max`
		
	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.
		
		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="54" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.
		
		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="68" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new List by applying function `f` to all elements of `it`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="82" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.
		
		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.
		
		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="115" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.
		
		This function returns true as soon as an element is found for which a
		call to `f` returns true.
		
		If no such element is found, the result is false.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="134" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.
		
		This function returns false as soon as an element is found for which a
		call to `f` returns false.
		
		If no such element is found, the result is true.
		
		In particular, this function always returns true if `it` is empty.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="146" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="159" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.
		
		If `it` is empty, the result is the empty List even if `f` is null.
		
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="179" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.
		
		If `it` has no elements, the result is `first`.
		
		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.
		
		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.
		
		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="206" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.
		
		This function uses operator `==` to check for equality.
		
		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="233" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new List containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<map public="1" params="X" set="method" line="259">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted by the
		function `f`.</haxe_doc>
		</map>
		<filter public="1" set="method" line="243">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with `f`. The returned list will contain all
		elements for which `f(x) == true`.</haxe_doc>
		</filter>
		<join public="1" set="method" line="224">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` List, with `sep` separating
		each element.</haxe_doc>
		</join>
		<toString public="1" set="method" line="203">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` List.
		
		The result is enclosed in { } with the individual elements being
		separated by a comma.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.
		
		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.
		
		Otherwise, false is returned.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.
		
		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="114">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="100">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		The element is removed from `this` List.</haxe_doc>
		</pop>
		<last public="1" set="method" line="90">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</last>
		<first public="1" set="method" line="81">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</add>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
	<_new public="1" set="method" static="1">
		<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="70" static="1">
		<f a="this:key:value">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="87" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<t path="Null"><c path="Map.V"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="102" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
	</iterator>
	<toString public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
	</toString>
	<arrayWrite public="1" get="inline" set="null" line="131" static="1">
		<f a="this:k:v">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<c path="Map.V"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</arrayWrite>
	<toStringMap get="inline" set="null" line="136" static="1">
		<f a="t">
			<c path="IMap">
				<c path="String"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap get="inline" set="null" line="140" static="1">
		<f a="t">
			<c path="IMap">
				<x path="Int"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toEnumValueMapMap>
	<toObjectMap params="K" get="inline" set="null" line="148" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toObjectMap>
	<fromStringMap params="V" get="inline" set="null" line="152" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<fromIntMap params="V" get="inline" set="null" line="156" static="1">
		<f a="map">
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="Map">
				<x path="Int"/>
				<c path="fromIntMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntMap>
	<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
		<f a="map">
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
			<x path="Map">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectMap>
</class></impl>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map">
		<_new public="1" set="method" static="1">
			<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="70" static="1">
			<f a="this:key:value">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="87" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<t path="Null"><c path="Map.V"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be 
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="102" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
		</iterator>
		<toString public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
		</toString>
		<arrayWrite public="1" get="inline" set="null" line="131" static="1">
			<f a="this:k:v">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<c path="Map.V"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</arrayWrite>
		<toStringMap get="inline" set="null" line="136" static="1">
			<f a="t">
				<c path="IMap">
					<c path="String"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap get="inline" set="null" line="140" static="1">
			<f a="t">
				<c path="IMap">
					<x path="Int"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.EnumValueMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toEnumValueMapMap>
		<toObjectMap params="K" get="inline" set="null" line="148" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.ObjectMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toObjectMap>
		<fromStringMap params="V" get="inline" set="null" line="152" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<fromIntMap params="V" get="inline" set="null" line="156" static="1">
			<f a="map">
				<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
				<x path="Map">
					<x path="Int"/>
					<c path="fromIntMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntMap>
		<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
			<f a="map">
				<c path="haxe.ds.ObjectMap">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</c>
				<x path="Map">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectMap>
	</class>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.K"/></t></f></keys>
		<remove public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<exists public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method"><f a="k:v">
	<c path="IMap.K"/>
	<c path="IMap.V"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<t path="Null"><c path="IMap.V"/></t>
</f></get>
	</class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.
		
		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.
		
		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.
		
		If `f` is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":include"><e>"hxMath"</e></m></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.
		
		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.
		
		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.
		
		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="41" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.
		
		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="46" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="53" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="60" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.
		
		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.
		
		This function is only defined if `a` and `b` are of the same type.
		
		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.
		
		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:
		
		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified
		
		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="68" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.
		
		If `f1` or `f2` are not functions, the result is unspecified.
		
		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="76" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.
		
		The result is true if `v` is one of the following:
			
		- class instance
		- structure
		- Class<T>
		- Enum<T>
			
		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.
		
		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.
		
		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="87" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.
		
		This method is only guaranteed to work on anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="92" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.
		
		This is only guaranteed to work on anonymous structures.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="104" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="23" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="27" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="31" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="43" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cpp/_std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.
		
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addChar public="1" get="inline" set="null" line="47">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.
		
		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="43">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.
		
		If `s` or `pos` are null, the result is unspecified.
		
		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<add public="1" set="method" line="39">
			<f a="x">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.
		
		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).
		
		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<get_length set="method" line="33"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<b><c path="Array"><c path="String"/></c></b>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="37" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="62" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="98" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:
			
		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;
		
		If `quotes` is true, the following characters are also replaced:
		
		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="117" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: htmlUnescape(htmlEscape(s)) == s

		The replacements follow:
			
		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="128" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="145" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is null, the result is unspecified.

		If `end` is the empty String "", the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="166" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="180" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="205" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="227" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="249" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="271" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="292" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="314" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="343" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`.

		This method is faster than String.charCodeAt() on most platforms.
		However, unlike String.charCodeAt(), the result is unspecified if
		`index` is negative or exceeds `s.length`.

		This operation is not guaranteed to work if `s` contains the \0
		character.</haxe_doc>
		</fastCodeAt>
		<isEof public="1" get="inline" set="null" line="370" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isEof>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<stdin public="1" set="method" line="33" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="37" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="41" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<getChar public="1" set="method" line="45" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<args public="1" set="method" line="49" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="53" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="60" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="64" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="68" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="72" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="76" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="80" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<escapeArgument set="method" line="84" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="98" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="107" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="111" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="115" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="119" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<environment public="1" set="method" line="123" static="1">
			<f a=""><c path="haxe.ds.StringMap"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env line="134" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="135" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="136" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="137" static="1"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></set_time_locale>
		<get_cwd line="138" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="139" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="140" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="141" static="1"><f a="">
	<c path="String"/>
	<x path="Int"/>
</f></sys_command>
		<sys_exit line="142" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="143" static="1"><f a=""><x path="Float"/></f></sys_time>
		<sys_cpu_time line="144" static="1"><f a=""><x path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="145" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="146" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
		<file_stdin line="148" static="1"><f a=""><unknown/></f></file_stdin>
		<file_stdout line="149" static="1"><f a=""><unknown/></f></file_stdout>
		<file_stderr line="150" static="1"><f a=""><unknown/></f></file_stderr>
		<getch line="152" static="1"><f a="">
	<x path="Bool"/>
	<x path="Int"/>
</f></getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="46" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.
		
		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.
		
		If `o` is null, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="52" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.
		
		If `c` has no super class, null is returned.
		
		If `c` is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="56" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="62" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="66" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If `name` is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If `name` is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.
		
		If `name` is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If `name` is null the result is unspecified.
		
		If `name` is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="80" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="86" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.
		
		This function guarantees that the class constructor is not called.
		
		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="90" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="94" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="100" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.
		
		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="104" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.
		
		This does not include static fields of parent classes.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="108" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="112" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="128" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="132" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="136" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="141" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="145" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/cpp/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="/usr/lib/haxe/std/cpp/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<_parse line="44" static="1"><f a=":">
	<c path="String"/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<d><c path="String"/></d>
	<x path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></pcdata>
		<done><f a=""><x path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></doctype>
		<cur><c path="Xml"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse public="1" set="method" line="46" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="110" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="119" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="126" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="133" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="140" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="147" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="154" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<toStringRec set="method" line="354"><f a="s">
	<c path="StringBuf"/>
	<x path="Void"/>
</f></toStringRec>
		<toString public="1" set="method" line="348">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<insertChild public="1" set="method" line="339">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<removeChild public="1" set="method" line="331">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="322">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<firstElement public="1" set="method" line="311">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<firstChild public="1" set="method" line="305">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<elementsNamed public="1" set="method" line="271">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<elements public="1" set="method" line="238">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<iterator public="1" set="method" line="231">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<attributes public="1" set="method" line="225">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<exists public="1" set="method" line="219">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<remove public="1" set="method" line="212">
			<f a="att">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<set public="1" set="method" line="203">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<get public="1" set="method" line="197">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<get_parent set="method" line="193"><f a=""><c path="Xml"/></f></get_parent>
		<parent public="1" get="accessor" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<set_nodeValue set="method" line="186"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get_nodeValue set="method" line="180"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeName set="method" line="174"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeName set="method" line="168"><f a=""><c path="String"/></f></get_nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<_parent><c path="Xml"/></_parent>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_attributes><d><c path="String"/></d></_attributes>
		<_nodeValue><c path="String"/></_nodeValue>
		<_nodeName><c path="String"/></_nodeName>
		<new set="method" line="41"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="521" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<serializeException public="1" set="method" line="498"><f a="e">
	<d/>
	<x path="Void"/>
</f></serializeException>
		<serialize public="1" set="method" line="224">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<serializeFields set="method" line="206"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serializeRef set="method" line="169"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<scount><x path="Int"/></scount>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<cache><c path="Array"><d/></c></cache>
		<buf><c path="StringBuf"/></buf>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:
	
	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:
		
		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="433" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<unserialize public="1" set="method" line="219">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<unserializeEnum set="method" line="187"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserializeObject set="method" line="172"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<get get="inline" set="null" line="143"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<getResolver public="1" set="method" line="139">
			<f a=""><t path="haxe.TypeResolver"/></f>
			<haxe_doc>Gets the type resolver of `this` Unserializer instance.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</getResolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<scache><c path="Array"><c path="String"/></c></scache>
		<cache><c path="Array"><d/></c></cache>
		<length><x path="Int"/></length>
		<pos><x path="Int"/></pos>
		<buf><c path="String"/></buf>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:
	
	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<encode public="1" set="method" line="127" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="132" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<decodeString public="1" set="method" line="119"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decodeString>
		<encodeString public="1" set="method" line="111"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encodeString>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<nbits><x path="Int"/></nbits>
		<base><c path="haxe.io.Bytes"/></base>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionnary.</haxe_doc>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/lib/haxe/std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="26" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<make public="1" set="method" line="36" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<str2blks set="method" line="104" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bytes2blks set="method" line="121" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<hex set="method" line="168"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<kt set="method" line="158">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<ft set="method" line="148">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<rol get="inline" set="null" line="141">
			<f a="num:cnt">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Bitwise rotate a 32-bit number to the left</haxe_doc>
		</rol>
		<doEncode set="method" line="58"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<toString public="1" set="method" line="205"><f a=""><c path="String"/></f></toString>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<keysLoop set="method" line="161"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<iteratorLoop set="method" line="153"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<keys public="1" set="method" line="126">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="115">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</iterator>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.
		
		This method returns true even if `key` is bound to null.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.
		
		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.
		
		Otherwise the binding of `key` is removed and true is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.
		
		If `key` is not bound to any value, `null` is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.
		
		If `key` is already bound to a value, that binding disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.
	
	Operations have a logarithmic average and worst-case cost.
	
	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<toString public="1" set="method" line="233"><f a=""><c path="String"/></f></toString>
		<get_height public="1" get="inline" set="null" line="231">
			<f a=""><x path="Int"/></f>
			<meta><m n=":extern"/></meta>
		</get_height>
		<_height><x path="Int"/></_height>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.
	
	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
	<_new public="1" set="method" line="25" static="1">
		<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<set public="1" get="inline" set="null" line="28" static="1">
		<f a="this:k:v">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<c path="haxe.ds.HashMap.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="32" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
	<exists public="1" get="inline" set="null" line="35" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</exists>
	<remove public="1" get="inline" set="null" line="38" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<keys public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</keys>
	<iterator public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
</class></impl>
	</abstract>
	<class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
		<_new public="1" set="method" line="25" static="1">
			<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<set public="1" get="inline" set="null" line="28" static="1">
			<f a="this:k:v">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="32" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
		<exists public="1" get="inline" set="null" line="35" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</exists>
		<remove public="1" get="inline" set="null" line="38" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<keys public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</keys>
		<iterator public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<toString public="1" set="method" line="58">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<toString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="58">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="48">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" get="inline" set="null" line="44">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="40">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<__KeyRefs><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.K"/></c></__KeyRefs>
		<__Internal><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.V"/></c></__Internal>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.
	
	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<toString public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="47">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" set="method" line="39">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="35">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="31">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<__Internal><d/></__Internal>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.WeakMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/WeakMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.WeakMap.K"/>
			<c path="haxe.ds.WeakMap.V"/>
		</implements>
		<toString public="1" set="method" line="85">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" set="method" line="57">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="50">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<t path="Null"><c path="haxe.ds.WeakMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="44">
			<f a="key:value">
				<c path="haxe.ds.WeakMap.K"/>
				<c path="haxe.ds.WeakMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new WeakMap.</haxe_doc>
		</new>
		<haxe_doc>WeakMap allows mapping of object keys to arbitrary values.
	
	The keys are considered to be weak references on static targets.
	
	See `Map` for documentation details.</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="250" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="275" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="324" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<fastGet public="1" get="inline" set="null" line="342" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<getData public="1" get="inline" set="null" line="246"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="232"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="211"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="163"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="125"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<sub public="1" set="method" line="99"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="68"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="50"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="34"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><x path="Int"/></length>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="138">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<addBytes public="1" get="inline" set="null" line="112"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<add public="1" get="inline" set="null" line="93"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addByte public="1" get="inline" set="null" line="75"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<get_length get="inline" set="null" line="63"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<_float_of_bytes line="335" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="336" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_double_of_bytes>
		<readString public="1" set="method" line="318"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readUInt24 public="1" set="method" line="303"><f a=""><x path="Int"/></f></readUInt24>
		<readInt24 public="1" set="method" line="293"><f a=""><x path="Int"/></f></readInt24>
		<readUInt16 public="1" set="method" line="287"><f a=""><x path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="278"><f a=""><x path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="271"><f a=""><x path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="198"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="144"><f a=""><x path="Float"/></f></readFloat>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<readUntil public="1" set="method" line="119"><f a="end">
	<x path="Int"/>
	<c path="String"/>
</f></readUntil>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<readAll public="1" set="method" line="77"><f a="?bufsize">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<LN2 line="31" static="1"><x path="Float"/></LN2>
		<_float_bytes line="329" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="330" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<writeInput public="1" set="method" line="291"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeInput>
		<prepare public="1" set="method" line="288">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInt32 public="1" set="method" line="268"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt32>
		<writeUInt24 public="1" set="method" line="255"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt24>
		<writeInt24 public="1" set="method" line="250"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt24>
		<writeUInt16 public="1" set="method" line="239"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="234"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="228"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="151"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="97"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<write public="1" set="method" line="78"><f a="s">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></write>
		<set_bigEndian set="method" line="71"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method" line="65"><f a=""><x path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CInt a="v"><c path="String"/></CInt>
		<CFloat a="f"><c path="String"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<CIdent a="s"><c path="String"/></CIdent>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd/>
		<OpMult/>
		<OpDiv/>
		<OpSub/>
		<OpAssign/>
		<OpEq/>
		<OpNotEq/>
		<OpGt/>
		<OpGte/>
		<OpLt/>
		<OpLte/>
		<OpAnd/>
		<OpOr/>
		<OpXor/>
		<OpBoolAnd/>
		<OpBoolOr/>
		<OpShl/>
		<OpShr/>
		<OpUShr/>
		<OpMod/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpInterval/>
		<OpArrow/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement/>
		<OpDecrement/>
		<OpNot/>
		<OpNeg/>
		<OpNegBits/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<x path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EVars a="vars"><c path="Array"><t path="haxe.macro.Var"/></c></EVars>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Case"/></c>
			<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		</ESwitch>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Catch"/></c>
		</ETry>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EBreak/>
		<EContinue/>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
		</EDisplay>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<EMeta a="s:e">
			<t path="haxe.macro.MetadataEntry"/>
			<t path="haxe.macro.Expr"/>
		</EMeta>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><x path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<APublic/>
		<APrivate/>
		<AStatic/>
		<AOverride/>
		<ADynamic/>
		<AInline/>
		<AMacro/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
		<FProp a="get:set:?t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><x path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDEnum/>
		<TDStructure/>
		<TDClass a="?superClass:?interfaces:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<x path="Bool"/>
		</TDClass>
		<TDAlias a="t"><e path="haxe.macro.ComplexType"/></TDAlias>
		<TDAbstract a="tthis:?from:?to">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		</TDAbstract>
	</enum>
	<class path="haxe.macro.Error" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<toString set="method" line="239"><f a=""><c path="String"/></f></toString>
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="235"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<class path="haxe.remoting.AsyncConnection" params="" file="/usr/lib/haxe/std/haxe/remoting/AsyncConnection.hx" interface="1">
		<setErrorHandler public="1" set="method"><f a="error">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method"><f a="params:?result">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.remoting.Context" params="" file="/usr/lib/haxe/std/haxe/remoting/Context.hx">
		<share public="1" set="method" line="55" static="1"><f a="name:obj">
	<c path="String"/>
	<a/>
	<c path="haxe.remoting.Context"/>
</f></share>
		<call public="1" set="method" line="36"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<addObject public="1" set="method" line="32"><f a="name:obj:?recursive">
	<c path="String"/>
	<a/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addObject>
		<objects><c path="haxe.ds.StringMap"><a>
	<rec><x path="Bool"/></rec>
	<obj><d/></obj>
</a></c></objects>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="jabber.Attention" params="" file="../../jabber/Attention.hx">
		<capture public="1" set="method" line="33" static="1">
			<f a="stream:jid:message">
				<c path="jabber.Stream"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends a message packet to the given entity inluding a property to get attention</haxe_doc>
		</capture>
		<haxe_doc>Extension for getting the attention of another user.
	XEP 224 - Attention: http://www.xmpp.org/extensions/xep-0224.html</haxe_doc>
	</class>
	<class path="jabber.EntityCapabilities" params="" file="../../jabber/EntityCapabilities.hx">
		<requestDiscoInfo set="method" line="131"><f a="jid:?node">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></requestDiscoInfo>
		<handleInfoResponse set="method" line="114"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoResponse>
		<handlePresence set="method" line="105"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<dispose public="1" set="method" line="100"><f a=""><x path="Void"/></f></dispose>
		<interceptPacket public="1" set="method" line="84"><f a="p">
	<c path="xmpp.Packet"/>
	<c path="xmpp.Packet"/>
</f></interceptPacket>
		<createVerificationString public="1" set="method" line="80">
			<f a="identities:features:?dataform">
				<c path="Array"><t path="xmpp.disco.Identity"/></c>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create/Recreate the verification string
		Call if your stream changes features</haxe_doc>
		</createVerificationString>
		<x><c path="Xml"/></x>
		<collector><c path="jabber.PacketCollector"/></collector>
		<ver public="1" set="null">
			<c path="String"/>
			<haxe_doc>My own verification string</haxe_doc>
		</ver>
		<node public="1" set="null">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application,
		typically a URL at the website of the project or company that produces the software</haxe_doc>
		</node>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onInfo public="1" set="dynamic" line="37">
			<f a="jid:info:?ver">
				<c path="String"/>
				<c path="xmpp.disco.Info"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fired when a new entity capability got discovered</haxe_doc>
		</onInfo>
		<onCaps public="1" set="dynamic" line="34">
			<f a="jid:caps:cb">
				<c path="String"/>
				<c path="xmpp.Caps"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback to application for checking if caps already exist (in cache)</haxe_doc>
		</onCaps>
		<new public="1" set="method" line="57"><f a="stream:node:identities:?ext">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for broadcasting and dynamically discovering client, device, or generic entity capabilities.

	XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="jabber.EntityTime" params="" file="../../jabber/EntityTime.hx">
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<load public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request the local time of another jabber entity.</haxe_doc>
		</load>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onLoad public="1" set="dynamic" line="31"><f a="jid:t">
	<c path="String"/>
	<c path="xmpp.EntityTime"/>
	<x path="Void"/>
</f></onLoad>
		<new public="1" set="method" line="36"><f a="s">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for requesting the local time of an entity.

	XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.EntityTimeListener" params="" file="../../jabber/EntityTimeListener.hx">
		<handleRequest set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<c><c path="jabber.PacketCollector"/></c>
		<time public="1" set="null"><c path="xmpp.EntityTime"/></time>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<new public="1" set="method" line="36"><f a="stream:?tzo">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers entity time requests.

	XEP 202 - EntityTime http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<class path="jabber.JID" params="" file="../../jabber/JID.hx">
		<toString public="1" set="method" line="79"><f a=""><c path="String"/></f></toString>
		<copy public="1" set="method" line="71"><f a=""><c path="jabber.JID"/></f></copy>
		<get_s get="inline" set="null" line="69"><f a=""><c path="String"/></f></get_s>
		<get_bare set="method" line="65"><f a=""><c path="String"/></f></get_bare>
		<s public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Just a shortcut for toString()</haxe_doc>
		</s>
		<bare public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>JID without resource</haxe_doc>
		</bare>
		<resource public="1">
			<c path="String"/>
			<haxe_doc>Resourcepart, uniquely identifies a specific connection (e.g., a device or location)</haxe_doc>
		</resource>
		<domain public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</domain>
		<node public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</node>
		<new public="1" set="method" line="55"><f a="?t">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Unique Jabber-ID.

	A JID is made up of a node (generally a username), a domain, and a resource.

		jid             = [ node "@" ] domain [ "/" resource ]
		domain          = fqdn / address-literal
		fqdn            = (sub-domain 1*("." sub-domain))
		sub-domain      = (internationalized domain label)
		address-literal = IPv4address / IPv6address

	Each allowable portion of a JID (node, domain, and resource) must not be more than 1023 bytes in length,
	resulting in a maximum total size (including the '@' and '/' separators) of 3071 bytes.</haxe_doc>
	</class>
	<class path="jabber.JIDUtil" params="" file="../../jabber/JIDUtil.hx">
		<MIN_LENGTH public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></MIN_LENGTH>
		<MAX_PARTSIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_PARTSIZE>
		<MAX_SIZE public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></MAX_SIZE>
		<EREG public="1" line="38" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid JID</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="57" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID is valid formed.</haxe_doc>
		</isValid>
		<node public="1" get="inline" set="null" line="74" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The node of the given JID.</haxe_doc>
		</node>
		<domain public="1" set="method" line="81" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The domain of the given JID.</haxe_doc>
		</domain>
		<resource public="1" set="method" line="90" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The resource of the given JID.</haxe_doc>
		</resource>
		<bare public="1" set="method" line="98" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes The resource from a JID.</haxe_doc>
		</bare>
		<hasResource public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns True if the given JID has a valid resource.</haxe_doc>
		</hasResource>
		<parts public="1" set="method" line="113" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>@returns A String array with parsed node, domain and resource.</haxe_doc>
		</parts>
		<splitBare public="1" set="method" line="122" static="1">
			<f a="jid">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits the given JID into parts and returns it as array excluding the resource.</haxe_doc>
		</splitBare>
		<compare public="1" set="method" line="130" static="1">
			<f a="a:b">
				<c path="jabber.JID"/>
				<c path="jabber.JID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</compare>
		<escapeNode public="1" set="method" line="145" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escapes the node portion of a JID according to "JID Escaping" (XEP-0106).
	    Escaping replaces characters prohibited by node-prep with escape sequences.

	    Typically, escaping is performed only by a client that is processing information
	    provided by a human user in unescaped form, or by a gateway to some external system
	    (e.g., email or LDAP) that needs to generate a JID.</haxe_doc>
		</escapeNode>
		<unescapeNode public="1" set="method" line="169" static="1">
			<f a="n">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Un-escapes the node portion of a JID according to XEP-0106:JID Escaping (http://www.xmpp.org/extensions/xep-0106.html).
     	Escaping replaces characters prohibited by node-prep with escape sequences.

     	Typically, unescaping is performed only by a client that wants to display JIDs
     	containing escaped characters to a human user, or by a gateway to some
     	external system (e.g., email or LDAP) that needs to generate identifiers
     	for foreign systems.</haxe_doc>
		</unescapeNode>
		<haxe_doc>Static methods for jabber-id validation and manipulation.</haxe_doc>
	</class>
	<class path="jabber.LastActivity" params="" file="../../jabber/LastActivity.hx">
		<handleLoad set="method" line="49"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<request public="1" set="method" line="43">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Requests the given entity for their last activity.<br/>
		Given a bare jid will be handled by the server on roster subscription basis.<br/>
		Otherwise the request will be fowarded to the resource of the client entity.<br/>]]></haxe_doc>
		</request>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onLoad public="1" set="dynamic" line="29"><f a="entity:secs">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onLoad>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.LastActivityListener" params="" file="../../jabber/LastActivityListener.hx">
		<handleRequest set="method" line="51"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleRequest>
		<dispose public="1" set="method" line="43"><f a=""><x path="Void"/></f></dispose>
		<c><c path="jabber.PacketCollector"/></c>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<time public="1">
			<x path="Int"/>
			<haxe_doc>Seconds passed after last user activity</haxe_doc>
		</time>
		<new public="1" set="method" line="35"><f a="stream:?time">
	<c path="jabber.Stream"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="jabber.MUCUtil" params="" file="../../jabber/MUCUtil.hx">
		<EREG public="1" line="30" static="1">
			<c path="EReg"/>
			<haxe_doc>Regular expression matching a valid MUC address</haxe_doc>
		</EREG>
		<isValid public="1" set="method" line="36" static="1">
			<f a="t:?nick">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given string is a valid muchat address.
		The 'nick' parameter indicates if a full adress (including nickname) is expected.</haxe_doc>
		</isValid>
		<getRoom public="1" get="inline" set="null" line="45" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the room of the muc jid.</haxe_doc>
		</getRoom>
		<getHost public="1" get="inline" set="null" line="52" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the host of the muc jid.</haxe_doc>
		</getHost>
		<getNick public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the occupant name of the muc jid.</haxe_doc>
		</getNick>
		<getParts public="1" set="method" line="67" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns array existing of roomname[0], host[1] and (optional) occupantname[2] of the given muc address.</haxe_doc>
		</getParts>
		<haxe_doc>Static methods for parsing of mutliuser chat addresses.</haxe_doc>
	</class>
	<class path="jabber.PacketListener" params="T" file="../../jabber/PacketListener.hx">
		<handlePacket set="method" line="53"><f a="p">
	<c path="jabber.PacketListener.T"/>
	<x path="Void"/>
</f></handlePacket>
		<set_listen set="method" line="47"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_listen>
		<collector><c path="jabber.PacketCollector"/></collector>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<listen public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Activates/Deactivates packet collecting</haxe_doc>
		</listen>
		<onPacket public="1" set="dynamic" line="30">
			<f a="p">
				<c path="jabber.PacketListener.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Packet recieved callback</haxe_doc>
		</onPacket>
		<new set="method" line="38"><f a="stream:handler:type:listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="jabber.PacketListener.T"/>
		<x path="Void"/>
	</f>
	<e path="xmpp.PacketType"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for top level packet listeners (jabber.PresenceListener, jabber.MessageListener).</haxe_doc>
	</class>
	<class path="jabber.MessageListener" params="" file="../../jabber/MessageListener.hx">
		<extends path="jabber.PacketListener"><c path="xmpp.Message"/></extends>
		<new public="1" set="method" line="34"><f a="stream:handler:?listen">
	<c path="jabber.Stream"/>
	<f a="">
		<c path="xmpp.Message"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Utility (shortcut) to listen/report incoming message packets.

	Usage:
	var l = new MessageListener( stream, function(m){
		trace("Received message: "+m);
	});</haxe_doc>
	</class>
	<class path="jabber.PacketCollector" params="" file="../../jabber/PacketCollector.hx">
		<deliver public="1" set="method" line="68">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Delivers the given packet to all registerd handlers.</haxe_doc>
		</deliver>
		<accept public="1" set="method" line="58">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given XMPP packet passes through all filters.</haxe_doc>
		</accept>
		<block public="1">
			<x path="Bool"/>
			<haxe_doc>Block remaining collectors</haxe_doc>
		</block>
		<permanent public="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the the collector should get removed from the stream after collecting.</haxe_doc>
		</permanent>
		<handlers public="1">
			<c path="Array"><f a="">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></c>
			<haxe_doc>Callbacks to which collected packets get delivered to.</haxe_doc>
		</handlers>
		<filters public="1" set="null">
			<c path="jabber._PacketCollector.FilterList"/>
			<haxe_doc>This collectors filters</haxe_doc>
		</filters>
		<new public="1" set="method" line="44"><f a="filters:handler:?permanent:?block">
	<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Default XMPP packet collector implementation.</haxe_doc>
	</class>
	<class path="jabber._PacketCollector.FilterList" params="" file="../../jabber/PacketCollector.hx" private="1" module="jabber.PacketCollector">
		<remove public="1" get="inline" set="null" line="108"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Bool"/>
</f></remove>
		<unshift public="1" get="inline" set="null" line="104"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></unshift>
		<push public="1" get="inline" set="null" line="100"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></push>
		<addFilter public="1" get="inline" set="null" line="96"><f a="_f">
	<t path="xmpp.PacketFilter"/>
	<x path="Void"/>
</f></addFilter>
		<addIDFilter public="1" get="inline" set="null" line="92"><f a="_f">
	<c path="xmpp.filter.PacketIDFilter"/>
	<x path="Void"/>
</f></addIDFilter>
		<iterator public="1" get="inline" set="null" line="88"><f a=""><t path="Iterator"><t path="xmpp.PacketFilter"/></t></f></iterator>
		<clear public="1" get="inline" set="null" line="83"><f a=""><x path="Void"/></f></clear>
		<f><c path="Array"><t path="xmpp.PacketFilter"/></c></f>
		<fid><c path="Array"><t path="xmpp.PacketFilter"/></c></fid>
		<new public="1" set="method" line="79"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="jabber.PacketInterceptor" params="" file="../../jabber/PacketInterceptor.hx">
		<a><interceptPacket set="method">
	<f a="p">
		<c path="xmpp.Packet"/>
		<c path="xmpp.Packet"/>
	</f>
	<haxe_doc>Intercepts outgoing XMPP packet before sending.</haxe_doc>
</interceptPacket></a>
		<haxe_doc>Modifies XMPP packets and/or runs additional processes before sending.</haxe_doc>
	</typedef>
	<class path="jabber.PersonalEvent" params="" file="../../jabber/PersonalEvent.hx">
		<sendIQ set="method" line="58"><f a="e:x:h">
	<c path="xmpp.PersonalEvent"/>
	<c path="Xml"/>
	<f a="">
		<c path="xmpp.PersonalEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<disable public="1" set="method" line="54">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disable publishing.</haxe_doc>
		</disable>
		<publish public="1" set="method" line="45">
			<f a="e">
				<c path="xmpp.PersonalEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Publish a personal event.</haxe_doc>
		</publish>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="33"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onDisable public="1" set="dynamic" line="32"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onDisable>
		<onPublish public="1" set="dynamic" line="31"><f a="e">
	<c path="xmpp.PersonalEvent"/>
	<x path="Void"/>
</f></onPublish>
		<new public="1" set="method" line="38"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Send personal updates or "events" to other users, who are typically contacts in the user's roster.
	
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<typedef path="jabber._PersonalEventListener.Listener" params="" file="../../jabber/PersonalEventListener.hx" private="1" module="jabber.PersonalEventListener"><a>
	<xmlns><c path="String"/></xmlns>
	<type><x path="Class"><c path="xmpp.PersonalEvent"/></x></type>
	<handler><f a=":">
	<c path="xmpp.Message"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></handler>
</a></typedef>
	<class path="jabber.PersonalEventListener" params="" file="../../jabber/PersonalEventListener.hx">
		<handlePersonalEvent set="method" line="100"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePersonalEvent>
		<getListener public="1" set="method" line="93">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<t path="jabber._PersonalEventListener.Listener"/>
			</f>
			<haxe_doc>Returns the listeners for the given type.</haxe_doc>
		</getListener>
		<clear public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clear all listeners.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="76">
			<f a="type">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove listener for the given type.</haxe_doc>
		</remove>
		<add public="1" set="method" line="59">
			<f a="t:h">
				<x path="Class"><c path="xmpp.PersonalEvent"/></x>
				<f a=":">
					<c path="xmpp.Message"/>
					<c path="Xml"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add listener for the given type.</haxe_doc>
		</add>
		<iterator public="1" get="inline" set="null" line="52"><f a=""><t path="Iterator"><t path="jabber._PersonalEventListener.Listener"/></t></f></iterator>
		<listeners><c path="List"><t path="jabber._PersonalEventListener.Listener"/></c></listeners>
		<stream public="1" set="null">
			<c path="jabber.Stream"/>
			<haxe_doc>Optional to collect ALL events</haxe_doc>
		</stream>
		<new public="1" set="method" line="44"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listener for incoming personal events from other entities.
	XEP-0163: Personal Eventing Protocol: http://xmpp.org/extensions/xep-0163.html</haxe_doc>
	</class>
	<class path="jabber.Pong" params="" file="../../jabber/Pong.hx">
		<handlePing set="method" line="52"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<dispose public="1" set="method" line="44"><f a=""><x path="Void"/></f></dispose>
		<c><c path="jabber.PacketCollector"/></c>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onPong public="1" set="dynamic" line="31">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Informational callback on ping-pong</haxe_doc>
		</onPong>
		<new public="1" set="method" line="37"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming ping messages and automaticly responds with a pong.
	XEP 199 - XMPP Ping: http://www.xmpp.org/extensions/xep-0199.html</haxe_doc>
	</class>
	<class path="jabber.PrivacyLists" params="" file="../../jabber/PrivacyLists.hx">
		<handleListPush set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleListPush>
		<sendRequest set="method" line="126"><f a="iqType:resultHandler:?active:?_default:?list">
	<e path="xmpp.IQType"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></sendRequest>
		<_update set="method" line="118"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></_update>
		<remove public="1" set="method" line="109"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="105"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></add>
		<update public="1" set="method" line="101"><f a="list">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></update>
		<changeDefault public="1" set="method" line="84"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></changeDefault>
		<deactivate public="1" set="method" line="77"><f a=""><x path="Void"/></f></deactivate>
		<activate public="1" set="method" line="69"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></activate>
		<load public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></load>
		<loadLists public="1" set="method" line="53"><f a=""><x path="Void"/></f></loadLists>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="39"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onDefaultChange public="1" set="dynamic" line="38"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onDefaultChange>
		<onDeactivate public="1" set="dynamic" line="37"><f a=""><x path="Void"/></f></onDeactivate>
		<onActivate public="1" set="dynamic" line="36"><f a="l">
	<c path="String"/>
	<x path="Void"/>
</f></onActivate>
		<onRemoved public="1" set="dynamic" line="35"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onRemoved>
		<onUpdate public="1" set="dynamic" line="34"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onUpdate>
		<onInfo public="1" set="dynamic" line="33"><f a="l">
	<c path="xmpp.PrivacyList"/>
	<x path="Void"/>
</f></onInfo>
		<onLists public="1" set="dynamic" line="32"><f a="l">
	<c path="xmpp.PrivacyLists"/>
	<x path="Void"/>
</f></onLists>
		<new public="1" set="method" line="43"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for blocking communication with unknown or undesirable entities.
	Depricated! Use jabber.ComBlock instead.

	XEP-0016: Privacy Lists: http://xmpp.org/extensions/xep-0016.html</haxe_doc>
	</class>
	<class path="jabber.PrivateStorage" params="" file="../../jabber/PrivateStorage.hx">
		<store public="1" set="method" line="59">
			<f a="name:namespace:data">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store private data.</haxe_doc>
		</store>
		<load public="1" set="method" line="43">
			<f a="name:namespace">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Load private data.</haxe_doc>
		</load>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="32"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onStored public="1" set="dynamic" line="31"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onStored>
		<onLoad public="1" set="dynamic" line="30"><f a="s">
	<c path="xmpp.PrivateStorage"/>
	<x path="Void"/>
</f></onLoad>
		<new public="1" set="method" line="36"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension to store any arbitrary XML on the server side.
	XEP-0049: Private XML Storage: http://xmpp.org/extensions/xep-0049.html</haxe_doc>
	</class>
	<class path="jabber.PubSub" params="" file="../../jabber/PubSub.hx">
		<sendIQ set="method" line="264"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a="">
		<c path="xmpp.IQ"/>
		<x path="Void"/>
	</f>
	<c path="xmpp.IQ"/>
</f></sendIQ>
		<publish public="1" set="method" line="241">
			<f a="node:item:?options">
				<c path="String"/>
				<c path="xmpp.pubsub.Item"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publish an item to a node.</haxe_doc>
		</publish>
		<purge public="1" set="method" line="226">
			<f a="node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Remove all items from the persistent store, with the exception of the last published item, which MAY be cached.
		(This is a optional feature for a pubsub service).</haxe_doc>
		</purge>
		<retract public="1" set="method" line="210">
			<f a="retract">
				<c path="xmpp.pubsub.Retract"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Publisher deletes an item once it has been published to a node that supports persistent items.</haxe_doc>
		</retract>
		<loadItems public="1" set="method" line="186">
			<f a="node:?subid:?maxItems:?ids">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load (all) items from the given node.</haxe_doc>
		</loadItems>
		<loadAffiliations public="1" set="method" line="170">
			<f a=""><c path="xmpp.IQ"/></f>
			<haxe_doc>Load list of affiliations for all nodes at the service.</haxe_doc>
		</loadAffiliations>
		<unsubscribe public="1" set="method" line="141">
			<f a="node:?jid:?subid">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Unsubscribe from given pubsub node.</haxe_doc>
		</unsubscribe>
		<subscribe public="1" set="method" line="123">
			<f a="node:?jid">
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc><![CDATA[Subscribe to given pubsub node.
		The 'jid' attribute specifying the exact XMPP address to be used as the subscribed JID.
		Often a bare JID (<localpart@domain.tld> or <domain.tld>)
		or full JID <localpart@domain.tld/resource>
		or <domain.tld/resource>.]]></haxe_doc>
		</subscribe>
		<loadSubscriptions public="1" set="method" line="104">
			<f a="?node">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Load list of current subscriptions.</haxe_doc>
		</loadSubscriptions>
		<deleteNode public="1" set="method" line="73">
			<f a="name">
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Delete pubsub node with given name (http://xmpp.org/extensions/xep-0060.html#owner-delete")</haxe_doc>
		</deleteNode>
		<createNode public="1" set="method" line="59">
			<f a="name:?config">
				<c path="String"/>
				<c path="xmpp.DataForm"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Create a pubsub node with the given name (http://xmpp.org/extensions/xep-0060.html#owner-create).</haxe_doc>
		</createNode>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<service public="1" set="null">
			<c path="String"/>
			<haxe_doc>Name of the pubsub service</haxe_doc>
		</service>
		<onPurge public="1" set="dynamic" line="45"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onPurge>
		<onRetract public="1" set="dynamic" line="44"><f a="r">
	<c path="xmpp.pubsub.Retract"/>
	<x path="Void"/>
</f></onRetract>
		<onAffiliations public="1" set="dynamic" line="43"><f a="a">
	<c path="xmpp.pubsub.Affiliations"/>
	<x path="Void"/>
</f></onAffiliations>
		<onItems public="1" set="dynamic" line="42"><f a="items">
	<c path="xmpp.pubsub.Items"/>
	<x path="Void"/>
</f></onItems>
		<onPublish public="1" set="dynamic" line="41"><f a="node:item">
	<c path="String"/>
	<c path="xmpp.pubsub.Item"/>
	<x path="Void"/>
</f></onPublish>
		<onUnsubscribe public="1" set="dynamic" line="40"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onUnsubscribe>
		<onSubscribe public="1" set="dynamic" line="39"><f a="sub">
	<c path="xmpp.pubsub.Subscription"/>
	<x path="Void"/>
</f></onSubscribe>
		<onSubscriptions public="1" set="dynamic" line="38"><f a="subs">
	<c path="xmpp.pubsub.Subscriptions"/>
	<x path="Void"/>
</f></onSubscriptions>
		<onNodeDelete public="1" set="dynamic" line="37"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeDelete>
		<onNodeCreate public="1" set="dynamic" line="35"><f a="node">
	<c path="String"/>
	<x path="Void"/>
</f></onNodeCreate>
		<onError public="1" set="dynamic" line="34"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<new public="1" set="method" line="51"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[PubSub client extension.

	http://xmpp.org/extensions/xep-0060.html">XEP-0060: Publish-Subscribe]]></haxe_doc>
	</class>
	<class path="jabber.PubSubListener" params="" file="../../jabber/PubSubListener.hx">
		<handlePubSubEvent set="method" line="62"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handlePubSubEvent>
		<dispose public="1" set="method" line="58"><f a=""><x path="Void"/></f></dispose>
		<c><c path="jabber.PacketCollector"/></c>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onSubscription public="1" set="dynamic" line="44">
			<f a="service:subscription">
				<c path="String"/>
				<c path="xmpp.pubsub.Subscription"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscription action notification</haxe_doc>
		</onSubscription>
		<onPurge public="1" set="dynamic" line="42">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got purged</haxe_doc>
		</onPurge>
		<onDelete public="1" set="dynamic" line="40">
			<f a="service:node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Node got deleted</haxe_doc>
		</onDelete>
		<onConfig public="1" set="dynamic" line="38">
			<f a="service:config">
				<c path="String"/>
				<a>
					<node><c path="String"/></node>
					<form><c path="xmpp.DataForm"/></form>
				</a>
				<x path="Void"/>
			</f>
			<haxe_doc>Configuration got changed</haxe_doc>
		</onConfig>
		<onItems public="1" set="dynamic" line="36">
			<f a="service:items">
				<c path="String"/>
				<c path="xmpp.pubsub.Items"/>
				<x path="Void"/>
			</f>
			<haxe_doc>New pubsub item(s) recieved</haxe_doc>
		</onItems>
		<onMessage public="1" set="dynamic" line="31">
			<f a="m">
				<c path="xmpp.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Every(!) full pubsub event message</haxe_doc>
		</onMessage>
		<new public="1" set="method" line="50"><f a="stream:service">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens for incoming pubsub events from a given service.
	XEP-0060: Publish-Subscribe: http://xmpp.org/extensions/xep-0060.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscovery" params="" file="../../jabber/ServiceDiscovery.hx">
		<handleItems set="method" line="99"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItems>
		<handleInfo set="method" line="75"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfo>
		<items public="1" set="method" line="65">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for items.</haxe_doc>
		</items>
		<info public="1" set="method" line="52">
			<f a="?jid:?node">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Query entity for information.</haxe_doc>
		</info>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="41"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onItems public="1" set="dynamic" line="40"><f a="jid:items">
	<c path="String"/>
	<c path="xmpp.disco.Items"/>
	<x path="Void"/>
</f></onItems>
		<onInfo public="1" set="dynamic" line="39"><f a="jid:info">
	<c path="String"/>
	<c path="xmpp.disco.Info"/>
	<x path="Void"/>
</f></onInfo>
		<new public="1" set="method" line="45"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages discovery of services from XMPP entities.
	Two kinds of information can be discovered:
		The identity and capabilities of an entity, including the protocols and features it supports.
		The items associated with an entity, such as the list of rooms hosted at a multi-user chat service.

	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<class path="jabber.ServiceDiscoveryListener" params="" file="../../jabber/ServiceDiscoveryListener.hx">
		<defaultIdentity public="1" line="33" static="1"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></defaultIdentity>
		<handleItemsQuery set="method" line="90"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleItemsQuery>
		<handleInfoQuery set="method" line="68"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleInfoQuery>
		<dispose public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<c_items><c path="jabber.PacketCollector"/></c_items>
		<c_info><c path="jabber.PacketCollector"/></c_info>
		<onItemsQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom items request handler relay</haxe_doc>
		</onItemsQuery>
		<onInfoQuery public="1">
			<f a="">
				<c path="xmpp.IQ"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Custom info request handler relay</haxe_doc>
		</onInfoQuery>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<new public="1" set="method" line="49"><f a="stream:?identities">
	<c path="jabber.Stream"/>
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>Listens/Answers incoming service discovery requests.
	XEP 30 - ServiceDiscovery: http://www.xmpp.org/extensions/xep-0030.html</haxe_doc>
	</class>
	<typedef path="jabber.SocketConnection" params="" file="../../jabber/SocketConnection.hx"><c path="jabber.net.SocketConnection_sys"/></typedef>
	<class path="jabber.SoftwareVersion" params="" file="../../jabber/SoftwareVersion.hx">
		<load public="1" set="method" line="41">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests the software version of the given entity.</haxe_doc>
		</load>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="30"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onLoad public="1" set="dynamic" line="29"><f a="jid:sv">
	<c path="String"/>
	<c path="xmpp.SoftwareVersion"/>
	<x path="Void"/>
</f></onLoad>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="jabber.SoftwareVersionListener" params="" file="../../jabber/SoftwareVersionListener.hx">
		<handleQuery set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleQuery>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<c><c path="jabber.PacketCollector"/></c>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity (optional)</haxe_doc>
		</os>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<new public="1" set="method" line="45"><f a="stream:name:version:?os">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extension for retrieving information about the software application associated with an XMPP entity
	XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<typedef path="jabber._Stream.Server" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream"><a><features><x path="Map">
	<c path="String"/>
	<c path="Xml"/>
</x></features></a></typedef>
	<class path="jabber._Stream.StreamFeatures" params="" file="../../jabber/Stream.hx" private="1" module="jabber.Stream">
		<toString public="1" get="inline" set="null" line="70"><f a=""><c path="String"/></f></toString>
		<clear public="1" get="inline" set="null" line="65"><f a="f">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<remove public="1" get="inline" set="null" line="61"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></remove>
		<has public="1" get="inline" set="null" line="57"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<add public="1" set="method" line="51"><f a="f">
	<c path="String"/>
	<x path="Bool"/>
</f></add>
		<iterator public="1" get="inline" set="null" line="47"><f a=""><t path="Iterator"><c path="String"/></t></f></iterator>
		<l><c path="Array"><c path="String"/></c></l>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="jabber.Stream" params="" file="../../jabber/Stream.hx">
		<defaultPacketIdLength public="1" line="81" static="1"><x path="Int"/></defaultPacketIdLength>
		<defaultMaxBufSize public="1" line="82" static="1"><x path="Int"/></defaultMaxBufSize>
		<cleanup set="method" line="596"><f a=""><x path="Void"/></f></cleanup>
		<handleStreamClose set="method" line="590"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleStreamClose>
		<handleStreamOpen set="method" line="586"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleDisconnect set="method" line="581"><f a="?e">
	<c path="String"/>
	<x path="Void"/>
</f></handleDisconnect>
		<handleConnect set="method" line="575"><f a=""><x path="Void"/></f></handleConnect>
		<processStreamInit set="method" line="571"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<resetBuffer set="method" line="548"><f a=""><x path="Void"/></f></resetBuffer>
		<buffer set="method" line="543"><f a="t">
	<c path="String"/>
	<x path="Void"/>
</f></buffer>
		<handlePacket public="1" set="method" line="479">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Handles incoming XMPP packets.
		Returns true if the packet got handled.</haxe_doc>
		</handlePacket>
		<handleXml public="1" set="method" line="465">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="xmpp.Packet"/></c>
			</f>
			<haxe_doc>Inject incoming XML data.
		Returns array of handled XMPP packets.</haxe_doc>
		</handleXml>
		<handleString public="1" set="method" line="377">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleString>
		<handleData public="1" set="method" line="366">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleData>
		<removeInterceptor public="1" set="method" line="360">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeInterceptor>
		<addInterceptor public="1" set="method" line="351">
			<f a="i">
				<t path="jabber.PacketInterceptor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</addInterceptor>
		<removeCollector public="1" set="method" line="342">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</removeCollector>
		<addCollector public="1" set="method" line="333">
			<f a="c">
				<c path="jabber.PacketCollector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Adds a XMPP packet collector to this stream and starts the timeout if not null.</haxe_doc>
		</addCollector>
		<addIDCollector public="1" set="method" line="324">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Adds an packet collector which filters XMPP packets by ids.
		These collectors get processed before any other.</haxe_doc>
		</addIDCollector>
		<collect public="1" set="method" line="315">
			<f a="filters:handler:?permanent">
				<t path="Iterable"><t path="xmpp.PacketFilter"/></t>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<c path="jabber.PacketCollector"/>
			</f>
			<haxe_doc>Creates, adds and returns a XMPP packet collector.</haxe_doc>
		</collect>
		<interceptPacket public="1" set="method" line="307">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Runs the XMPP packet interceptor on the given packet.</haxe_doc>
		</interceptPacket>
		<sendBytes public="1" set="method" line="296"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></sendBytes>
		<sendData public="1" set="method" line="275">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Send raw string.</haxe_doc>
		</sendData>
		<sendPacket public="1" params="T" set="method" line="264">
			<f a="p:?intercept">
				<c path="sendPacket.T"/>
				<x path="Bool"/>
				<c path="sendPacket.T"/>
			</f>
			<haxe_doc>Intercept/Send/Return XMPP packet.</haxe_doc>
		</sendPacket>
		<sendIQResult public="1" get="inline" set="null" line="257">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create and send the resulting iq for given request</haxe_doc>
		</sendIQResult>
		<sendIQ public="1" set="method" line="239">
			<f a="iq:?handler">
				<c path="xmpp.IQ"/>
				<f a="">
					<c path="xmpp.IQ"/>
					<x path="Void"/>
				</f>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Send an IQ packet and forwards the response to the given handler function.</haxe_doc>
		</sendIQ>
		<sendPresenceTo public="1" get="inline" set="null" line="230">
			<f a="jid:?show:?status:?priority:?type">
				<c path="String"/>
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send directed presence</haxe_doc>
		</sendPresenceTo>
		<sendPresence public="1" set="method" line="223">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Send a presence packet.</haxe_doc>
		</sendPresence>
		<sendMessage public="1" set="method" line="216">
			<f a="to:body:?subject:?type:?thread:?from">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="xmpp.MessageType"/>
				<c path="String"/>
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Send a message packet (default type is 'chat').</haxe_doc>
		</sendMessage>
		<close public="1" set="method" line="201">
			<f a="?disconnect">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Closes the XMPP stream.<br/>
		Passed argument indicates if the data connection to the server should also get disconnected.]]></haxe_doc>
		</close>
		<open public="1" set="method" line="185">
			<f a="jid">
				<c path="jabber.JID"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Open the XMPP stream.</haxe_doc>
		</open>
		<nextID public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>Create/Returns the next unique id for this XMPP stream</haxe_doc>
		</nextID>
		<set_cnx set="method" line="146"><f a="c">
	<c path="jabber.StreamConnection"/>
	<c path="jabber.StreamConnection"/>
</f></set_cnx>
		<set_jid set="method" line="140"><f a="j">
	<c path="jabber.JID"/>
	<c path="jabber.JID"/>
</f></set_jid>
		<numPacketsSent><x path="Int"/></numPacketsSent>
		<interceptors><c path="Array"><t path="jabber.PacketInterceptor"/></c></interceptors>
		<collectors><c path="Array"><c path="jabber.PacketCollector"/></c></collectors>
		<collectors_id><c path="Array"><c path="jabber.PacketCollector"/></c></collectors_id>
		<buf><c path="StringBuf"/></buf>
		<maxBufSize public="1">
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</maxBufSize>
		<bufSize public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Incoming data buffer size</haxe_doc>
		</bufSize>
		<dataInterceptors public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataInterceptor"/></c>
			<haxe_doc></haxe_doc>
		</dataInterceptors>
		<dataFilters public="1" set="null">
			<c path="Array"><t path="jabber.StreamDataFilter"/></c>
			<haxe_doc></haxe_doc>
		</dataFilters>
		<jid public="1" set="accessor">
			<c path="jabber.JID"/>
			<haxe_doc>Jabber-id of this entity</haxe_doc>
		</jid>
		<lang public="1" set="null">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</lang>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>Stream-id</haxe_doc>
		</id>
		<server public="1" set="null">
			<t path="jabber._Stream.Server"/>
			<haxe_doc></haxe_doc>
		</server>
		<features public="1" set="null">
			<c path="jabber._Stream.StreamFeatures"/>
			<haxe_doc>Clients stream features</haxe_doc>
		</features>
		<cnx public="1" set="accessor">
			<c path="jabber.StreamConnection"/>
			<haxe_doc>The connection used to transport xmpp data</haxe_doc>
		</cnx>
		<status public="1">
			<e path="jabber.StreamStatus"/>
			<haxe_doc>Current status of the XMPP stream</haxe_doc>
		</status>
		<onClose public="1" set="dynamic" line="92">
			<f a="?e">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when the XMPP stream closes, optionally reporting stream errors if occured</haxe_doc>
		</onClose>
		<onOpen public="1" set="dynamic" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the XMPP stream is opened and ready to exchange XMPP data</haxe_doc>
		</onOpen>
		<new set="method" line="133"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for handling a XMPP data stream to and from another entity.
	
	See: http://xmpp.org/rfcs/rfc6120.html#streams</haxe_doc>
	</class>
	<class path="jabber.StreamConnection" params="" file="../../jabber/StreamConnection.hx">
		<writeBytes public="1" set="method" line="111">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send raw bytes, returns true on succeess</haxe_doc>
		</writeBytes>
		<write public="1" set="method" line="103">
			<f a="t">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send a string, returns true on succeess</haxe_doc>
		</write>
		<read public="1" set="method" line="95">
			<f a="?yes">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Starts/Stops reading data input, returns true if successfully started</haxe_doc>
		</read>
		<setSecure public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</setSecure>
		<disconnect public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</disconnect>
		<connect public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</connect>
		<set_host set="method" line="68"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_host>
		<http public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this data connection is a HTTP (BOSH) connection (default is false)</haxe_doc>
		</http>
		<secured public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if TLS is negotiation is complete and data transfered is encrypted</haxe_doc>
		</secured>
		<secure public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if this is a secure connection (TLS negotiation complete)</haxe_doc>
		</secure>
		<connected public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates if connected and ready to read and write.</haxe_doc>
		</connected>
		<host public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>Hostname or IP address of the XMPP server.</haxe_doc>
		</host>
		<__onSecured public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>TLS negotiation complete callback</haxe_doc>
		</__onSecured>
		<__onString public="1">
			<f a="">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>String recieved callback</haxe_doc>
		</__onString>
		<__onData public="1">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Bytes recieved callback</haxe_doc>
		</__onData>
		<__onDisconnect public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Disconnected callback. Parameter is an optional error message</haxe_doc>
		</__onDisconnect>
		<__onConnect public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Succesfully connected callback</haxe_doc>
		</__onConnect>
		<new set="method" line="61"><f a="host:secure:?http">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for XMPP stream connections.</haxe_doc>
	</class>
	<typedef path="jabber.StreamDataFilter" params="" file="../../jabber/StreamDataFilter.hx"><a><filterData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Filter raw incoming data before processing</haxe_doc>
</filterData></a></typedef>
	<typedef path="jabber.StreamDataInterceptor" params="" file="../../jabber/StreamDataInterceptor.hx"><a><interceptData set="method">
	<f a="data">
		<c path="haxe.io.Bytes"/>
		<c path="haxe.io.Bytes"/>
	</f>
	<haxe_doc>Modify raw outgoing XMPP data before sending</haxe_doc>
</interceptData></a></typedef>
	<enum path="jabber.StreamStatus" params="" file="../../jabber/StreamStatus.hx">
		<closed><haxe_doc>XMPP stream is inactive.</haxe_doc></closed>
		<pending><haxe_doc>Request to open XMPP stream sent but no response so far.</haxe_doc></pending>
		<starttls><haxe_doc>TLS negotiation in progress.</haxe_doc></starttls>
		<open><haxe_doc>XMPP stream is open and ready to exchange data.</haxe_doc></open>
	</enum>
	<class path="jabber.UserSearch" params="" file="../../jabber/UserSearch.hx">
		<sendIQ set="method" line="56"><f a="iq:h">
	<c path="xmpp.IQ"/>
	<f a=":">
		<c path="String"/>
		<c path="xmpp.UserSearch"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendIQ>
		<search public="1" set="method" line="46"><f a="jid:item">
	<c path="String"/>
	<t path="xmpp.UserSearchItem"/>
	<x path="Void"/>
</f></search>
		<requestFields public="1" set="method" line="39"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></requestFields>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onError public="1" set="dynamic" line="31"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onResult public="1" set="dynamic" line="30"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onResult>
		<onFields public="1" set="dynamic" line="29"><f a="jid:l">
	<c path="String"/>
	<c path="xmpp.UserSearch"/>
	<x path="Void"/>
</f></onFields>
		<new public="1" set="method" line="35"><f a="stream">
	<c path="jabber.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0055: Search: http://xmpp.org/extensions/xep-0055.html</haxe_doc>
	</class>
	<class path="jabber.XMPPDebug" params="" file="../../jabber/XMPPDebug.hx">
		<active public="1" line="80" static="1">
			<x path="Bool"/>
			<haxe_doc>Activate/Deactivate output.
		Default is true.</haxe_doc>
		</active>
		<lastPrintWasOutgoing public="1" set="null" line="83" static="1">
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</lastPrintWasOutgoing>
		<beautify public="1" line="91" static="1">
			<x path="Bool"/>
			<haxe_doc>Indicates if the XMPP debug output should get formatted/beautified.
		Mind: If active, it is not ensured that the formatted string matches exactly the sent/recieved ones!
		Default value is false.
		Currently only supported in terminal targets.</haxe_doc>
		</beautify>
		<showDate public="1" line="96" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current date in meta information</haxe_doc>
		</showDate>
		<showTime public="1" line="101" static="1">
			<x path="Bool"/>
			<haxe_doc>Toggle print the current time in meta information</haxe_doc>
		</showTime>
		<i public="1" get="inline" set="null" line="106" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print incoming XMPP data</haxe_doc>
		</i>
		<o public="1" get="inline" set="null" line="113" static="1">
			<f a="t">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print outgoing XMPP data</haxe_doc>
		</o>
		<print public="1" set="method" line="124" static="1">
			<f a="t:out:?level">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print manually to console</haxe_doc>
		</print>
		<color_out public="1" line="142" static="1"><x path="Int"/></color_out>
		<color_inc public="1" line="143" static="1"><x path="Int"/></color_inc>
		<__print public="1" set="method" line="147" static="1">
			<f a="t:?color">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</__print>
		<haxe_doc>Utility for debugging XMPP transfer.
	Set the compiler flag: -D xmpp_debug to activate it.
	
	* Terminal targets: Color highlighted
	* Browser targets: Printed to the default debug console
	* Adobe air: Printed to fdb 'trace'</haxe_doc>
		<meta><m n=":require"><e>xmpp_debug</e></m></meta>
	</class>
	<class path="xmpp.ErrorPacket" params="" file="../../xmpp/ErrorPacket.hx">
		<parseInto set="method" line="72" static="1"><f a="p:x:xmlns">
	<c path="xmpp.ErrorPacket"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Bool"/>
</f></parseInto>
		<_toXml set="method" line="53"><f a="p:ns">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
</f></_toXml>
		<app public="1">
			<t path="xmpp.ApplicationErrorCondition"/>
			<haxe_doc>Application-specific error condition</haxe_doc>
		</app>
		<lang public="1">
			<c path="String"/>
			<haxe_doc>Language of the text content XML character data</haxe_doc>
		</lang>
		<text public="1">
			<c path="String"/>
			<haxe_doc>Describes the error in more detail</haxe_doc>
		</text>
		<condition public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</condition>
		<new set="method" line="45"><f a="condition:?text:?lang:?app">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base class for xmpp.Error and xmpp.StreamError</haxe_doc>
	</class>
	<class path="xmpp.Error" params="" file="../../xmpp/Error.hx">
		<extends path="xmpp.ErrorPacket"/>
		<XMLNS public="1" set="null" line="30" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Error"/>
</f></parse>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<code public="1"><t path="Null"><x path="Int"/></t></code>
		<type public="1"><e path="xmpp.ErrorType"/></type>
		<new public="1" set="method" line="35"><f a="type:condition:?code:?text:?lang:?app">
	<e path="xmpp.ErrorType"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<t path="xmpp.ApplicationErrorCondition"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.XMPPError" params="" file="../../jabber/XMPPError.hx">
		<extends path="xmpp.Error"/>
		<toString public="1" set="method" line="37"><f a=""><c path="String"/></f></toString>
		<from public="1" set="null"><c path="String"/></from>
		<new public="1" set="method" line="31"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Used to dispatch and track XMPP protocol errors.</haxe_doc>
	</class>
	<class path="jabber.client.Account" params="" file="../../jabber/client/Account.hx">
		<changePassword public="1" set="method" line="145">
			<f a="node:pass">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change account password.</haxe_doc>
		</changePassword>
		<remove public="1" set="method" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Delete account from server.</haxe_doc>
		</remove>
		<register public="1" set="method" line="87">
			<f a="reg">
				<c path="xmpp.Register"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Register new account.</haxe_doc>
		</register>
		<requestRegistrationFields public="1" set="method" line="55">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Request required registration fields from server</haxe_doc>
		</requestRegistrationFields>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<onError public="1" set="dynamic" line="44">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<onPasswordChange public="1" set="dynamic" line="41">
			<f a="pass">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for password change success</haxe_doc>
		</onPasswordChange>
		<onRemove public="1" set="dynamic" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback for account remove success</haxe_doc>
		</onRemove>
		<onRegister public="1" set="dynamic" line="35">
			<f a="node">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for account registering success</haxe_doc>
		</onRegister>
		<onFields public="1" set="dynamic" line="32">
			<f a="fields">
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Callback for recieved registration fields</haxe_doc>
		</onFields>
		<new public="1" set="method" line="48"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration: http://www.xmpp.org/extensions/xep-0077.html</haxe_doc>
	</class>
	<class path="jabber.client.AuthenticationBase" params="" file="../../jabber/client/AuthenticationBase.hx">
		<start public="1" set="method" line="48">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Start the authentication process.</haxe_doc>
		</start>
		<stream public="1" set="null">
			<c path="jabber.client.Stream"/>
			<haxe_doc></haxe_doc>
		</stream>
		<resource public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid resource to authenticate</haxe_doc>
		</resource>
		<onFail public="1" set="dynamic" line="33">
			<f a="info">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Authenication failed callback</haxe_doc>
		</onFail>
		<onSuccess public="1" set="dynamic" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Authenication was success full callback</haxe_doc>
		</onSuccess>
		<new set="method" line="41"><f a="s">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract client account authentication class.</haxe_doc>
	</class>
	<class path="jabber.client.Authentication" params="" file="../../jabber/client/Authentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<removeSASLCollectors set="method" line="176"><f a=""><x path="Void"/></f></removeSASLCollectors>
		<handleSession set="method" line="165"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSession>
		<handleBind set="method" line="141"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleBind>
		<handleStreamOpen set="method" line="130"><f a=""><x path="Void"/></f></handleStreamOpen>
		<handleSASLSuccess set="method" line="119"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLSuccess>
		<handleSASLChallenge set="method" line="113"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLChallenge>
		<handleSASLFailed set="method" line="105"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Void"/>
</f></handleSASLFailed>
		<start public="1" set="method" line="76" override="1">
			<f a="password:?resource">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Inits SASL authentication.
		Returns false if no supported SASL mechanism got offered by the server.</haxe_doc>
		</start>
		<c_success><c path="jabber.PacketCollector"/></c_success>
		<c_fail><c path="jabber.PacketCollector"/></c_fail>
		<c_challenge><c path="jabber.PacketCollector"/></c_challenge>
		<onStreamOpenHandler><f a=""><x path="Void"/></f></onStreamOpenHandler>
		<mechanism public="1" set="null">
			<t path="jabber.sasl.Mechanism"/>
			<haxe_doc>Used SASL method</haxe_doc>
		</mechanism>
		<serverMechanisms public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>Available SASL mechanisms offered by server</haxe_doc>
		</serverMechanisms>
		<mechanisms public="1" set="null">
			<c path="Array"><t path="jabber.sasl.Mechanism"/></c>
			<haxe_doc>Clients SASL mechanisms (in prefered order)</haxe_doc>
		</mechanisms>
		<onNegotiated public="1" set="dynamic" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Callback on SASL negotiation completed</haxe_doc>
		</onNegotiated>
		<new public="1" set="method" line="59"><f a="stream:mechanisms">
	<c path="jabber.client.Stream"/>
	<t path="Iterable"><t path="jabber.sasl.Mechanism"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>SASL client authentication.

	Responsible for:
		* Authenticating a client account using SASL
		* Binding the resource to the connection
		* Establishing a session with the server

	RFC3920-SASL http://xmpp.org/rfcs/rfc3920.html#sasl
	RFC3920-BIND http://xmpp.org/rfcs/rfc3920.html#bind</haxe_doc>
	</class>
	<class path="jabber.client.GMailNotify" params="" file="../../jabber/client/GMailNotify.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<handleNotification set="method" line="77"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleNotification>
		<dispose public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops collecting/reporting mail notifications.
		This does NOT unsubscribe from getting mail notifications (currently not provided by the service).</haxe_doc>
		</dispose>
		<request public="1" set="method" line="57">
			<f a="?newerThanTime:?newerThanTid:?q">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param newerThanTime The time of the oldest unread email to retrieve, in milliseconds
		
		@param newerThanTid The highest thread number of messages to return, where higher numbers are more recent email threads.
		The server will return only threads newer than that specified by this attribute.
		If using this attribute, you should also use newer-than-time for best results.
		When querying for the first time, you should omit this value.
		
		@param q Specifies an optional search query string.
		This string uses the same syntax as the search box in Gmail, including supported operators.
		
		The server will also subscribe the client to receive notifications when new mail is received.</haxe_doc>
		</request>
		<c><c path="jabber.PacketCollector"/></c>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<onMail public="1" set="dynamic" line="34"><f a="m">
	<c path="Xml"/>
	<x path="Void"/>
</f></onMail>
		<new public="1" set="method" line="40"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A custom google extension to XMPP to enable users to query their Gmail account for emails,
	and receive notifications when a new message arrives.

	https://developers.google.com/talk/jep_extensions/gmail</haxe_doc>
	</class>
	<class path="jabber.client.MUCOccupant" params="" file="../../jabber/client/MUChat.hx" module="jabber.client.MUChat">
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<presence public="1"><c path="xmpp.Presence"/></presence>
		<jid public="1"><c path="String"/></jid>
		<nick public="1"><c path="String"/></nick>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="jabber.client.MUChat" params="" file="../../jabber/client/MUChat.hx">
		<destroy set="method" line="453"><f a=""><x path="Void"/></f></destroy>
		<getOccupantName get="inline" set="null" line="449"><f a="j">
	<c path="String"/>
	<c path="String"/>
</f></getOccupantName>
		<sendMyPresence set="method" line="436"><f a="?priority">
	<x path="Int"/>
	<c path="xmpp.Presence"/>
</f></sendMyPresence>
		<handlePresence set="method" line="275"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<handleMessage set="method" line="251"><f a="m">
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></handleMessage>
		<invite public="1" set="method" line="231">
			<f a="jid:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends an (mediated) invitation message to the given entity .</haxe_doc>
		</invite>
		<kick public="1" set="method" line="201">
			<f a="nick:?reason">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</kick>
		<changeNick public="1" set="method" line="190">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeNick>
		<changeSubject public="1" set="method" line="179">
			<f a="t">
				<c path="String"/>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc></haxe_doc>
		</changeSubject>
		<speak public="1" set="method" line="169">
			<f a="t:?properties">
				<c path="String"/>
				<c path="Array"><c path="Xml"/></c>
				<c path="xmpp.Message"/>
			</f>
			<haxe_doc>Sends message to all room occupants.</haxe_doc>
		</speak>
		<sendPresence public="1" set="method" line="159">
			<f a="?show:?status:?priority:?type">
				<e path="xmpp.PresenceShow"/>
				<c path="String"/>
				<x path="Int"/>
				<e path="xmpp.PresenceType"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc></haxe_doc>
		</sendPresence>
		<leave public="1" set="method" line="145">
			<f a="?message">
				<c path="String"/>
				<c path="xmpp.Presence"/>
			</f>
			<haxe_doc>Sends unavailable presence to the room, exits room.</haxe_doc>
		</leave>
		<join public="1" set="method" line="130">
			<f a="nick:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Sends initial presence to room.</haxe_doc>
		</join>
		<getOccupant public="1" set="method" line="121"><f a="nick">
	<c path="String"/>
	<c path="jabber.client.MUCOccupant"/>
</f></getOccupant>
		<get_me set="method" line="104"><f a=""><c path="jabber.client.MUCOccupant"/></f></get_me>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<message><c path="xmpp.Message"/></message>
		<presence><c path="xmpp.Presence"/></presence>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<me public="1" get="accessor" set="null"><c path="jabber.client.MUCOccupant"/></me>
		<subject public="1" set="null"><c path="String"/></subject>
		<occupants public="1" set="null"><c path="Array"><c path="jabber.client.MUCOccupant"/></c></occupants>
		<affiliation public="1" set="null"><e path="xmpp.muc.Affiliation"/></affiliation>
		<role public="1" set="null"><e path="xmpp.muc.Role"/></role>
		<password public="1" set="null"><c path="String"/></password>
		<nick public="1" set="null"><c path="String"/></nick>
		<myjid public="1" set="null"><c path="String"/></myjid>
		<joined public="1" set="null"><x path="Bool"/></joined>
		<room public="1" set="null"><c path="String"/></room>
		<jid public="1" set="null"><c path="String"/></jid>
		<onError public="1" set="dynamic" line="63"><f a="e">
	<c path="jabber.XMPPError"/>
	<x path="Void"/>
</f></onError>
		<onKick public="1" set="dynamic" line="62"><f a="nick">
	<c path="String"/>
	<x path="Void"/>
</f></onKick>
		<onSubject public="1" set="dynamic" line="61"><f a="o:t">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></onSubject>
		<onPresence public="1" set="dynamic" line="60"><f a="o">
	<c path="jabber.client.MUCOccupant"/>
	<x path="Void"/>
</f></onPresence>
		<onMessage public="1" set="dynamic" line="58"><f a="o:m">
	<c path="jabber.client.MUCOccupant"/>
	<c path="xmpp.Message"/>
	<x path="Void"/>
</f></onMessage>
		<onUnlock public="1" set="dynamic" line="57"><f a=""><x path="Void"/></f></onUnlock>
		<onLeave public="1" set="dynamic" line="56"><f a=""><x path="Void"/></f></onLeave>
		<onJoin public="1" set="dynamic" line="55"><f a=""><x path="Void"/></f></onJoin>
		<new public="1" set="method" line="84"><f a="stream:host:roomName">
	<c path="jabber.client.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Multiuser chatroom.

	http://www.xmpp.org/extensions/xep-0045.html
	http://www.xmpp.org/extensions/xep-0249.html</haxe_doc>
	</class>
	<class path="jabber.client.NonSASLAuthentication" params="" file="../../jabber/client/NonSASLAuthentication.hx">
		<extends path="jabber.client.AuthenticationBase"/>
		<handleResult set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResult>
		<handleResponse set="method" line="64"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleResponse>
		<start public="1" set="method" line="48" override="1"><f a="password:?resource">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></start>
		<password public="1" set="null"><c path="String"/></password>
		<username public="1" set="null"><c path="String"/></username>
		<usePlainText public="1" set="null"><x path="Bool"/></usePlainText>
		<active public="1" set="null"><x path="Bool"/></active>
		<new public="1" set="method" line="37"><f a="stream:?usePlainText">
	<c path="jabber.client.Stream"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Obsolete, superseded in favor of SASL authentication (jabber.client.Authentication)!
	<a href="http://xmpp.org/extensions/xep-0078.html">XEP-0078: Non-SASL Authentication</a>]]></haxe_doc>
	</class>
	<enum path="jabber.client.RosterSubscriptionMode" params="" file="../../jabber/client/RosterSubscriptionMode.hx">
		<rejectAll><haxe_doc>Reject all subscription requests.</haxe_doc></rejectAll>
		<manual><haxe_doc>Ask how to proceed.</haxe_doc></manual>
		<acceptAll a="subscribe">
			<x path="Bool"/>
			<haxe_doc>Accept all subscription and unsubscription requests.</haxe_doc>
		</acceptAll>
		<haxe_doc>Configuration how to handle recieved presence subscriptions</haxe_doc>
	</enum>
	<class path="jabber.client.Roster" params="" file="../../jabber/client/Roster.hx">
		<defaultSubscriptionMode public="1" line="39" static="1"><e path="jabber.client.RosterSubscriptionMode"/></defaultSubscriptionMode>
		<handlePresence set="method" line="316"><f a="p">
	<c path="xmpp.Presence"/>
	<x path="Void"/>
</f></handlePresence>
		<handleIQ set="method" line="270"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<sendAddItemRequest set="method" line="247"><f a="jid:?groups">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></sendAddItemRequest>
		<sendPresence set="method" line="241"><f a="jid:type">
	<c path="String"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></sendPresence>
		<confirmSubscription public="1" set="method" line="231">
			<f a="jid:?allow:?subscribe">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the requesting entity to recieve presence updates from you.</haxe_doc>
		</confirmSubscription>
		<cancelSubscription public="1" set="method" line="223">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Cancel the subscription from entity.
		You will no longer recieve presence updates.</haxe_doc>
		</cancelSubscription>
		<unsubscribe public="1" set="method" line="207">
			<f a="jid:?cancelSubscription">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Unsubscribe from entities presence.
		The entity will no longer recieve presence updates.</haxe_doc>
		</unsubscribe>
		<subscribe public="1" set="method" line="180">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Subscribe to the presence of the entity.
		You will get presence updates from this entity (if confirmed).</haxe_doc>
		</subscribe>
		<removeItem public="1" set="method" line="156">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove entry from remote roster</haxe_doc>
		</removeItem>
		<addItem public="1" set="method" line="146">
			<f a="jid:?groups">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Add entry to your roster</haxe_doc>
		</addItem>
		<load public="1" set="method" line="132">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</load>
		<hasItem public="1" get="inline" set="null" line="126">
			<f a="jid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc></haxe_doc>
		</hasItem>
		<getItem public="1" set="method" line="119">
			<f a="jid">
				<c path="String"/>
				<c path="xmpp.roster.Item"/>
			</f>
			<haxe_doc></haxe_doc>
		</getItem>
		<dispose public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</dispose>
		<get_groups set="method" line="91"><f a=""><c path="Array"><c path="String"/></c></f></get_groups>
		<c_message><c path="jabber.PacketCollector"/></c_message>
		<c_presence><c path="jabber.PacketCollector"/></c_presence>
		<groups public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></groups>
		<items public="1" set="null"><c path="Array"><c path="xmpp.roster.Item"/></c></items>
		<available public="1" set="null"><x path="Bool"/></available>
		<subscriptionMode public="1"><e path="jabber.client.RosterSubscriptionMode"/></subscriptionMode>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<onError public="1" set="dynamic" line="69">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc>A roster manipulation error occured</haxe_doc>
		</onError>
		<onUnsubscription public="1" set="dynamic" line="66">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact unsubscribed from your presence</haxe_doc>
		</onUnsubscription>
		<onSubscription public="1" set="dynamic" line="63">
			<f a="jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Contact subscribed to your presence</haxe_doc>
		</onSubscription>
		<onAsk public="1" set="dynamic" line="60">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Incoming presence subscription request</haxe_doc>
		</onAsk>
		<onUnsubscribed public="1" set="dynamic" line="57">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Unsubscribed presence of the contact</haxe_doc>
		</onUnsubscribed>
		<onSubscribed public="1" set="dynamic" line="54">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subscribed to the presence of the contact</haxe_doc>
		</onSubscribed>
		<onUpdate public="1" set="dynamic" line="51">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got updated</haxe_doc>
		</onUpdate>
		<onRemove public="1" set="dynamic" line="48">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got removed from your roster</haxe_doc>
		</onRemove>
		<onAdd public="1" set="dynamic" line="45">
			<f a="i">
				<c path="xmpp.roster.Item"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Item got added to the roster</haxe_doc>
		</onAdd>
		<onLoad public="1" set="dynamic" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Roster got loaded</haxe_doc>
		</onLoad>
		<new public="1" set="method" line="80"><f a="stream:?subscriptionMode">
	<c path="jabber.client.Stream"/>
	<e path="jabber.client.RosterSubscriptionMode"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client roster (serverside saved contact list)</haxe_doc>
	</class>
	<class path="jabber.client.Stream" params="" file="../../jabber/client/Stream.hx">
		<extends path="jabber.Stream"/>
		<PORT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></PORT>
		<PORT_SECURE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></PORT_SECURE>
		<defaultPort public="1" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for socket connections</haxe_doc>
		</defaultPort>
		<defaultPortSecure public="1" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>The default port for secure socket connections</haxe_doc>
		</defaultPortSecure>
		<parseServerStreamFeatures set="method" line="136"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></parseServerStreamFeatures>
		<processStreamInit set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></processStreamInit>
		<handleConnect set="method" line="56" override="1"><f a=""><x path="Void"/></f></handleConnect>
		<version><x path="Bool"/></version>
		<new public="1" set="method" line="48"><f a="cnx:?maxBufSize">
	<c path="jabber.StreamConnection"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Client-Server XMPP stream.

	See: http://xmpp.org/rfcs/rfc6120.html#examples-c2s</haxe_doc>
	</class>
	<class path="jabber.client.VCardBase" params="T" file="../../jabber/client/VCardBase.hx">
		<handleUpdate set="method" line="84"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleUpdate>
		<_handleLoad set="method" line="78"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<handleLoad set="method" line="67"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleLoad>
		<_load set="method" line="61"><f a="x:jid">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></_load>
		<update public="1" set="method" line="55">
			<f a="vc">
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Update own vcard.</haxe_doc>
		</update>
		<load public="1" set="method" line="48">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or own no jid is given.</haxe_doc>
		</load>
		<stream public="1" set="null"><c path="jabber.client.Stream"/></stream>
		<onError public="1" set="dynamic" line="37">
			<f a="e">
				<c path="jabber.XMPPError"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</onError>
		<onUpdate public="1" set="dynamic" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Own vcard updated callback</haxe_doc>
		</onUpdate>
		<onLoad public="1" set="dynamic" line="33">
			<f a="jid:data">
				<c path="String"/>
				<c path="jabber.client.VCardBase.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>VCard loaded callback</haxe_doc>
		</onLoad>
		<new set="method" line="41"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for vcard classes (jabber.client.VCard and jabber.client.VCardTemp)</haxe_doc>
	</class>
	<class path="jabber.client.VCardTemp" params="" file="../../jabber/client/VCardTemp.hx">
		<extends path="jabber.client.VCardBase"><c path="xmpp.VCardTemp"/></extends>
		<_handleLoad set="method" line="42" override="1"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></_handleLoad>
		<load public="1" set="method" line="38" override="1">
			<f a="?jid">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Requests to load the vcard from the given entity or from its own if jid is null.</haxe_doc>
		</load>
		<new public="1" set="method" line="31"><f a="stream">
	<c path="jabber.client.Stream"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html

	Depricated but still widely implementd by servers (use jabber.client.VCard)</haxe_doc>
	</class>
	<class path="jabber.lop.Farm" params="" file="../../jabber/lop/Farm.hx">
		<createFormField set="method" line="199" static="1"><f a="name:value:type">
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.dataform.FieldType"/>
	<c path="xmpp.dataform.Field"/>
</f></createFormField>
		<createFormFieldMulti set="method" line="206" static="1"><f a="name:values">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<c path="xmpp.dataform.Field"/>
</f></createFormFieldMulti>
		<getDataForm public="1" set="method" line="179">
			<f a=""><c path="xmpp.DataForm"/></f>
			<haxe_doc>Generate a dataform of this farms settings.</haxe_doc>
		</getDataForm>
		<handleIQ public="1" set="method" line="87">
			<f a="iq">
				<c path="xmpp.IQ"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</handleIQ>
		<perform_multicast public="1"><t path="Null"><x path="Bool"/></t></perform_multicast>
		<accept_connection public="1"><t path="Null"><x path="Bool"/></t></accept_connection>
		<listen_for_connection public="1"><t path="Null"><x path="Bool"/></t></listen_for_connection>
		<open_connection public="1"><t path="Null"><x path="Bool"/></t></open_connection>
		<delete_file public="1"><c path="Array"><c path="String"/></c></delete_file>
		<write_file public="1"><c path="Array"><c path="String"/></c></write_file>
		<read_file public="1"><c path="Array"><c path="String"/></c></read_file>
		<farm_start_time public="1"><c path="String"/></farm_start_time>
		<max_concurrent_vms public="1"><t path="Null"><x path="Int"/></t></max_concurrent_vms>
		<job_queue_capacity public="1"><t path="Null"><x path="Int"/></t></job_queue_capacity>
		<job_timeout public="1"><x path="Float"/></job_timeout>
		<vm_time_to_live public="1"><x path="Float"/></vm_time_to_live>
		<vm_species public="1"><c path="String"/></vm_species>
		<ip public="1"><c path="String"/></ip>
		<password public="1" set="null"><c path="String"/></password>
		<species public="1" set="null"><x path="Map">
	<c path="String"/>
	<f a=":">
		<c path="jabber.JID"/>
		<c path="xmpp.lop.SpawnVM"/>
		<c path="String"/>
	</f>
</x></species>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<onGetBindings public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<c path="xmpp.lop.Bindings"/>
</f></onGetBindings>
		<onSetBindings public="1" set="dynamic" line="41"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onSetBindings>
		<onPing public="1" set="dynamic" line="40"><f a="ping">
	<c path="xmpp.lop.Ping"/>
	<c path="String"/>
</f></onPing>
		<onVMKill public="1" set="dynamic" line="39"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></onVMKill>
		<onJob public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<c path="String"/>
</f></onJob>
		<new public="1" set="method" line="63"><f a="stream:?password:?vm_species:?vm_time_to_live:?job_timeout">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Manages the spawning of virtual machines.
	The disco 'identity' of a farm MUST be of category="client" and type="bot" (name is up to the implementation).
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html</haxe_doc>
	</class>
	<class path="jabber.lop.Villein" params="" file="../../jabber/lop/Villein.hx">
		<handleSetBindings set="method" line="179"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleSetBindings>
		<handleGetBindings set="method" line="167"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleGetBindings>
		<handleTerminate set="method" line="155"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleTerminate>
		<handlePing set="method" line="144"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handlePing>
		<handleJob set="method" line="131"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleJob>
		<handleVMSpawn set="method" line="121"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleVMSpawn>
		<terminateVM public="1" set="method" line="115">
			<f a="vm_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</terminateVM>
		<setBindings public="1" set="method" line="102">
			<f a="id:list">
				<c path="String"/>
				<t path="Iterable"><t path="xmpp.lop.Binding"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</setBindings>
		<getBindings public="1" set="method" line="91">
			<f a="id:names">
				<c path="String"/>
				<t path="Iterable"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</getBindings>
		<abortJob public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</abortJob>
		<pingJob public="1" set="method" line="75">
			<f a="vm_id:job_id">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</pingJob>
		<submitJob public="1" set="method" line="66">
			<f a="id:job">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</submitJob>
		<spawnVM public="1" set="method" line="58">
			<f a="species:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc></haxe_doc>
		</spawnVM>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<farm public="1" set="null">
			<c path="String"/>
			<haxe_doc>The jid of the farm</haxe_doc>
		</farm>
		<onVariablesFail public="1" set="dynamic" line="45"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onVariablesFail>
		<onVariables public="1" set="dynamic" line="44"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onVariables>
		<onBindFail public="1" set="dynamic" line="43"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onBindFail>
		<onBind public="1" set="dynamic" line="42"><f a="bindings">
	<c path="xmpp.lop.Bindings"/>
	<x path="Void"/>
</f></onBind>
		<onTerminateFail public="1" set="dynamic" line="41"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onTerminateFail>
		<onTerminate public="1" set="dynamic" line="40"><f a="vm">
	<c path="String"/>
	<x path="Void"/>
</f></onTerminate>
		<onFail public="1" set="dynamic" line="39"><f a="id:e">
	<c path="String"/>
	<c path="xmpp.Error"/>
	<x path="Void"/>
</f></onFail>
		<onResult public="1" set="dynamic" line="38"><f a="job">
	<c path="xmpp.lop.Submit"/>
	<x path="Void"/>
</f></onResult>
		<onSpawn public="1" set="dynamic" line="37"><f a="s">
	<c path="xmpp.lop.SpawnVM"/>
	<x path="Void"/>
</f></onSpawn>
		<new public="1" set="method" line="51"><f a="stream:farm">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Communicates with a resource provider's farm in order to spawn and compute with virtual machines that leverage provided resources.<br/>
	
	Linked Process Protocol: http://xmpp.org/extensions/inbox/lop.html]]></haxe_doc>
	</class>
	<typedef path="jabber.net._SocketConnectionBase_sys.AbstractSocket" params="" file="../../jabber/net/SocketConnectionBase_sys.hx" private="1" module="jabber.net.SocketConnectionBase_sys"><a>
	<write set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
	<shutdown set="method"><f a="read:write">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></shutdown>
	<setTimeout set="method"><f a="t">
	<x path="Float"/>
	<x path="Void"/>
</f></setTimeout>
	<output set="null"><c path="haxe.io.Output"/></output>
	<input set="null"><c path="haxe.io.Input"/></input>
	<connect set="method"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
	<close set="method"><f a=""><x path="Void"/></f></close>
</a></typedef>
	<class path="jabber.net.SocketConnectionBase_sys" params="" file="../../jabber/net/SocketConnectionBase_sys.hx">
		<extends path="jabber.StreamConnection"/>
		<defaultBufSize public="1" line="42" static="1"><x path="Int"/></defaultBufSize>
		<defaultMaxBufSize public="1" line="43" static="1"><x path="Int"/></defaultMaxBufSize>
		<defaultTimeout public="1" line="44" static="1"><x path="Int"/></defaultTimeout>
		<error set="method" line="116"><f a="info">
	<c path="String"/>
	<x path="Void"/>
</f></error>
		<readData set="method" line="91"><f a=""><x path="Void"/></f></readData>
		<read public="1" set="method" line="79" override="1"><f a="?yes">
	<x path="Bool"/>
	<x path="Bool"/>
</f></read>
		<disconnect public="1" set="method" line="69" override="1"><f a=""><x path="Void"/></f></disconnect>
		<bufsize><x path="Int"/></bufsize>
		<bufpos><x path="Int"/></bufpos>
		<buf><c path="haxe.io.Bytes"/></buf>
		<reading public="1" set="null"><x path="Bool"/></reading>
		<socket public="1" set="null"><t path="jabber.net._SocketConnectionBase_sys.AbstractSocket"/></socket>
		<timeout public="1" set="null"><x path="Int"/></timeout>
		<maxbufsize public="1" set="null"><x path="Int"/></maxbufsize>
		<port public="1" set="null"><x path="Int"/></port>
		<new set="method" line="56"><f a="host:port:secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.net.SocketConnection_sys" params="" file="../../jabber/net/SocketConnection_sys.hx">
		<extends path="jabber.net.SocketConnectionBase_sys"/>
		<writeBytes public="1" set="method" line="86" override="1"><f a="t">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></writeBytes>
		<write public="1" set="method" line="72" override="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></write>
		<setSecure public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></setSecure>
		<connect public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></connect>
		<new public="1" set="method" line="30"><f a="?host:?port:?secure:?bufsize:?maxbufsize:?timeout">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="jabber.remoting.Connection" params="" file="../../jabber/remoting/Connection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" get="inline" set="null" line="103" static="1"><f a="stream:target">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="jabber.remoting.Connection"/>
</f></create>
		<call public="1" set="method" line="66"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></call>
		<setErrorHandler public="1" get="inline" set="null" line="62"><f a="h">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setErrorHandler>
		<resolve public="1" set="method" line="49"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__error><f a="">
	<d/>
	<x path="Void"/>
</f></__error>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<target public="1">
			<c path="String"/>
			<haxe_doc>Jid of opposite</haxe_doc>
		</target>
		<new set="method" line="42"><f a="stream:target:path:error">
	<c path="jabber.Stream"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>Haxe remoting connection to another XMPP entity.
	User ServiceDiscovery to determine if an entity supports haxe-remoting (hxr).

	http://haxe.org/doc/remoting</haxe_doc>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="jabber.remoting.Host" params="" file="../../jabber/remoting/Host.hx">
		<numActive public="1" set="null" static="1"><x path="Int"/></numActive>
		<processRequest public="1" set="method" line="75" static="1"><f a="data:ctx">
	<c path="String"/>
	<c path="haxe.remoting.Context"/>
	<c path="String"/>
</f></processRequest>
		<handleIQ set="method" line="60"><f a="iq">
	<c path="xmpp.IQ"/>
	<x path="Void"/>
</f></handleIQ>
		<close public="1" set="method" line="53"><f a=""><x path="Void"/></f></close>
		<c><c path="jabber.PacketCollector"/></c>
		<stream public="1" set="null"><c path="jabber.Stream"/></stream>
		<ctx public="1"><c path="haxe.remoting.Context"/></ctx>
		<client public="1" set="null">
			<c path="String"/>
			<haxe_doc>JID of current/last processed entity</haxe_doc>
		</client>
		<new public="1" set="method" line="45"><f a="stream:ctx">
	<c path="jabber.Stream"/>
	<c path="haxe.remoting.Context"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[HaXe remoting host.<br/>
	<a href="http://haxe.org/doc/remoting">http://haxe.org/doc/remoting</a>]]></haxe_doc>
	</class>
	<class path="jabber.sasl.LOGINMechanism" params="" file="../../jabber/sasl/LOGINMechanism.hx">
		<NAME public="1" get="inline" set="null" line="35" static="1"><c path="String"/></NAME>
		<createChallengeResponse public="1" set="method" line="56">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<createAuthenticationText public="1" set="method" line="48">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<nChallenges><x path="Int"/></nChallenges>
		<username><c path="String"/></username>
		<password><c path="String"/></password>
		<id public="1" set="null"><c path="String"/></id>
		<new public="1" get="inline" set="null" line="43"><f a=""><x path="Void"/></f></new>
		<haxe_doc>LOGIN SASL Mechanism.
	
	Obsolete clear-text user/password Simple Authentication and Security Layer (SASL) mechanism called the LOGIN mechanism.
	The LOGIN mechanism was intended to be used, in combination with data confidentiality services provided by a lower layer,
	in protocols which lack a simple password authentication command.

	http://tools.ietf.org/id/draft-murchison-sasl-login-00.txt</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Calculator" params="" file="../../jabber/sasl/MD5Calculator.hx">
		<parseChallenge public="1" set="method" line="35" static="1">
			<f a="challenge">
				<c path="String"/>
				<a>
					<realm><c path="String"/></realm>
					<nonce><c path="String"/></nonce>
				</a>
			</f>
			<haxe_doc>* Parses the initial challenge and returns calculated realm and nonce</haxe_doc>
		</parseChallenge>
		<run public="1" set="method" line="56" static="1">
			<f a="host:serverType:username:realm:pass:nonce">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Caluclate/Create the MD5 challenge response</haxe_doc>
		</run>
		<h get="inline" set="null" line="89" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></h>
		<hh get="inline" set="null" line="90" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></hh>
		<quote get="inline" set="null" line="91" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<unquote get="inline" set="null" line="92" static="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></unquote>
		<haxe_doc>Static methods for computing SASL-MD5 credentials.</haxe_doc>
	</class>
	<class path="jabber.sasl.MD5Mechanism" params="" file="../../jabber/sasl/MD5Mechanism.hx">
		<NAME public="1" get="inline" set="null" line="30" static="1"><c path="String"/></NAME>
		<createChallengeResponse public="1" set="method" line="55">
			<f a="challenge">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<createAuthenticationText public="1" set="method" line="46">
			<f a="username:host:pass:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<resource><c path="String"/></resource>
		<pass><c path="String"/></pass>
		<host><c path="String"/></host>
		<username><c path="String"/></username>
		<serverType public="1"><c path="String"/></serverType>
		<id public="1" set="null"><c path="String"/></id>
		<new public="1" set="method" line="40"><f a="?serverType">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Using Digest Authentication as a SASL Mechanism: ftp://ietf.org//rfc/rfc2831.txt
	SASL and DIGEST-MD5 for XMPP: http://web.archive.org/web/20050224191820/http://cataclysm.cx/wip/digest-md5-crash.html</haxe_doc>
	</class>
	<typedef path="jabber.sasl.Mechanism" params="" file="../../jabber/sasl/Mechanism.hx">
		<a>
			<id set="null">
				<c path="String"/>
				<haxe_doc>The id of this mechanism, for example PLAIN, DIGEST-MD5, ...</haxe_doc>
			</id>
			<createChallengeResponse set="method">
				<f a="challenge">
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createChallengeResponse>
			<createAuthenticationText set="method">
				<f a="user:host:password:resource">
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc></haxe_doc>
			</createAuthenticationText>
		</a>
		<haxe_doc>SASL mechanism type.</haxe_doc>
	</typedef>
	<class path="jabber.sasl.PlainMechanism" params="" file="../../jabber/sasl/PlainMechanism.hx">
		<NAME public="1" get="inline" set="null" line="32" static="1"><c path="String"/></NAME>
		<createChallengeResponse public="1" get="inline" set="null" line="51">
			<f a="c">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createChallengeResponse>
		<createAuthenticationText public="1" get="inline" set="null" line="41">
			<f a="username:host:password:resource">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</createAuthenticationText>
		<id public="1" set="null"><c path="String"/></id>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The PLAIN mechanism should not be used without adequate data security protection
	as this mechanism affords no integrity or confidentiality protections itself.
	
	The PLAIN Simple Authentication and Security Layer (SASL) Mechanism: http://www.ietf.org/rfc/rfc4616.txt</haxe_doc>
	</class>
	<class path="jabber.util.Base64" params="" file="../../jabber/util/Base64.hx">
		<CHARS public="1" line="39" static="1"><c path="String"/></CHARS>
		<encode public="1" set="method" line="45" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<decode public="1" set="method" line="74" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</decode>
		<encodeBytes public="1" set="method" line="101" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</encodeBytes>
		<decodeBytes public="1" set="method" line="120" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc></haxe_doc>
		</decodeBytes>
		<random public="1" set="method" line="138" static="1">
			<f a="?len:?chars">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Create a random (base64 compatible) string of given length.</haxe_doc>
		</random>
		<haxe_doc>Base64 encoding/decoding utility.</haxe_doc>
	</class>
	<class path="jabber.util.DateUtil" params="" file="../../jabber/util/DateUtil.hx"><formatTimePartValue public="1" set="method" line="30" static="1"><f a="v">
	<x path="Int"/>
	<c path="String"/>
</f></formatTimePartValue></class>
	<class path="jabber.util.MD5" params="" file="../../jabber/util/MD5.hx">
		<encode public="1" get="inline" set="null" line="36" static="1">
			<f a="s:?raw">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</encode>
		<inst line="74" static="1"><c path="jabber.util.MD5"/></inst>
		<__encode set="method" line="190"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></__encode>
		<doEncode set="method" line="185"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncode>
		<doEncodeRaw set="method" line="177"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></doEncodeRaw>
		<bin2str set="method" line="167"><f a="inp">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></bin2str>
		<str2bin set="method" line="155"><f a="inp">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2bin>
		<ii set="method" line="151"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<hh set="method" line="147"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<gg set="method" line="143"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<ff set="method" line="139"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<cmn set="method" line="135"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<rol set="method" line="131"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<str2blks set="method" line="112"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<addme set="method" line="106"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<bitAND set="method" line="100"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<bitXOR set="method" line="94"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitOR set="method" line="88"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<rhex set="method" line="78"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></rhex>
		<new set="method" line="76"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.
	Modified version from the haxe std lib to provide raw encoding as well as support for non official compiler targets.</haxe_doc>
	</class>
	<class path="jabber.util.SHA1" params="" file="../../jabber/util/SHA1.hx"><encode public="1" get="inline" set="null" line="38" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode></class>
	<class path="jabber.util.SystemUtil" params="" file="../../jabber/util/SystemUtil.hx"><systemName public="1" get="inline" set="null" line="31" static="1">
	<f a=""><c path="String"/></f>
	<haxe_doc>Returns the name of the operating system used (crossplatform).</haxe_doc>
</systemName></class>
	<class path="jabber.util.XMLBeautify" params="" file="../../jabber/util/XMLBeautify.hx">
		<it public="1" set="method" line="35" static="1">
			<f a="t">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format given string to something readable.
		Only for debugging, do NOT use in production.</haxe_doc>
		</it>
		<createNode set="method" line="43" static="1"><f a="x:b:depth">
	<c path="Xml"/>
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createNode>
		<indent get="inline" set="null" line="77" static="1"><f a="b:n">
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></indent>
		<haxe_doc>Utility to 'beautify' XML strings (for debugging).</haxe_doc>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="74" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></file_eof>
		<file_read line="76" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_read>
		<file_read_char line="77" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_read_char>
		<file_close line="79" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="80" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="81" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_tell>
		<eof public="1" set="method" line="70"><f a=""><x path="Bool"/></f></eof>
		<tell public="1" set="method" line="65"><f a=""><x path="Int"/></f></tell>
		<seek public="1" set="method" line="61"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<close public="1" set="method" line="56" override="1"><f a=""><x path="Void"/></f></close>
		<readBytes public="1" set="method" line="45" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="34" override="1"><f a=""><x path="Int"/></f></readByte>
		<__f><d/></__f>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="60" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="61" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_tell>
		<file_flush line="63" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_flush>
		<file_write line="64" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_write>
		<file_write_char line="65" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></file_write_char>
		<tell public="1" set="method" line="55"><f a=""><x path="Int"/></f></tell>
		<seek public="1" set="method" line="51"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<close public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method" line="42" override="1"><f a=""><x path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="38" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="34" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<__f><d/></__f>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/lib/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
	</enum>
	<class path="sys.net.Host" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Host.hx">
		<localhost public="1" set="method" line="41" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the local computer host name</haxe_doc>
		</localhost>
		<host_resolve line="49" static="1"><f a="">
	<c path="String"/>
	<x path="Int"/>
</f></host_resolve>
		<host_reverse line="50" static="1"><f a="">
	<x path="Int"/>
	<c path="String"/>
</f></host_reverse>
		<host_to_string line="51" static="1"><f a="">
	<x path="Int"/>
	<c path="String"/>
</f></host_to_string>
		<host_local line="52" static="1"><f a=""><c path="String"/></f></host_local>
		<reverse public="1" set="method" line="37">
			<f a=""><c path="String"/></f>
			<haxe_doc>Perform a reverse-DNS query to resolve a host name from an IP.</haxe_doc>
		</reverse>
		<toString public="1" set="method" line="33">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<new public="1" set="method" line="29">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.net._Socket.SocketInput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Input"/>
		<socket_recv line="69" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></socket_recv>
		<socket_recv_char line="70" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></socket_recv_char>
		<socket_close line="71" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<close public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></close>
		<readBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="34" override="1"><f a=""><x path="Int"/></f></readByte>
		<__s><d/></__s>
		<new public="1" set="method" line="30"><f a="s">
	<unknown/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.net._Socket.SocketOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Output"/>
		<socket_close line="112" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<socket_send_char line="113" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></socket_send_char>
		<socket_send line="114" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></socket_send>
		<close public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></close>
		<writeBytes public="1" set="method" line="96" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="83" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<__s><d/></__s>
		<new public="1" set="method" line="79"><f a="s">
	<unknown/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx">
		<select public="1" set="method" line="217" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		[read] contains sockets on which we want to wait for available data to be read,
		[write] contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		[others] contains sockets on which we want to wait for exceptional conditions.
		[select] will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a [timeout] (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<socket_new line="228" static="1"><f a="">
	<x path="Bool"/>
	<unknown/>
</f></socket_new>
		<socket_close line="229" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<socket_write line="230" static="1"><f a=":">
	<d/>
	<t path="haxe.io.BytesData"/>
	<unknown/>
</f></socket_write>
		<socket_read line="231" static="1"><f a="">
	<d/>
	<t path="haxe.io.BytesData"/>
</f></socket_read>
		<socket_connect line="232" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></socket_connect>
		<socket_listen line="233" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></socket_listen>
		<socket_select line="234" static="1"><f a=":::">
	<c path="Array"><c path="sys.net.Socket"/></c>
	<c path="Array"><c path="sys.net.Socket"/></c>
	<c path="Array"><c path="sys.net.Socket"/></c>
	<t path="Null"><x path="Float"/></t>
	<c path="Array"><c path="Array"><c path="sys.net.Socket"/></c></c>
</f></socket_select>
		<socket_bind line="235" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></socket_bind>
		<socket_accept line="236" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_accept>
		<socket_peer line="237" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_peer>
		<socket_host line="238" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_host>
		<socket_set_timeout line="239" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></socket_set_timeout>
		<socket_shutdown line="240" static="1"><f a="::">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></socket_shutdown>
		<socket_set_blocking line="241" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></socket_set_blocking>
		<socket_set_fast_send line="242" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></socket_set_fast_send>
		<setFastSend public="1" set="method" line="213">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediatly send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<setBlocking public="1" set="method" line="209">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediatly by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<waitForRead public="1" set="method" line="205">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setTimeout public="1" set="method" line="201">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<host public="1" set="method" line="194">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about our side of a connected socket.</haxe_doc>
		</host>
		<peer public="1" set="method" line="187">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about the other side of a connected socket.</haxe_doc>
		</peer>
		<accept public="1" set="method" line="178">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<bind public="1" set="method" line="174">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<shutdown public="1" set="method" line="170">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<listen public="1" set="method" line="166">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use [accept()] to accept incoming connections.</haxe_doc>
		</listen>
		<connect public="1" set="method" line="155">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't sucessfully connect.</haxe_doc>
		</connect>
		<write public="1" set="method" line="151">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.</haxe_doc>
		</write>
		<read public="1" set="method" line="145">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.</haxe_doc>
		</read>
		<close public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retreive your custom infos after a [select].
	*</haxe_doc>
		</custom>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use [setBlocking(false)] or [setTimeout] to prevent that.</haxe_doc>
		</output>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use [setBlocking(false)] or [setTimeout] to prevent infinite waiting.</haxe_doc>
		</input>
		<__s><d/></__s>
		<new public="1" set="method" line="127">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="xmpp.Attention" params="" file="../../xmpp/Attention.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<createXml public="1" get="inline" set="null" line="28" static="1"><f a=""><c path="Xml"/></f></createXml>
	</class>
	<class path="xmpp.Auth" params="" file="../../xmpp/Auth.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Auth"/>
</f></parse>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<resource public="1"><c path="String"/></resource>
		<digest public="1"><c path="String"/></digest>
		<password public="1"><c path="String"/></password>
		<username public="1"><c path="String"/></username>
		<new public="1" set="method" line="38"><f a="?username:?password:?digest:?resource">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ extension used for inband account authentication.</haxe_doc>
	</class>
	<class path="xmpp.Bind" params="" file="../../xmpp/Bind.hx">
		<XMLNS public="1" set="null" line="32" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Bind"/>
</f></parse>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<jid public="1"><c path="String"/></jid>
		<resource public="1"><c path="String"/></resource>
		<new public="1" set="method" line="37"><f a="?resource:?jid">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[IQ extension used to bind a resource to a stream.
	http://xmpp.org/rfcs/rfc3920.html#bind">RFC3920#bind]]></haxe_doc>
	</class>
	<class path="xmpp.Packet" params="" file="../../xmpp/Packet.hx">
		<PROTOCOL public="1" set="null" line="29" static="1"><c path="String"/></PROTOCOL>
		<parse public="1" set="method" line="82" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses given XML into a XMPP packet object.</haxe_doc>
		</parse>
		<parseAttributes set="method" line="94" static="1">
			<f a="p:x">
				<c path="xmpp.Packet"/>
				<c path="Xml"/>
				<c path="xmpp.Packet"/>
			</f>
			<haxe_doc>Parses/adds basic attributes to the XMPP packet.</haxe_doc>
		</parseAttributes>
		<addAttributes set="method" line="66">
			<f a="x">
				<c path="Xml"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Adds the basic packet attributes to the given XML.</haxe_doc>
		</addAttributes>
		<toString public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Creates/Returns the string representation of this XMPP packet.</haxe_doc>
		</toString>
		<toXml public="1" set="method" line="52">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates/Returns the XML representation of this XMPP packet.</haxe_doc>
		</toXml>
		<errors public="1"><c path="Array"><c path="xmpp.Error"/></c></errors>
		<properties public="1"><c path="Array"><c path="Xml"/></c></properties>
		<lang public="1"><c path="String"/></lang>
		<id public="1"><c path="String"/></id>
		<from public="1"><c path="String"/></from>
		<to public="1"><c path="String"/></to>
		<_type public="1" set="null">
			<e path="xmpp.PacketType"/>
			<haxe_doc>The top level type of the XMPP packet</haxe_doc>
		</_type>
		<new set="method" line="40"><f a="?to:?from:?id:?lang">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.Caps" params="" file="../../xmpp/Caps.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc></haxe_doc>
		</parse>
		<has public="1" set="method" line="83" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given xmpp packet has a caps property</haxe_doc>
		</has>
		<fromPresence public="1" set="method" line="101" static="1">
			<f a="p">
				<c path="xmpp.Packet"/>
				<c path="xmpp.Caps"/>
			</f>
			<haxe_doc>Extracts the caps information from given presence packet</haxe_doc>
		</fromPresence>
		<createVerfificationString public="1" set="method" line="111" static="1">
			<f a="identities:features:?dataform">
				<t path="Iterable"><t path="xmpp.disco.Identity"/></t>
				<t path="Iterable"><c path="String"/></t>
				<c path="xmpp.DataForm"/>
				<c path="String"/>
			</f>
			<haxe_doc>http://xmpp.org/extensions/xep-0115.html#ver</haxe_doc>
		</createVerfificationString>
		<sortIdentities set="method" line="149" static="1"><f a="a:b">
	<t path="xmpp.disco.Identity"/>
	<t path="xmpp.disco.Identity"/>
	<x path="Int"/>
</f></sortIdentities>
		<sortDataFormFields set="method" line="162" static="1"><f a="a:b">
	<c path="xmpp.dataform.Field"/>
	<c path="xmpp.dataform.Field"/>
	<x path="Int"/>
</f></sortDataFormFields>
		<sortString set="method" line="166" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></sortString>
		<toXml public="1" set="method" line="64"><f a=""><c path="Xml"/></f></toXml>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>A set of nametokens specifying additional feature bundles.
		This attribute is deprecated!</haxe_doc>
		</ext>
		<ver public="1">
			<c path="String"/>
			<haxe_doc>A string that is used to verify the identity and supported features of the entity</haxe_doc>
		</ver>
		<node public="1">
			<c path="String"/>
			<haxe_doc>A URI that uniquely identifies a software application, typically a URL at the website
		of the project or company that produces the software</haxe_doc>
		</node>
		<hash public="1">
			<c path="String"/>
			<haxe_doc>The hashing algorithm used to generate the verification string, fe: sha-1.</haxe_doc>
		</hash>
		<new public="1" set="method" line="57"><f a="hash:node:ver:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0085: Entity Capabilities: http://xmpp.org/extensions/xep-0115.html</haxe_doc>
	</class>
	<class path="xmpp.DataForm" params="" file="../../xmpp/DataForm.hx">
		<XMLNS public="1" set="null" line="34" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.DataForm"/>
</f></parse>
		<toXml public="1" set="method" line="49"><f a=""><c path="Xml"/></f></toXml>
		<items public="1"><c path="Array"><c path="xmpp.dataform.Item"/></c></items>
		<reported public="1"><c path="xmpp.dataform.Reported"/></reported>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<instructions public="1"><c path="String"/></instructions>
		<title public="1"><c path="String"/></title>
		<type public="1"><e path="xmpp.dataform.FormType"/></type>
		<new public="1" set="method" line="43"><f a="?type">
	<e path="xmpp.dataform.FormType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>DataForm packet extension (for iq and message packets).

	XEP-0004: Data Forms: http://xmpp.org/extensions/xep-0004.html</haxe_doc>
	</class>
	<class path="xmpp.DateTime" params="" file="../../xmpp/DateTime.hx">
		<EREG_DATE public="1" line="35" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC date expression.
		CCYY-MM-DDThh:mm:ss[.sss]TZD</haxe_doc>
		</EREG_DATE>
		<EREG_TIME public="1" line="41" static="1">
			<c path="EReg"/>
			<haxe_doc>UTC time expression.
		hh:mm:ss[.sss][TZD]</haxe_doc>
		</EREG_TIME>
		<isValidDate public="1" get="inline" set="null" line="43" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidDate>
		<isValidTime public="1" get="inline" set="null" line="47" static="1"><f a="t">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidTime>
		<now public="1" get="inline" set="null" line="54" static="1">
			<f a="?offset">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the current time as UTC formatted string</haxe_doc>
		</now>
		<fromDate public="1" get="inline" set="null" line="61" static="1">
			<f a="d:?offset">
				<c path="Date"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromDate>
		<fromTime public="1" get="inline" set="null" line="68" static="1">
			<f a="t:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a the given date as UTC formatted string</haxe_doc>
		</fromTime>
		<toDate public="1" set="method" line="79" static="1">
			<f a="utc:?tzo">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc><![CDATA[Create a Date object from a UTC time string

		//TODO this offset thing will fail!
		// TODO 24+ -> 0
		//untested!]]></haxe_doc>
		</toDate>
		<utc public="1" set="method" line="105" static="1">
			<f a="t:?offset">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Formats a (regular) date string to a XMPP compatible UTC date string (CCYY-MM-DDThh:mm:ss[.sss]TZD)
		For example: 2008-11-01 18:45:47 gets 2008-11-01T18:45:47Z
		Optionally a timezone offset could be attached.</haxe_doc>
		</utc>
		<getParts public="1" set="method" line="152" static="1">
			<f a="utc">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Return the parts of a UTC time string
		//TODO include tzo</haxe_doc>
		</getParts>
		<getTZOValue public="1" set="method" line="170" static="1">
			<f a="tzo">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the given TZO as integer value</haxe_doc>
		</getTZOValue>
		<getTimeValue public="1" set="method" line="177" static="1"><f a="t">
	<c path="String"/>
	<x path="Int"/>
</f></getTimeValue>
		<haxe_doc>Standardization of ISO 8601 profiles and their lexical representation.

	XMPP Date and Time Profiles: http://xmpp.org/extensions/xep-0082.html</haxe_doc>
	</class>
	<class path="xmpp.EntityTime" params="" file="../../xmpp/EntityTime.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="78" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.EntityTime"/>
</f></parse>
		<toXml public="1" set="method" line="70"><f a=""><c path="Xml"/></f></toXml>
		<tzo public="1">
			<c path="String"/>
			<haxe_doc>The entity's numeric time zone offset from UTC.
		The format conforms to the Time Zone Definition (TZD) specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html).
		Example: +02:00</haxe_doc>
		</tzo>
		<utc public="1">
			<c path="String"/>
			<haxe_doc>The UTC time according to the responding entity.
		 The format conforms to the dateTime profile specified in XEP-0082 (http://www.xmpp.org/extensions/xep-0082.html)
		 and MUST be expressed in UTC.</haxe_doc>
		</utc>
		<new public="1" set="method" line="48"><f a="?utc:?tzo">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 202 - EntityTime: http://www.xmpp.org/extensions/xep-0202.html</haxe_doc>
	</class>
	<typedef path="xmpp.ApplicationErrorCondition" params="" file="../../xmpp/ErrorPacket.hx" module="xmpp.ErrorPacket"><a>
	<xmlns><c path="String"/></xmlns>
	<condition><c path="String"/></condition>
</a></typedef>
	<enum path="xmpp.ErrorType" params="" file="../../xmpp/ErrorType.hx">
		<auth><haxe_doc>Retry after providing credentials</haxe_doc></auth>
		<cancel><haxe_doc>Do not retry (the error is unrecoverable)</haxe_doc></cancel>
		<continue_><haxe_doc>Proceed (the condition was only a warning)</haxe_doc></continue_>
		<modify><haxe_doc>Retry after changing the data sent</haxe_doc></modify>
		<wait><haxe_doc>Retry after waiting (the error is temporary)</haxe_doc></wait>
	</enum>
	<class path="xmpp.HXR" params="" file="../../xmpp/HXR.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<create public="1" set="method" line="33" static="1">
			<f a="?d">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</create>
		<getData public="1" get="inline" set="null" line="42" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
		</getData>
		<haxe_doc>Haxe/XMPP remoting extension</haxe_doc>
	</class>
	<class path="xmpp.IQ" params="" file="../../xmpp/IQ.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="82" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.IQ"/>
</f></parse>
		<createQueryXml public="1" set="method" line="105" static="1">
			<f a="ns:?name">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc><![CDATA[Creates a '<query xmlns="namspace"/>' XML tag]]></haxe_doc>
		</createQueryXml>
		<createResult public="1" get="inline" set="null" line="114" static="1">
			<f a="iq:?from">
				<c path="xmpp.IQ"/>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a result type IQ from the given request</haxe_doc>
		</createResult>
		<createError public="1" set="method" line="121" static="1">
			<f a="iq:?errors:?from">
				<c path="xmpp.IQ"/>
				<c path="Array"><c path="xmpp.Error"/></c>
				<c path="String"/>
				<c path="xmpp.IQ"/>
			</f>
			<haxe_doc>Creates a error type IQ packet from given request</haxe_doc>
		</createError>
		<toXml public="1" set="method" line="74" override="1"><f a=""><c path="Xml"/></f></toXml>
		<x public="1">
			<t path="xmpp.PacketElement"/>
			<haxe_doc>The exclusive child of the IQ packet</haxe_doc>
		</x>
		<type public="1">
			<e path="xmpp.IQType"/>
			<haxe_doc>Either: get/set/result/error</haxe_doc>
		</type>
		<new public="1" set="method" line="66"><f a="?type:?id:?to:?from">
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[InfoQuery XMPP packet

	Info/Query, or IQ, is a "request-response" mechanism, similar in some ways to the Hypertext Transfer Protocol [HTTP].
	The semantics of IQ enable an entity to make a request of, and receive a response from, another entity.
	The data content of the request and response is defined by the schema or other structural definition associated with the XML namespace that qualifies the direct child element of the IQ element,
	and the interaction is tracked by the requesting entity through use of the 'id' attribute. Thus, IQ interactions follow a common pattern of structured data exchange such as get/result or set/result (although an error can be returned in reply to a request if appropriate)

	Requesting                  Responding
	  Entity                      Entity
	----------                  ----------
	    |                            |
	    | <iq id='1' type='get'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='1' type='result'>  |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |
	    | <iq id='2' type='set'>     |
	    |   [ ... payload ... ]      |
	    | </iq>                      |
	    | -------------------------> |
	    |                            |
	    | <iq id='2' type='error'>   |
	    |   [ ... condition ... ]    |
	    | </iq>                      |
	    | <------------------------- |
	    |                            |]]></haxe_doc>
	</class>
	<enum path="xmpp.IQType" params="" file="../../xmpp/IQType.hx">
		<get/>
		<set/>
		<result/>
		<error/>
	</enum>
	<class path="xmpp.LOP" params="" file="../../xmpp/LOP.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.LastActivity" params="" file="../../xmpp/LastActivity.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.LastActivity"/>
</f></parse>
		<parseSeconds public="1" get="inline" set="null" line="50" static="1">
			<f a="x">
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Parses/Returns the time value of the given IQ query xml.</haxe_doc>
		</parseSeconds>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<seconds public="1"><x path="Int"/></seconds>
		<new public="1" set="method" line="33"><f a="?seconds">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0012: Last Activity: http://xmpp.org/extensions/xep-0012.html</haxe_doc>
	</class>
	<class path="xmpp.MUC" params="" file="../../xmpp/MUC.hx"><XMLNS public="1" set="null" line="25" static="1"><c path="String"/></XMLNS></class>
	<class path="xmpp.MUCAdmin" params="" file="../../xmpp/MUCAdmin.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCAdmin"/>
</f></parse>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<items public="1"><c path="Array"><c path="xmpp.muc.Item"/></c></items>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCOwner" params="" file="../../xmpp/MUCOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<items public="1"><c path="List"><c path="xmpp.muc.Item"/></c></items>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.MUCUser" params="" file="../../xmpp/MUCUser.hx">
		<XMLNS public="1" set="null" line="33" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.MUCUser"/>
</f></parse>
		<toXml public="1" set="method" line="44"><f a=""><c path="Xml"/></f></toXml>
		<status public="1"><c path="xmpp.muc.Status"/></status>
		<password public="1"><c path="String"/></password>
		<item public="1"><c path="xmpp.muc.Item"/></item>
		<invite public="1"><c path="xmpp.muc.Invite"/></invite>
		<destroy public="1"><c path="xmpp.muc.Destroy"/></destroy>
		<decline public="1"><c path="xmpp.muc.Decline"/></decline>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Message" params="" file="../../xmpp/Message.hx">
		<extends path="xmpp.Packet"/>
		<parse public="1" set="method" line="60" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Message"/>
</f></parse>
		<toXml public="1" set="method" line="50" override="1"><f a=""><c path="Xml"/></f></toXml>
		<thread public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</thread>
		<subject public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</subject>
		<body public="1">
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</body>
		<type public="1">
			<e path="xmpp.MessageType"/>
			<haxe_doc></haxe_doc>
		</type>
		<new public="1" set="method" line="38"><f a="?to:?body:?subject:?type:?thread:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.MessageType"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XMPP message packet.</haxe_doc>
	</class>
	<enum path="xmpp.MessageType" params="" file="../../xmpp/MessageType.hx">
		<normal/>
		<error/>
		<chat/>
		<groupchat/>
		<headline/>
		<haxe_doc></haxe_doc>
	</enum>
	<typedef path="xmpp.PacketElement" params="" file="../../xmpp/PacketElement.hx"><a><toXml set="method"><f a=""><c path="Xml"/></f></toXml></a></typedef>
	<typedef path="xmpp.PacketFilter" params="" file="../../xmpp/PacketFilter.hx"><a><accept set="method">
	<f a="packet">
		<c path="xmpp.Packet"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Returns true if the given XMPP packet passes through this filter.</haxe_doc>
</accept></a></typedef>
	<enum path="xmpp.PacketType" params="" file="../../xmpp/PacketType.hx">
		<iq><haxe_doc></haxe_doc></iq>
		<message><haxe_doc></haxe_doc></message>
		<presence><haxe_doc></haxe_doc></presence>
		<custom><haxe_doc></haxe_doc></custom>
		<haxe_doc>Core XMPP packet types.</haxe_doc>
	</enum>
	<class path="xmpp.PersonalEvent" params="" file="../../xmpp/PersonalEvent.hx">
		<toXml public="1" set="method" line="52"><f a=""><c path="Xml"/></f></toXml>
		<empty public="1" set="method" line="48">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns a empty XML node for disabling the personal event.</haxe_doc>
		</empty>
		<getNode public="1" set="method" line="41">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the (subclass) namespace.</haxe_doc>
		</getNode>
		<xmlns public="1" set="null"><c path="String"/></xmlns>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<new set="method" line="33"><f a="nodeName:xmlns">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Abstract base for personal event classes.
	The implementing class HAS TO HAVE a static XMLNS field (required by jabber.PersonalEventListener)!</haxe_doc>
	</class>
	<class path="xmpp.Ping" params="" file="../../xmpp/Ping.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<xml public="1" line="29" static="1"><c path="Xml"/></xml>
		<haxe_doc><![CDATA[<a href="http://www.xmpp.org/extensions/xep-0199.html">XEP 199 - XMPP Ping</a>]]></haxe_doc>
	</class>
	<class path="xmpp.PlainPacket" params="" file="../../xmpp/PlainPacket.hx">
		<extends path="xmpp.Packet"/>
		<toXml public="1" get="inline" set="null" line="40" override="1"><f a=""><c path="Xml"/></f></toXml>
		<src public="1">
			<c path="Xml"/>
			<haxe_doc>Plain XML content of the packet.</haxe_doc>
		</src>
		<new public="1" set="method" line="34"><f a="src">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Plain/Custom XMPP packet.</haxe_doc>
	</class>
	<class path="xmpp.Presence" params="" file="../../xmpp/Presence.hx">
		<extends path="xmpp.Packet"/>
		<MAX_STATUS_SIZE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></MAX_STATUS_SIZE>
		<parse public="1" set="method" line="61" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Presence"/>
</f></parse>
		<toXml public="1" set="method" line="52" override="1"><f a=""><c path="Xml"/></f></toXml>
		<set_status set="method" line="46"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_status>
		<priority public="1"><t path="Null"><x path="Int"/></t></priority>
		<status public="1" set="accessor"><c path="String"/></status>
		<show public="1"><e path="xmpp.PresenceShow"/></show>
		<type public="1"><e path="xmpp.PresenceType"/></type>
		<new public="1" set="method" line="37"><f a="?show:?status:?priority:?type">
	<e path="xmpp.PresenceShow"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="xmpp.PresenceType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>RFC-3921 - Instant Messaging and Presence: http://xmpp.org/rfcs/rfc3921.html
	Exchanging Presence Information: http://www.xmpp.org/rfcs/rfc3921.html#presence</haxe_doc>
	</class>
	<enum path="xmpp.PresenceShow" params="" file="../../xmpp/PresenceShow.hx">
		<chat><haxe_doc>Especially socialable</haxe_doc></chat>
		<away><haxe_doc>Away from device</haxe_doc></away>
		<xa><haxe_doc>Extended Away</haxe_doc></xa>
		<dnd><haxe_doc>Busy</haxe_doc></dnd>
		<haxe_doc>Four elements, which provide insights into a human users availbility
	for and interest in communication.</haxe_doc>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="xmpp.PresenceType" params="" file="../../xmpp/PresenceType.hx">
		<error/>
		<probe/>
		<subscribe/>
		<subscribed/>
		<unavailable/>
		<unsubscribe/>
		<unsubscribed/>
	</enum>
	<class path="xmpp.PrivacyList" params="" file="../../xmpp/PrivacyList.hx">
		<parse public="1" set="method" line="42" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyList"/>
</f></parse>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<items public="1"><c path="Array"><c path="xmpp.privacylist.Item"/></c></items>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PrivacyLists" params="" file="../../xmpp/PrivacyLists.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="59" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivacyLists"/>
</f></parse>
		<iterator public="1" get="inline" set="null" line="55"><f a=""><t path="Iterator"><c path="xmpp.PrivacyList"/></t></f></iterator>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<lists public="1"><c path="Array"><c path="xmpp.PrivacyList"/></c></lists>
		<_default public="1"><c path="String"/></_default>
		<active public="1"><c path="String"/></active>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.PrivateStorage" params="" file="../../xmpp/PrivateStorage.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PrivateStorage"/>
</f></parse>
		<toXml public="1" set="method" line="40"><f a=""><c path="Xml"/></f></toXml>
		<data public="1"><c path="Xml"/></data>
		<namespace public="1"><c path="String"/></namespace>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="34"><f a="name:namespace:?data">
	<c path="String"/>
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.PubSub" params="" file="../../xmpp/PubSub.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="90" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSub"/>
</f></parse>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<unsubscribe public="1"><a>
	<subid><c path="String"/></subid>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></unsubscribe>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<retract public="1"><c path="xmpp.pubsub.Retract"/></retract>
		<publish public="1"><c path="xmpp.pubsub.Publish"/></publish>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<configure public="1"><c path="xmpp.DataForm"/></configure>
		<create public="1"><c path="String"/></create>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<options public="1"><c path="xmpp.pubsub.Options"/></options>
		<subscribe public="1"><a>
	<node><c path="String"/></node>
	<jid><c path="String"/></jid>
</a></subscribe>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubEvent" params="" file="../../xmpp/PubSubEvent.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubEvent"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<subscription public="1"><c path="xmpp.pubsub.Subscription"/></subscription>
		<purge public="1"><c path="String"/></purge>
		<delete public="1"><c path="String"/></delete>
		<configuration public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configuration>
		<items public="1"><c path="xmpp.pubsub.Items"/></items>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.PubSubOwner" params="" file="../../xmpp/PubSubOwner.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="76" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.PubSubOwner"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<_default public="1"><a>
	<form><c path="xmpp.DataForm"/></form>
	<empty><x path="Bool"/></empty>
</a></_default>
		<affiliations public="1"><c path="xmpp.pubsub.Affiliations"/></affiliations>
		<subscriptions public="1"><c path="xmpp.pubsub.Subscriptions"/></subscriptions>
		<configure public="1"><a>
	<node><c path="String"/></node>
	<form><c path="xmpp.DataForm"/></form>
</a></configure>
		<purge public="1"><c path="String"/></purge>
		<delete public="1">
			<c path="String"/>
			<haxe_doc>Set to "" (empty string) to add a empty delete element</haxe_doc>
		</delete>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.Register" params="" file="../../xmpp/Register.hx">
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="96" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Register"/>
</f></parse>
		<createElement set="method" line="88"><f a="x:id">
	<c path="Xml"/>
	<c path="String"/>
	<c path="Xml"/>
</f></createElement>
		<toXml public="1" set="method" line="61"><f a=""><c path="Xml"/></f></toXml>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<remove public="1"><x path="Bool"/></remove>
		<registered public="1"><x path="Bool"/></registered>
		<key public="1"><c path="String"/></key>
		<text public="1"><c path="String"/></text>
		<misc public="1"><c path="String"/></misc>
		<date public="1"><c path="String"/></date>
		<url public="1"><c path="String"/></url>
		<phone public="1"><c path="String"/></phone>
		<zip public="1"><c path="String"/></zip>
		<state public="1"><c path="String"/></state>
		<city public="1"><c path="String"/></city>
		<address public="1"><c path="String"/></address>
		<last public="1"><c path="String"/></last>
		<first public="1"><c path="String"/></first>
		<nick public="1"><c path="String"/></nick>
		<name public="1"><c path="String"/></name>
		<email public="1"><c path="String"/></email>
		<password public="1"><c path="String"/></password>
		<username public="1"><c path="String"/></username>
		<new public="1" set="method" line="53"><f a="?username:?password:?email:?name">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP-0077: In-Band Registration</haxe_doc>
	</class>
	<class path="xmpp.Roster" params="" file="../../xmpp/Roster.hx">
		<extends path="List"><c path="xmpp.roster.Item"/></extends>
		<XMLNS public="1" set="null" line="29" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.Roster"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="31"><f a="?items">
	<t path="Iterable"><c path="xmpp.roster.Item"/></t>
	<x path="Void"/>
</f></new>
		<haxe_doc>IQ roster extension.</haxe_doc>
	</class>
	<class path="xmpp.SASL" params="" file="../../xmpp/SASL.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<EREG_FAILURE public="1" line="32" static="1"><c path="EReg"/></EREG_FAILURE>
		<createAuth public="1" set="method" line="36" static="1">
			<f a="mech:?text">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createAuth>
		<createResponse public="1" set="method" line="47" static="1">
			<f a="t">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc></haxe_doc>
		</createResponse>
		<parseMechanisms public="1" set="method" line="58" static="1">
			<f a="x">
				<c path="Xml"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Parses list of SASL mechanisms.</haxe_doc>
		</parseMechanisms>
		<haxe_doc>Static methods for creation/manipulation of SASL XMPP packets.</haxe_doc>
	</class>
	<class path="xmpp.SoftwareVersion" params="" file="../../xmpp/SoftwareVersion.hx">
		<XMLNS public="1" set="null" line="31" static="1"><c path="String"/></XMLNS>
		<parse public="1" get="inline" set="null" line="56" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.SoftwareVersion"/>
</f></parse>
		<toXml public="1" set="method" line="48"><f a=""><c path="Xml"/></f></toXml>
		<os public="1">
			<c path="String"/>
			<haxe_doc>The operating system of the queried entity</haxe_doc>
		</os>
		<version public="1">
			<c path="String"/>
			<haxe_doc>The specific version of the software</haxe_doc>
		</version>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The natural-language name of the software</haxe_doc>
		</name>
		<new public="1" set="method" line="42"><f a="?name:?version:?os">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>XEP 0092 - Software Version: http://www.xmpp.org/extensions/xep-0092.html</haxe_doc>
	</class>
	<class path="xmpp.Stream" params="" file="../../xmpp/Stream.hx">
		<STREAM public="1" set="null" line="29" static="1"><c path="String"/></STREAM>
		<CLIENT public="1" set="null" line="30" static="1"><c path="String"/></CLIENT>
		<SERVER public="1" set="null" line="31" static="1"><c path="String"/></SERVER>
		<createOpenXml public="1" set="method" line="39" static="1">
			<f a="ns:to:?version:?lang:?header">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Creates the opening XML tag of a XMPP stream.</haxe_doc>
		</createOpenXml>
		<haxe_doc>Static stuff for creation/manipulation of XMPP stream opening/closing tags.</haxe_doc>
	</class>
	<class path="xmpp.UserSearch" params="" file="../../xmpp/UserSearch.hx">
		<XMLNS public="1" set="null" line="28" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="62" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.UserSearch"/>
</f></parse>
		<getFieldValue set="method" line="88" static="1"><f a="x">
	<c path="Xml"/>
	<c path="String"/>
</f></getFieldValue>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<items public="1"><c path="Array"><t path="xmpp.UserSearchItem"/></c></items>
		<email public="1"><c path="String"/></email>
		<nick public="1"><c path="String"/></nick>
		<last public="1"><c path="String"/></last>
		<first public="1"><c path="String"/></first>
		<instructions public="1"><c path="String"/></instructions>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="xmpp.UserSearchItem" params="" file="../../xmpp/UserSearchItem.hx"><a>
	<nick><c path="String"/></nick>
	<last><c path="String"/></last>
	<jid><c path="String"/></jid>
	<first><c path="String"/></first>
	<email><c path="String"/></email>
</a></typedef>
	<class path="xmpp.VCardTemp" params="" file="../../xmpp/VCardTemp.hx">
		<XMLNS public="1" set="null" line="42" static="1"><c path="String"/></XMLNS>
		<PROD_ID public="1" set="null" line="43" static="1"><c path="String"/></PROD_ID>
		<VERSION public="1" set="null" line="44" static="1"><c path="String"/></VERSION>
		<hasPhoto public="1" set="method" line="153" static="1">
			<f a="vc">
				<c path="xmpp.VCardTemp"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the given vcard has a photo attached (all xmpp.vcard.Photo).</haxe_doc>
		</hasPhoto>
		<emptyXml public="1" set="method" line="158" static="1"><f a=""><c path="Xml"/></f></emptyXml>
		<parse public="1" set="method" line="167" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.VCardTemp"/>
</f></parse>
		<parsePhoto set="method" line="306" static="1"><f a="x">
	<c path="Xml"/>
	<t path="xmpp.vcard.Photo"/>
</f></parsePhoto>
		<addXmlField set="method" line="144"><f a="n:x:?name">
	<c path="String"/>
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></addXmlField>
		<toXml public="1" set="method" line="68"><f a=""><c path="Xml"/></f></toXml>
		<desc public="1"><c path="String"/></desc>
		<url public="1"><c path="String"/></url>
		<org public="1"><t path="xmpp.vcard.Org"/></org>
		<role public="1"><c path="String"/></role>
		<title public="1"><c path="String"/></title>
		<geo public="1"><t path="xmpp.vcard.Geo"><x path="Float"/></t></geo>
		<tz public="1"><c path="String"/></tz>
		<jid public="1"><c path="String"/></jid>
		<email public="1"><t path="xmpp.vcard.EMail"/></email>
		<tels public="1"><c path="Array"><t path="xmpp.vcard.Tel"/></c></tels>
		<addresses public="1"><c path="Array"><t path="xmpp.vcard.Address"/></c></addresses>
		<birthday public="1"><c path="String"/></birthday>
		<photo public="1"><t path="xmpp.vcard.Photo"/></photo>
		<nickname public="1"><c path="String"/></nickname>
		<n public="1"><t path="xmpp.vcard.Name"/></n>
		<fn public="1"><c path="String"/></fn>
		<new public="1" set="method" line="63"><f a=""><x path="Void"/></f></new>
		<haxe_doc>XEP-0054: vcard-temp: http://www.xmpp.org/extensions/xep-0054.html
	RFC2426: http://tools.ietf.org/html/rfc2426

	Depricated! Replaced by XEP0292 (see xmpp.VCard).
	This is just a subset of RFC2426!</haxe_doc>
	</class>
	<class path="xmpp.X" params="" file="../../xmpp/X.hx"><create public="1" set="method" line="28" static="1"><f a="ns:?childs">
	<c path="String"/>
	<t path="Iterable"><c path="Xml"/></t>
	<c path="Xml"/>
</f></create></class>
	<class path="xmpp.XMLUtil" params="" file="../../xmpp/XMLUtil.hx">
		<createElement public="1" set="method" line="33" static="1">
			<f a="n:t">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param n Name of xml element to create
		@param t Node content</haxe_doc>
		</createElement>
		<addElement public="1" get="inline" set="null" line="44" static="1">
			<f a="x:name:content">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param n Name of xml node
		@param t Node content</haxe_doc>
		</addElement>
		<addField public="1" set="method" line="56" static="1">
			<f a="x:o:n:?required">
				<c path="Xml"/>
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the element to
		@param o The target object, provider of value
		@param n Name of XML node
		@param t Node content</haxe_doc>
		</addField>
		<addFields public="1" set="method" line="69" static="1">
			<f a="x:o:?fields">
				<c path="Xml"/>
				<d/>
				<t path="Iterable"><c path="String"/></t>
				<c path="Xml"/>
			</f>
			<haxe_doc>@param x XML element to attach the created element to
		@param o The target object to retrieve the field values from
		@param fields Optional names of fields, gets reflected if null</haxe_doc>
		</addFields>
		<reflectElements public="1" params="T" set="method" line="78" static="1">
			<f a="target:x">
				<c path="reflectElements.T"/>
				<c path="Xml"/>
				<c path="reflectElements.T"/>
			</f>
			<haxe_doc>TODO use?</haxe_doc>
		</reflectElements>
		<ns public="1" set="method" line="90" static="1">
			<f a="x:?ns">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get (if no ns specified) or set the namespace of the given xml element.

		@param x XML element to attach the create element to
		@param ns Optional namespace to set</haxe_doc>
		</ns>
		<setNamespace public="1" get="inline" set="null" line="100" static="1">
			<f a="x:s">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Hack because flash is unable to set xml namespace (since haxe 2.06) //TODO</haxe_doc>
		</setNamespace>
		<haxe_doc>XML utilities.</haxe_doc>
	</class>
	<class path="xmpp.dataform.Field" params="" file="../../xmpp/dataform/Field.hx">
		<parse public="1" set="method" line="55" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Field"/>
</f></parse>
		<parseFields public="1" set="method" line="74" static="1">
			<f a="t:x">
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
				<c path="Xml"/>
				<a><fields><c path="Array"><c path="xmpp.dataform.Field"/></c></fields></a>
			</f>
			<haxe_doc>Parses all dataform fields into the given dataform field container.</haxe_doc>
		</parseFields>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<options public="1"><c path="Array"><c path="xmpp.dataform.FieldOption"/></c></options>
		<values public="1"><c path="Array"><c path="String"/></c></values>
		<required public="1"><x path="Bool"/></required>
		<desc public="1"><c path="String"/></desc>
		<variable public="1"><c path="String"/></variable>
		<type public="1"><e path="xmpp.dataform.FieldType"/></type>
		<label public="1"><c path="String"/></label>
		<new public="1" set="method" line="36"><f a="?type">
	<e path="xmpp.dataform.FieldType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.FieldOption" params="" file="../../xmpp/dataform/FieldOption.hx">
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.FieldOption"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<value public="1"><c path="String"/></value>
		<label public="1"><c path="String"/></label>
		<new public="1" set="method" line="31"><f a="?label:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.dataform.FieldType" params="" file="../../xmpp/dataform/FieldType.hx">
		<boolean><haxe_doc>The field enables an entity to gather or provide an either-or choice between two options.
		The default value is "false".</haxe_doc></boolean>
		<fixed><haxe_doc><![CDATA[The field is intended for data description (e.g., human-readable text such as "section" headers) rather than data gathering or provision.
		The <value/> child SHOULD NOT contain newlines (the \n and \r characters);
		instead an application SHOULD generate multiple fixed fields, each with one <value/> child.]]></haxe_doc></fixed>
		<hidden><haxe_doc>The field is not shown to the form-submitting entity, but instead is returned with the form.
		The form-submitting entity SHOULD NOT modify the value of a hidden field, 
		but MAY do so if such behavior is defined for the "using protocol".</haxe_doc></hidden>
		<jid_multi><haxe_doc>The field enables an entity to gather or provide multiple Jabber IDs.
		Each provided JID SHOULD be unique (as determined by comparison that includes application of the Nodeprep, Nameprep, and Resourceprep profiles of Stringprep as specified in XMPP Core),
		and duplicate JIDs MUST be ignored.</haxe_doc></jid_multi>
		<jid_single><haxe_doc>The field enables an entity to gather or provide a single Jabber ID.</haxe_doc></jid_single>
		<list_multi><haxe_doc>The field enables an entity to gather or provide one or more options from among many.
		A form-submitting entity chooses one or more items from among the options presented by the form-processing entity and MUST NOT insert new options.
		The form-submitting entity MUST NOT modify the order of items as received from the form-processing entity,
		since the order of items MAY be significant.</haxe_doc></list_multi>
		<list_single><haxe_doc>The field enables an entity to gather or provide one option from among many.
		A form-submitting entity chooses one item from among the options presented by the form-processing entity and MUST NOT insert new options.</haxe_doc></list_single>
		<text_multi><haxe_doc>The field enables an entity to gather or provide multiple lines of text.</haxe_doc></text_multi>
		<text_private><haxe_doc>The field enables an entity to gather or provide a single line or word of text,
		which shall be obscured in an interface (e.g., with multiple instances of the asterisk character).</haxe_doc></text_private>
		<text_single><haxe_doc>The field enables an entity to gather or provide a single line or word of text, which may be shown in an interface.
		This field type is the default and MUST be assumed if a form-submitting entity receives a field type it does not understand.</haxe_doc></text_single>
	</enum>
	<enum path="xmpp.dataform.FormType" params="" file="../../xmpp/dataform/FormType.hx">
		<cancel><haxe_doc>The form-submitting entity has cancelled submission of data to the form-processing entity.</haxe_doc></cancel>
		<form><haxe_doc>The form-processing entity is asking the form-submitting entity to complete a form.</haxe_doc></form>
		<result><haxe_doc>The form-processing entity is returning data (e.g., search results) to the form-submitting entity,
		or the data is a generic data set.</haxe_doc></result>
		<submit><haxe_doc>The form-submitting entity is submitting data to the form-processing entity.
		The submission MAY include fields that were not provided in the empty form,
		but the form-processing entity MUST ignore any fields that it does not understand.</haxe_doc></submit>
	</enum>
	<class path="xmpp.dataform.Item" params="" file="../../xmpp/dataform/Item.hx">
		<parse public="1" get="inline" set="null" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Item"/>
</f></parse>
		<createXml set="method" line="36"><f a="n">
	<c path="String"/>
	<c path="Xml"/>
</f></createXml>
		<toXml public="1" set="method" line="32"><f a=""><c path="Xml"/></f></toXml>
		<fields public="1"><c path="Array"><c path="xmpp.dataform.Field"/></c></fields>
		<new public="1" set="method" line="28"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.dataform.Reported" params="" file="../../xmpp/dataform/Reported.hx">
		<extends path="xmpp.dataform.Item"/>
		<parse public="1" get="inline" set="null" line="34" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.dataform.Reported"/>
</f></parse>
		<toXml public="1" set="method" line="30" override="1"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="26"><f a="?fields">
	<c path="Array"><c path="xmpp.dataform.Field"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="xmpp.disco.Identity" params="" file="../../xmpp/disco/Identity.hx"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<category><c path="String"/></category>
</a></typedef>
	<class path="xmpp.disco.Info" params="" file="../../xmpp/disco/Info.hx">
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="68" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Info"/>
</f></parse>
		<toXml public="1" set="method" line="46"><f a=""><c path="Xml"/></f></toXml>
		<x public="1">
			<c path="Xml"/>
			<haxe_doc>Dataform</haxe_doc>
		</x>
		<node public="1">
			<c path="String"/>
			<haxe_doc>Specific node</haxe_doc>
		</node>
		<features public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>List of features/namespaces</haxe_doc>
		</features>
		<identities public="1">
			<c path="Array"><t path="xmpp.disco.Identity"/></c>
			<haxe_doc></haxe_doc>
		</identities>
		<new public="1" set="method" line="40"><f a="?identities:?features:?node">
	<c path="Array"><t path="xmpp.disco.Identity"/></c>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Item" params="" file="../../xmpp/disco/Item.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Item"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<node public="1"><c path="String"/></node>
		<name public="1"><c path="String"/></name>
		<jid public="1"><c path="String"/></jid>
		<new public="1" set="method" line="30"><f a="jid:?name:?node">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.disco.Items" params="" file="../../xmpp/disco/Items.hx">
		<extends path="List"><c path="xmpp.disco.Item"/></extends>
		<XMLNS public="1" set="null" line="26" static="1"><c path="String"/></XMLNS>
		<parse public="1" set="method" line="43" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.disco.Items"/>
</f></parse>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="30"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.filter.IQFilter" params="" file="../../xmpp/filter/IQFilter.hx">
		<accept public="1" set="method" line="39">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<type public="1"><e path="xmpp.IQType"/></type>
		<node public="1"><c path="String"/></node>
		<xmlns public="1"><c path="String"/></xmlns>
		<new public="1" set="method" line="33"><f a="?xmlns:?type:?node">
	<c path="String"/>
	<e path="xmpp.IQType"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters IQ packets: namespace/nodename/iqtype</haxe_doc>
	</class>
	<class path="xmpp.filter.MessageFilter" params="" file="../../xmpp/filter/MessageFilter.hx">
		<accept public="1" set="method" line="38">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<type public="1"><e path="xmpp.MessageType"/></type>
		<new public="1" set="method" line="33"><f a="?type">
	<e path="xmpp.MessageType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters message packets, optional including xmpp.MessageType.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromContainsFilter" params="" file="../../xmpp/filter/PacketFromContainsFilter.hx">
		<accept public="1" set="method" line="42">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<set_contains set="method" line="37"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_contains>
		<ereg><c path="EReg"/></ereg>
		<contains public="1" set="accessor"><c path="String"/></contains>
		<new public="1" set="method" line="33"><f a="contains">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets where the from attribute contains the given string.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketFromFilter" params="" file="../../xmpp/filter/PacketFromFilter.hx">
		<accept public="1" get="inline" set="null" line="35"><f a="p">
	<c path="xmpp.Packet"/>
	<x path="Bool"/>
</f></accept>
		<jid public="1"><c path="String"/></jid>
		<new public="1" set="method" line="31"><f a="jid">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching 'from' attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketIDFilter" params="" file="../../xmpp/filter/PacketIDFilter.hx">
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="31"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters XMPP packets with matching id attribute.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketNameFilter" params="" file="../../xmpp/filter/PacketNameFilter.hx">
		<accept public="1" set="method" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<expr public="1"><c path="EReg"/></expr>
		<new public="1" set="method" line="31"><f a="expr">
	<c path="EReg"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters (just) custom XMPP packets with given nodename expression.</haxe_doc>
	</class>
	<class path="xmpp.filter.PacketPropertyFilter" params="" file="../../xmpp/filter/PacketPropertyFilter.hx">
		<accept public="1" set="method" line="36">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<name public="1"><c path="String"/></name>
		<ns public="1"><c path="String"/></ns>
		<new public="1" set="method" line="31"><f a="ns:?name">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<class path="xmpp.filter.PacketTypeFilter" params="" file="../../xmpp/filter/PacketTypeFilter.hx">
		<accept public="1" get="inline" set="null" line="35">
			<f a="p">
				<c path="xmpp.Packet"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</accept>
		<type public="1"><e path="xmpp.PacketType"/></type>
		<new public="1" set="method" line="31"><f a="type">
	<e path="xmpp.PacketType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Filters packets with matching xmpp.PacketType.</haxe_doc>
	</class>
	<typedef path="xmpp.lop.Binding" params="" file="../../xmpp/lop/Binding.hx"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
	<datatype><c path="String"/></datatype>
</a></typedef>
	<class path="xmpp.lop.Bindings" params="" file="../../xmpp/lop/Bindings.hx">
		<extends path="List"><t path="xmpp.lop.Binding"/></extends>
		<parse public="1" set="method" line="49" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Bindings"/>
</f></parse>
		<toXml public="1" set="method" line="35"><f a=""><c path="Xml"/></f></toXml>
		<vm_id public="1"><c path="String"/></vm_id>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Ping" params="" file="../../xmpp/lop/Ping.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Ping"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<status public="1"><c path="String"/></status>
		<job_id public="1"><c path="String"/></job_id>
		<vm_id public="1"><c path="String"/></vm_id>
		<new public="1" set="method" line="32"><f a="vm_id:?job_id:?status">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.SpawnVM" params="" file="../../xmpp/lop/SpawnVM.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.SpawnVM"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<password public="1"><c path="String"/></password>
		<id public="1"><c path="String"/></id>
		<species public="1"><c path="String"/></species>
		<new public="1" set="method" line="32"><f a="species:?id:?password">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Submit" params="" file="../../xmpp/lop/Submit.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Submit"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<code public="1"><c path="String"/></code>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="31"><f a="id:?code">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.lop.Terminate" params="" file="../../xmpp/lop/Terminate.hx">
		<parse public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.lop.Terminate"/>
</f></parse>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<vm_id public="1"><c path="String"/></vm_id>
		<new public="1" set="method" line="30"><f a="vm_id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.muc.Affiliation" params="" file="../../xmpp/muc/Affiliation.hx">
		<none/>
		<owner/>
		<admin/>
		<member/>
		<outcast/>
		<haxe_doc>Long-lived association or connection with a room.
	Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Decline" params="" file="../../xmpp/muc/Decline.hx">
		<parse public="1" set="method" line="50" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Decline"/>
</f></parse>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<nodeName><c path="String"/></nodeName>
		<reason public="1"><c path="String"/></reason>
		<from public="1"><c path="String"/></from>
		<to public="1"><c path="String"/></to>
		<new public="1" set="method" line="35"><f a="?reason:?to:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Destroy" params="" file="../../xmpp/muc/Destroy.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Destroy"/>
</f></parse>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<reason public="1"><c path="String"/></reason>
		<jid public="1"><c path="String"/></jid>
		<new public="1" set="method" line="32"><f a="?jid:?reason">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Invite" params="" file="../../xmpp/muc/Invite.hx">
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Invite"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<reason public="1"><c path="String"/></reason>
		<from public="1"><c path="String"/></from>
		<to public="1"><c path="String"/></to>
		<new public="1" set="method" line="30"><f a="to:?reason:?from">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.muc.Item" params="" file="../../xmpp/muc/Item.hx">
		<parse public="1" set="method" line="67" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.muc.Item"/>
</f></parse>
		<toXml public="1" set="method" line="45"><f a=""><c path="Xml"/></f></toXml>
		<continue_ public="1"><c path="String"/></continue_>
		<reason public="1"><c path="String"/></reason>
		<actor public="1"><c path="String"/></actor>
		<jid public="1"><c path="String"/></jid>
		<nick public="1"><c path="String"/></nick>
		<role public="1"><e path="xmpp.muc.Role"/></role>
		<affiliation public="1"><e path="xmpp.muc.Affiliation"/></affiliation>
		<new public="1" set="method" line="38"><f a="?affiliation:?role:?nick:?jid">
	<e path="xmpp.muc.Affiliation"/>
	<e path="xmpp.muc.Role"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc></haxe_doc>
	</class>
	<enum path="xmpp.muc.Role" params="" file="../../xmpp/muc/Role.hx">
		<none/>
		<visitor/>
		<participant/>
		<moderator/>
		<haxe_doc>Roles and Affiliations: http://xmpp.org/extensions/xep-0045.html#connections</haxe_doc>
	</enum>
	<class path="xmpp.muc.Status" params="" file="../../xmpp/muc/Status.hx">
		<MYSELF public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></MYSELF>
		<ROOMNICK_CHANGED public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></ROOMNICK_CHANGED>
		<WAITS_FOR_UNLOCK public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></WAITS_FOR_UNLOCK>
		<parse public="1" get="inline" set="null" line="42" static="1"><f a="x">
	<a><get set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get></a>
	<c path="xmpp.muc.Status"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<code public="1"><x path="Int"/></code>
		<new public="1" set="method" line="32"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.Action" params="" file="../../xmpp/privacylist/Action.hx">
		<allow/>
		<deny/>
	</enum>
	<class path="xmpp.privacylist.Item" params="" file="../../xmpp/privacylist/Item.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.privacylist.Item"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<order public="1"><x path="Int"/></order>
		<value public="1"><c path="String"/></value>
		<action public="1"><e path="xmpp.privacylist.Action"/></action>
		<type public="1"><e path="xmpp.privacylist.ItemType"/></type>
		<new public="1" set="method" line="31"><f a="action:?type:?value:?order">
	<e path="xmpp.privacylist.Action"/>
	<e path="xmpp.privacylist.ItemType"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.privacylist.ItemType" params="" file="../../xmpp/privacylist/ItemType.hx">
		<group/>
		<jid/>
		<subscription/>
	</enum>
	<class path="xmpp.pubsub.Affiliation" params="" file="../../xmpp/pubsub/Affiliation.hx">
		<parse public="1" set="method" line="41" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliation"/>
</f></parse>
		<toXml public="1" set="method" line="34"><f a=""><c path="Xml"/></f></toXml>
		<affiliation public="1"><e path="xmpp.pubsub.AffiliationState"/></affiliation>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="29"><f a="node:affiliation">
	<c path="String"/>
	<e path="xmpp.pubsub.AffiliationState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.AffiliationState" params="" file="../../xmpp/pubsub/AffiliationState.hx">
		<none/>
		<owner/>
		<publisher/>
		<member/>
		<outcast/>
		<haxe_doc><![CDATA[<a href="http://xmpp.org/extensions/xep-0060.html#affiliations">Affiliations</a>]]></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Affiliations" params="" file="../../xmpp/pubsub/Affiliations.hx">
		<extends path="List"><c path="xmpp.pubsub.Affiliation"/></extends>
		<parse public="1" set="method" line="33" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Affiliations"/>
</f></parse>
		<toXml public="1" set="method" line="26"><f a=""><c path="Xml"/></f></toXml>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="xmpp.pubsub.Item" params="" file="../../xmpp/pubsub/Item.hx">
		<parse public="1" set="method" line="45" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Item"/>
</f></parse>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<payload public="1"><c path="Xml"/></payload>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="31"><f a="?id:?payload">
	<c path="String"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Items" params="" file="../../xmpp/pubsub/Items.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Items"/>
</f></parse>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<maxItems public="1"><t path="Null"><x path="Int"/></t></maxItems>
		<subid public="1"><c path="String"/></subid>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="30"><f a="?node:?subid:?maxItems">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Options" params="" file="../../xmpp/pubsub/Options.hx">
		<parse public="1" set="method" line="47" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Options"/>
</f></parse>
		<toXml public="1" set="method" line="38"><f a=""><c path="Xml"/></f></toXml>
		<form public="1"><c path="xmpp.DataForm"/></form>
		<subid public="1"><c path="String"/></subid>
		<node public="1"><c path="String"/></node>
		<jid public="1"><c path="String"/></jid>
		<new public="1" set="method" line="31"><f a="?jid:?node:?subid:?form">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="xmpp.DataForm"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Publish" params="" file="../../xmpp/pubsub/Publish.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="44" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Publish"/>
</f></parse>
		<toXml public="1" set="method" line="36"><f a=""><c path="Xml"/></f></toXml>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="28"><f a="node:?items">
	<c path="String"/>
	<t path="Iterable"><c path="xmpp.pubsub.Item"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Retract" params="" file="../../xmpp/pubsub/Retract.hx">
		<extends path="List"><c path="xmpp.pubsub.Item"/></extends>
		<parse public="1" set="method" line="46" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Retract"/>
</f></parse>
		<toXml public="1" set="method" line="37"><f a=""><c path="Xml"/></f></toXml>
		<notify public="1"><x path="Bool"/></notify>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="29"><f a="node:?itemIDs:?notify">
	<c path="String"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="xmpp.pubsub.Subscription" params="" file="../../xmpp/pubsub/Subscription.hx">
		<parse public="1" set="method" line="52" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscription"/>
</f></parse>
		<toXml public="1" set="method" line="42"><f a=""><c path="Xml"/></f></toXml>
		<subscription public="1"><e path="xmpp.pubsub.SubscriptionState"/></subscription>
		<subid public="1"><c path="String"/></subid>
		<node public="1"><c path="String"/></node>
		<jid public="1"><c path="String"/></jid>
		<new public="1" set="method" line="32"><f a="jid:?node:?subid:?subscription">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="xmpp.pubsub.SubscriptionState"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.pubsub.SubscriptionState" params="" file="../../xmpp/pubsub/SubscriptionState.hx">
		<none><haxe_doc>The node MUST NOT send event notifications or payloads to the Entity.</haxe_doc></none>
		<pending><haxe_doc>An entity has requested to subscribe to a node and the request has not yet been approved by a node owner.
		The node MUST NOT send event notifications or payloads to the entity while it is in this state.</haxe_doc></pending>
		<unconfigured><haxe_doc>An entity has subscribed but its subscription options have not yet been configured.
		The node MAY send event notifications or payloads to the entity while it is in this state.
		The service MAY timeout unconfigured subscriptions.</haxe_doc></unconfigured>
		<subscribed><haxe_doc>An entity is subscribed to a node.
		The node MUST send all event notifications (and, if configured, payloads) to the entity while it is in this state
		(subject to subscriber configuration and content filtering).</haxe_doc></subscribed>
		<haxe_doc></haxe_doc>
	</enum>
	<class path="xmpp.pubsub.Subscriptions" params="" file="../../xmpp/pubsub/Subscriptions.hx">
		<extends path="List"><c path="xmpp.pubsub.Subscription"/></extends>
		<parse public="1" set="method" line="40" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.pubsub.Subscriptions"/>
</f></parse>
		<toXml public="1" set="method" line="33"><f a=""><c path="Xml"/></f></toXml>
		<node public="1"><c path="String"/></node>
		<new public="1" set="method" line="28"><f a="?node">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.AskType" params="" file="../../xmpp/roster/AskType.hx">
		<subscribe><haxe_doc>Denotes that  a request to subscribe to a entities presence has been made.</haxe_doc></subscribe>
		<unsubscribe><haxe_doc>Denotes that a request to unscubscribe from a users presence has been made.</haxe_doc></unsubscribe>
		<haxe_doc>Roster ask types.</haxe_doc>
	</enum>
	<class path="xmpp.roster.Item" params="" file="../../xmpp/roster/Item.hx">
		<parse public="1" set="method" line="54" static="1"><f a="x">
	<c path="Xml"/>
	<c path="xmpp.roster.Item"/>
</f></parse>
		<toXml public="1" set="method" line="43"><f a=""><c path="Xml"/></f></toXml>
		<groups public="1"><c path="List"><c path="String"/></c></groups>
		<askType public="1"><e path="xmpp.roster.AskType"/></askType>
		<name public="1"><c path="String"/></name>
		<subscription public="1"><e path="xmpp.roster.Subscription"/></subscription>
		<jid public="1" set="null"><c path="String"/></jid>
		<new public="1" set="method" line="34"><f a="jid:?subscription:?name:?askType:?groups">
	<c path="String"/>
	<e path="xmpp.roster.Subscription"/>
	<c path="String"/>
	<e path="xmpp.roster.AskType"/>
	<t path="Iterable"><c path="String"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="xmpp.roster.Subscription" params="" file="../../xmpp/roster/Subscription.hx">
		<none><haxe_doc>The user and subscriber have no interest in each other's presence.</haxe_doc></none>
		<to><haxe_doc>The user is interested in receiving presence updates from the subscriber.</haxe_doc></to>
		<from><haxe_doc>The subscriber is interested in receiving presence updates from the user.</haxe_doc></from>
		<both><haxe_doc>The user and subscriber have a mutual interest in each other's presence.</haxe_doc></both>
		<remove><haxe_doc>The user wishes to stop receiving presence updates from the subscriber.</haxe_doc></remove>
		<haxe_doc>Roster subscription states.</haxe_doc>
	</enum>
	<typedef path="xmpp.vcard.Address" params="" file="../../xmpp/vcard/Address.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<street>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</street>
	<region>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</region>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<postal>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</postal>
	<pobox>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pobox>
	<pcode>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcode>
	<parcel>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parcel>
	<locality>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</locality>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<extadd>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</extadd>
	<ctry>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</ctry>
</a></typedef>
	<typedef path="xmpp.vcard.EMail" params="" file="../../xmpp/vcard/EMail.hx"><a>
	<x400>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</x400>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<userid><c path="String"/></userid>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<internet>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</internet>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
</a></typedef>
	<typedef path="xmpp.vcard.Geo" params="T" file="../../xmpp/vcard/Geo.hx"><a>
	<lon><c path="xmpp.vcard.Geo.T"/></lon>
	<lat><c path="xmpp.vcard.Geo.T"/></lat>
</a></typedef>
	<typedef path="xmpp.vcard.Name" params="" file="../../xmpp/vcard/Name.hx"><a>
	<suffix><c path="String"/></suffix>
	<prefix><c path="String"/></prefix>
	<middle><c path="String"/></middle>
	<given><c path="String"/></given>
	<family><c path="String"/></family>
</a></typedef>
	<typedef path="xmpp.vcard.Org" params="" file="../../xmpp/vcard/Org.hx"><a>
	<orgunit><c path="String"/></orgunit>
	<orgname><c path="String"/></orgname>
</a></typedef>
	<typedef path="xmpp.vcard.Photo" params="" file="../../xmpp/vcard/Photo.hx"><a>
	<type><c path="String"/></type>
	<binval><c path="String"/></binval>
</a></typedef>
	<typedef path="xmpp.vcard.Tel" params="" file="../../xmpp/vcard/Tel.hx"><a>
	<work>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</work>
	<voice>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</voice>
	<video>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</video>
	<pref>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pref>
	<pcs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pcs>
	<pager>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</pager>
	<number><c path="String"/></number>
	<msg>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</msg>
	<modem>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</modem>
	<isdn>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</isdn>
	<home>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</home>
	<fax>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</fax>
	<cell>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</cell>
	<bbs>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</bbs>
</a></typedef>
</haxe>